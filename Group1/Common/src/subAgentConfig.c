/* $Id: subAgentConfig.c,v 1.6 2004/01/14 14:03:33 saisk Exp $*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#ifdef WIN32
#include "../inc/subAgentConfig.h"
#else
#include "subAgentConfig.h"
#endif


/* <Start: WIP_NURI_ALL > */
#define IPADD_LEN 4
#define SUBAGENTINFO_FILE "/usr/local/conf/subAgentInfo.conf"

static void writeToFile();
static void readFromFile();

char gcMasterAgentIP[IPADD_LEN];
int giMasterAgentPort;

char gcSystemAgentIP[IPADD_LEN];
int giSystemAgentPort;
long glSystemAgentOID;

char gcApp1AgentIP[IPADD_LEN];
int giApp1AgentPort;
int giApp1AgentTrapPort;
long glApp1AgentOID;

char gcApp2AgentIP[IPADD_LEN];
int giApp2AgentPort;
int giApp2AgentTrapPort;
long glApp2AgentOID;

char gcApp3AgentIP[IPADD_LEN];
int giApp3AgentPort;
int giApp3AgentTrapPort;
long glApp3AgentOID;

char gcApp4AgentIP[IPADD_LEN];
int giApp4AgentPort;
int giApp4AgentTrapPort;
long glApp4AgentOID;

char gcApp5AgentIP[IPADD_LEN];
int giApp5AgentPort;
int giApp5AgentTrapPort;
long glApp5AgentOID;

/* <End: WIP_NURI_WIN > */

/** Initializes the subAgentConfig module */
void
init_subAgentConfig(void)
{
    static oid appSNMPTrapPort1_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,8, 0 };
    static oid appSNMPTrapPort2_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,12, 0 };
    static oid appSNMPAgentPort1_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,7, 0 };
    static oid appSNMPAgentOID1_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,9, 0 };
    static oid appSNMPTrapPort3_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,16, 0 };
    static oid appSNMPAgentPort2_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,11, 0 };
    static oid appSNMPAgentOID2_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,13, 0 };
    static oid appSNMPTrapPort4_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,20, 0 };
    static oid appSNMPAgentPort3_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,15, 0 };
    static oid appSNMPAgentOID3_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,17, 0 };
    static oid appSNMPTrapPort5_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,24, 0 };
    static oid appSNMPAgentOID4_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,21, 0 };
    static oid appSNMPAgentPort4_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,19, 0 };
    static oid appSNMPAgentOID5_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,25, 0 };
    static oid appSNMPAgentPort5_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,23, 0 };
    static oid systemSNMPAgentIP_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,3, 0 };
    static oid appSNMPAgentIP1_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,6, 0 };
    static oid appSNMPAgentIP2_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,10, 0 };
    static oid systemSNMPOID_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,5, 0 };
    static oid appSNMPAgentIP3_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,14, 0 };
    static oid appSNMPAgentIP4_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,18, 0 };
    static oid appSNMPAgentIP5_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,22, 0 };
    static oid systemSNMPAgentPort_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,4, 0 };
    static oid masterSNMPAgentPort_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,2, 0 };
    static oid masterSNMPAgentIP_oid[] = { 1,3,6,1,4,1,3204,1,3,34,5,1, 0 };

  DEBUGMSGTL(("subAgentConfig", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPTrapPort1",
                               do_appSNMPTrapPort1,
                               appSNMPTrapPort1_oid,
                               OID_LENGTH(appSNMPTrapPort1_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPTrapPort2",
                               do_appSNMPTrapPort2,
                               appSNMPTrapPort2_oid,
                               OID_LENGTH(appSNMPTrapPort2_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentPort1",
                               do_appSNMPAgentPort1,
                               appSNMPAgentPort1_oid,
                               OID_LENGTH(appSNMPAgentPort1_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentOID1",
                               do_appSNMPAgentOID1,
                               appSNMPAgentOID1_oid,
                               OID_LENGTH(appSNMPAgentOID1_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPTrapPort3",
                               do_appSNMPTrapPort3,
                               appSNMPTrapPort3_oid,
                               OID_LENGTH(appSNMPTrapPort3_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentPort2",
                               do_appSNMPAgentPort2,
                               appSNMPAgentPort2_oid,
                               OID_LENGTH(appSNMPAgentPort2_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentOID2",
                               do_appSNMPAgentOID2,
                               appSNMPAgentOID2_oid,
                               OID_LENGTH(appSNMPAgentOID2_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPTrapPort4",
                               do_appSNMPTrapPort4,
                               appSNMPTrapPort4_oid,
                               OID_LENGTH(appSNMPTrapPort4_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentPort3",
                               do_appSNMPAgentPort3,
                               appSNMPAgentPort3_oid,
                               OID_LENGTH(appSNMPAgentPort3_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentOID3",
                               do_appSNMPAgentOID3,
                               appSNMPAgentOID3_oid,
                               OID_LENGTH(appSNMPAgentOID3_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPTrapPort5",
                               do_appSNMPTrapPort5,
                               appSNMPTrapPort5_oid,
                               OID_LENGTH(appSNMPTrapPort5_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentOID4",
                               do_appSNMPAgentOID4,
                               appSNMPAgentOID4_oid,
                               OID_LENGTH(appSNMPAgentOID4_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentPort4",
                               do_appSNMPAgentPort4,
                               appSNMPAgentPort4_oid,
                               OID_LENGTH(appSNMPAgentPort4_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentOID5",
                               do_appSNMPAgentOID5,
                               appSNMPAgentOID5_oid,
                               OID_LENGTH(appSNMPAgentOID5_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentPort5",
                               do_appSNMPAgentPort5,
                               appSNMPAgentPort5_oid,
                               OID_LENGTH(appSNMPAgentPort5_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("systemSNMPAgentIP",
                               do_systemSNMPAgentIP,
                               systemSNMPAgentIP_oid,
                               OID_LENGTH(systemSNMPAgentIP_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentIP1",
                               do_appSNMPAgentIP1,
                               appSNMPAgentIP1_oid,
                               OID_LENGTH(appSNMPAgentIP1_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentIP2",
                               do_appSNMPAgentIP2,
                               appSNMPAgentIP2_oid,
                               OID_LENGTH(appSNMPAgentIP2_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("systemSNMPOID",
                               do_systemSNMPOID,
                               systemSNMPOID_oid,
                               OID_LENGTH(systemSNMPOID_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentIP3",
                               do_appSNMPAgentIP3,
                               appSNMPAgentIP3_oid,
                               OID_LENGTH(appSNMPAgentIP3_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentIP4",
                               do_appSNMPAgentIP4,
                               appSNMPAgentIP4_oid,
                               OID_LENGTH(appSNMPAgentIP4_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("appSNMPAgentIP5",
                               do_appSNMPAgentIP5,
                               appSNMPAgentIP5_oid,
                               OID_LENGTH(appSNMPAgentIP5_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("systemSNMPAgentPort",
                               do_systemSNMPAgentPort,
                               systemSNMPAgentPort_oid,
                               OID_LENGTH(systemSNMPAgentPort_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("masterSNMPAgentPort",
                               do_masterSNMPAgentPort,
                               masterSNMPAgentPort_oid,
                               OID_LENGTH(masterSNMPAgentPort_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("masterSNMPAgentIP",
                               do_masterSNMPAgentIP,
                               masterSNMPAgentIP_oid,
                               OID_LENGTH(masterSNMPAgentIP_oid),
                               HANDLER_CAN_RWRITE));
	readFromFile();
}


int
do_appSNMPAgentIP1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
			(u_char *) gcApp1AgentIP, IPADD_LEN);
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
				requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcApp1AgentIP,
					requests->requestvb->val.string,
					requests->requestvb->val_len);
			writeToFile();
	    	}
	/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentPort1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {
	
	    /* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
			(u_char *) &giApp1AgentPort, 
			sizeof(giApp1AgentPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp1AgentPort = *(requests->requestvb->val.integer);
	    	}
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
do_appSNMPTrapPort1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &giApp1AgentTrapPort, 
				sizeof(giApp1AgentTrapPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp1AgentTrapPort = *(requests->requestvb->val.integer);
	    }
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;
    
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentOID1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &glApp1AgentOID, 
				sizeof(glApp1AgentOID));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	glApp1AgentOID= *(requests->requestvb->val.integer);
	    }
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
do_appSNMPAgentIP2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
			(u_char *) gcApp2AgentIP, IPADD_LEN);
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
				requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcApp2AgentIP,
					requests->requestvb->val.string,
					requests->requestvb->val_len);
			writeToFile();
	    	}
	/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentPort2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {
	
	    /* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
			(u_char *) &giApp2AgentPort, 
			sizeof(giApp2AgentPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp2AgentPort = *(requests->requestvb->val.integer);
	    	}
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
do_appSNMPTrapPort2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &giApp2AgentTrapPort, 
				sizeof(giApp2AgentTrapPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp2AgentTrapPort = *(requests->requestvb->val.integer);
	    }
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;
    
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentOID2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &glApp2AgentOID, 
				sizeof(glApp2AgentOID));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	glApp2AgentOID= *(requests->requestvb->val.integer);
	    }
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
do_appSNMPAgentIP3(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
			(u_char *) gcApp3AgentIP, IPADD_LEN);
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
				requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcApp3AgentIP,
					requests->requestvb->val.string,
					requests->requestvb->val_len);
			writeToFile();
	    	}
	/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentPort3(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {
	
	    /* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
			(u_char *) &giApp3AgentPort, 
			sizeof(giApp3AgentPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp3AgentPort = *(requests->requestvb->val.integer);
	    	}
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
do_appSNMPTrapPort3(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &giApp3AgentTrapPort, 
				sizeof(giApp3AgentTrapPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp3AgentTrapPort = *(requests->requestvb->val.integer);
	    }
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;
    
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentOID3(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &glApp3AgentOID, 
				sizeof(glApp3AgentOID));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	glApp3AgentOID= *(requests->requestvb->val.integer);
	    }
		writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
do_appSNMPAgentIP4(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
			(u_char *) gcApp4AgentIP, IPADD_LEN);
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
				requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcApp4AgentIP,
					requests->requestvb->val.string,
					requests->requestvb->val_len);
				writeToFile();
	    	}
	/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentPort4(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {
	
	    /* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
			(u_char *) &giApp4AgentPort, 
			sizeof(giApp4AgentPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp4AgentPort = *(requests->requestvb->val.integer);
	    	}
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
do_appSNMPTrapPort4(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &giApp4AgentTrapPort, 
				sizeof(giApp4AgentTrapPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp4AgentTrapPort = *(requests->requestvb->val.integer);
	    }
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;
    
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentOID4(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &glApp4AgentOID, 
				sizeof(glApp4AgentOID));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	glApp4AgentOID= *(requests->requestvb->val.integer);
	    }
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
do_appSNMPAgentIP5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
			(u_char *) gcApp5AgentIP, IPADD_LEN);
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
				requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcApp5AgentIP,
					requests->requestvb->val.string,
					requests->requestvb->val_len);
				writeToFile();
	    	}
	/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentPort5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {
	
	    /* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
			(u_char *) &giApp5AgentPort, 
			sizeof(giApp5AgentPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp5AgentPort = *(requests->requestvb->val.integer);
	    	}
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
do_appSNMPTrapPort5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &giApp5AgentTrapPort, 
				sizeof(giApp5AgentTrapPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giApp5AgentTrapPort = *(requests->requestvb->val.integer);
	    }
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;
    
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_appSNMPAgentOID5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &glApp5AgentOID, 
				sizeof(glApp5AgentOID));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	glApp5AgentOID= *(requests->requestvb->val.integer);
	    }
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_systemSNMPAgentIP(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
			(u_char *) gcSystemAgentIP, IPADD_LEN);
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
				requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcSystemAgentIP,
					requests->requestvb->val.string,
					requests->requestvb->val_len);
				writeToFile();
	    	}
	/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_systemSNMPAgentPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {
	
	    /* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
			(u_char *) &giSystemAgentPort, 
			sizeof(giSystemAgentPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giSystemAgentPort = *(requests->requestvb->val.integer);
	    	}
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
do_systemSNMPOID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
				(u_char *) &glSystemAgentOID, 
				sizeof(glSystemAgentOID));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
	case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	glSystemAgentOID= *(requests->requestvb->val.integer);
	    }
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int 
do_masterSNMPAgentIP(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

	/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
			(u_char *) gcMasterAgentIP, IPADD_LEN);
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
				requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcMasterAgentIP,
					requests->requestvb->val.string,
					requests->requestvb->val_len);
				writeToFile();
	    	}
	/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_masterSNMPAgentPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {
	
	    /* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
			(u_char *) &giMasterAgentPort, 
			sizeof(giMasterAgentPort));
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, 
				SNMP_ERR_COMMITFAILED);
            } else {
	    	giMasterAgentPort = *(requests->requestvb->val.integer);
	    	}
			writeToFile(); 
		/* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

void writeToFile() {
	FILE *fp;
	int i;
	char tempBuff[10];
	fp=fopen(SUBAGENTINFO_FILE,"w");
	if(fp!=NULL){
		// The Sub Agent Ports
		fprintf(fp,"%d\n",giMasterAgentPort);
		fprintf(fp,"%d\n",giSystemAgentPort);
		fprintf(fp,"%d\n",giApp1AgentPort);
		fprintf(fp,"%d\n",giApp1AgentTrapPort);
		fprintf(fp,"%d\n",giApp2AgentPort);
		fprintf(fp,"%d\n",giApp2AgentTrapPort);
		fprintf(fp,"%d\n",giApp3AgentPort);
		fprintf(fp,"%d\n",giApp3AgentTrapPort);
		fprintf(fp,"%d\n",giApp4AgentPort);
		fprintf(fp,"%d\n",giApp4AgentTrapPort);
		fprintf(fp,"%d\n",giApp5AgentPort);
		fprintf(fp,"%d\n",giApp5AgentTrapPort);

		//OIDs
		fprintf(fp,"%d\n",glSystemAgentOID);
		fprintf(fp,"%d\n",glApp1AgentOID);
		fprintf(fp,"%d\n",glApp2AgentOID);
		fprintf(fp,"%d\n",glApp3AgentOID);
		fprintf(fp,"%d\n",glApp4AgentOID);
		fprintf(fp,"%d\n",glApp5AgentOID);
		
		
		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcMasterAgentIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}

		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcSystemAgentIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}

		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcApp1AgentIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}

		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcApp2AgentIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}
	
		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcApp3AgentIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}
	
		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcApp4AgentIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}
	
		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcApp5AgentIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}

		fflush(fp);
		fclose(fp);
	}
}


void readFromFile() {
	FILE *fp;
	int i;
	char tempBuff[10];
	fp=fopen(SUBAGENTINFO_FILE,"r");
	if(fp!=NULL){

		// The Sub Agent Ports
		fscanf(fp,"%d\n",&giMasterAgentPort);
		fscanf(fp,"%d\n",&giSystemAgentPort);
		fscanf(fp,"%d\n",&giApp1AgentPort);
		fscanf(fp,"%d\n",&giApp1AgentTrapPort);
		fscanf(fp,"%d\n",&giApp2AgentPort);
		fscanf(fp,"%d\n",&giApp2AgentTrapPort);
		fscanf(fp,"%d\n",&giApp3AgentPort);
		fscanf(fp,"%d\n",&giApp3AgentTrapPort);
		fscanf(fp,"%d\n",&giApp4AgentPort);
		fscanf(fp,"%d\n",&giApp4AgentTrapPort);
		fscanf(fp,"%d\n",&giApp5AgentPort);
		fscanf(fp,"%d\n",&giApp5AgentTrapPort);

		//OIDs
		fscanf(fp,"%d\n",&glSystemAgentOID);
		fscanf(fp,"%d\n",&glApp1AgentOID);
		fscanf(fp,"%d\n",&glApp2AgentOID);
		fscanf(fp,"%d\n",&glApp3AgentOID);
		fscanf(fp,"%d\n",&glApp4AgentOID);
		fscanf(fp,"%d\n",&glApp5AgentOID);

		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcMasterAgentIP[i]=atoi(tempBuff);
		}
	
		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcSystemAgentIP[i]=atoi(tempBuff);
		}
	
		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcApp1AgentIP[i]=atoi(tempBuff);
		}
	
		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcApp2AgentIP[i]=atoi(tempBuff);
		}
	
		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcApp3AgentIP[i]=atoi(tempBuff);
		}

		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcApp4AgentIP[i]=atoi(tempBuff);
		}

		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcApp5AgentIP[i]=atoi(tempBuff);
		}

		fclose(fp);
	}
}

/* <End: WIP_NURI_ALL > */
