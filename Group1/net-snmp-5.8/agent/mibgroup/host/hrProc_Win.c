/*****************************************************************************
 *
 * filename.c: [hrProc_Win.c]
 *
 *      Copyright (c) 2002 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name : Ashok Shankar
 *
 * description :
 *      [ Collecting information about Processors present in the System ]
 *
 * TODO:
 *      [ Find the no. of Processors dynamically using PDH calls]
 *
 * CM Details:
 *
 * $Author: karthis $
 * $Log: hrProc_Win.c,v $
 * Revision 1.4  2004/01/21 05:16:31  karthis
 * updated CPULOAD
 *
 * Revision 1.3  2003/11/27 15:47:23  ashok
 * Minor Changes
 *
 * Revision 1.2  2003/11/10 06:45:52  ashok
 * no message
 *
 * Revision 1.1  2003/10/31 12:08:44  ashok
 * Added into CVS by Ashok
 *
 * $State: Exp $
 * $Id: hrProc_Win.c,v 1.4 2004/01/21 05:16:31 karthis Exp $
 * $Name: NASCenterAgent_29Jan2004_Patch3_SrcRls $ 
 *
 ****************************************************************************/
/* Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/********************************* includes *********************************/
#include <net-snmp/net-snmp-config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <windows.h>
//For Registering with Device Table
#include "host_res_Win.h"
#include "hrProc_Win.h"
#include <net-snmp/agent/auto_nlist.h>
#include <net-snmp/agent/agent_read_config.h>
#include "ucd-snmp/loadave.h"
#include "../NuriEnterprise/Win32/inc/NASCenter_EM_PDHCommon_Win.h"

/****************************** local macros ********************************/
// For Index Genaration
#define HRPROC_MONOTONICALLY_INCREASING
#define	HRPROC_ID		1
#define	HRPROC_LOAD		2

/********************* local structure/union definitions ********************/

/********************* prototypes for local functions ***********************/
int header_hrproc(struct variable *, oid *, size_t *, int,size_t *, 
				  WriteMethod **);

/************************ globals within this module*************************/
SYSTEM_INFO gstSysInfo;
int         procLoad = 0;
PDH_FMT_COUNTERVALUE gCPUPDHFmtValue;

/************************ externs *************************/
extern void     Init_HR_Proc(void);
extern int      Get_Next_HR_Proc(void);

/************************ statics *************************/
static int      HRP_index;

    /*********************
 *
 *  Initialisation & common implementation functions
 *
 *********************/
/* 
 * variable4 hrNetworkEntry_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 hrproc_variables[] = {
    {HRPROC_ID, ASN_OBJECT_ID, RONLY, var_hrproc, 2, {1, 1}},
    {HRPROC_LOAD, ASN_INTEGER, RONLY, var_hrproc, 2, {1, 2}}
};
/* 
 * hrproc_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             hrproc_variables_oid[] = { 1, 3, 6, 1, 2, 1, 25, 3, 3 };

/** Initializes the hrproc module */
void init_hr_proc(void)
{
	//For Registering in hrDevice Table.
    init_device[HRDEV_PROC] = Init_HR_Proc;
    next_device[HRDEV_PROC] = Get_Next_HR_Proc;
#ifdef HRPROC_MONOTONICALLY_INCREASING
    dev_idx_inc[HRDEV_PROC] = 1;
#endif

    REGISTER_MIB("host/hr_proc", hrproc_variables, variable4,
                 hrproc_variables_oid);
	/* <Start: WIP_NURI_WIN: Addition - added code for collecting system 
	parameters> */
	GetSystemInfo(&gstSysInfo);
	
}

/*
 * header_hrproc(...
 * Arguments:
 * vp     IN      - pointer to variable entry that points here
 * name    IN/OUT  - IN/name requested, OUT/name found
 * length  IN/OUT  - length of IN/OUT oid's 
 * exact   IN      - TRUE if an exact match was requested
 * var_len OUT     - length of variable or 0 if function returned
 * write_method
 * 
 */

int header_hrproc(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method)
{
	
#define HRPROC_ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int             proc_idx, LowIndex = -1;
    int             result;
	
    DEBUGMSGTL(("host/hr_proc", "var_hrproc: "));
    DEBUGMSGOID(("host/hr_proc", name, *length));
    DEBUGMSG(("host/hr_proc", " %d\n", exact));

    memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));
    /*
     * Find "next" proc entry 
     */

    Init_HR_Proc();

    for (;;) {
		proc_idx = Get_Next_HR_Proc();
        if (proc_idx == -1)
            break;
        newname[HRPROC_ENTRY_NAME_LENGTH] = proc_idx;
        result = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (result == 0)) {
            LowIndex = proc_idx;
            /*
             * Save processor status information 
             */
            break;
        }
        if ((!exact && (result < 0)) &&
            (LowIndex == -1 || proc_idx < LowIndex)) {
            LowIndex = proc_idx;
            /*
             * Save processor status information 
             */
#ifdef HRPROC_MONOTONICALLY_INCREASING
            break;
#endif
        }
    }

    if (LowIndex == -1) {
        DEBUGMSGTL(("host/hr_proc", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,
           (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    DEBUGMSGTL(("host/hr_proc", "... get proc stats "));
    DEBUGMSGOID(("host/hr_proc", name, *length));
    DEBUGMSG(("host/hr_proc", "\n"));
	
    return LowIndex;
}

    /*********************
 *
 *  System specific implementation functions
 *
 *********************/

u_char * var_hrproc(struct variable * vp,
           oid * name,
           size_t * length,
           int exact, size_t * var_len, WriteMethod ** write_method)
{
    int             proc_idx;
    char                    PDHpath [MAX_PATH];
 
	
	
    proc_idx = header_hrproc(vp, name, length, exact, var_len, write_method);
    if (proc_idx == MATCH_FAILED)
		
        return NULL;

    //if (try_getloadavg(&avenrun[0], sizeof(avenrun) / sizeof(avenrun[0]))
        //== -1)
        //return NULL;

    switch (vp->magic) {
    case HRPROC_ID:
        *var_len = sizeof(gstSysInfo.wProcessorArchitecture);
        return (u_char *) &gstSysInfo.wProcessorArchitecture;
		
    case HRPROC_LOAD:
		
	/*#if NO_DUMMY_VALUES
        return NULL;
	#endif */
       strcpy(PDHpath,"\\Processor(_Total)\\% Processor Time");
        COMPDH_CollectionTime(PDHpath, &gCPUPDHFmtValue);
        DEBUGMSGTL(("NURICPU","Path: %s ,load : %ld\n",PDHpath,gCPUPDHFmtValue.longValue));
        procLoad= gCPUPDHFmtValue.longValue;
       *var_len = sizeof(procLoad);       
        return (u_char *) &procLoad; 
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_hrproc\n",
                    vp->magic));
    }
	
	
    return NULL;
		
}


/*********************
 *
 *  Internal implementation functions for Index Generation
 *
 *********************/
/*****************************************************************************
 *
 * name             :   Init_HR_Proc
 * description      :   Initializing the static Index variable HRP_index
 * input parameters :   _
 * return type      :   _
 * global variables :   _
 * calls            :   _
 */
void Init_HR_Proc(void)
{
    HRP_index = 0;
	
}

/*****************************************************************************
 *
 * name             :   Get_Next_HR_Proc
 * description      :   Increments the static Index variable HRP_index and 
 *						generates the index
 * input parameters :   _
 * return type      :   int
 * global variables :   _
 * calls            :   _
 */
int Get_Next_HR_Proc(void)
{    
    if (HRP_index < 1)
        return ((HRDEV_PROC << HRDEV_TYPE_SHIFT) + HRP_index++);
    else
        return -1;
}

