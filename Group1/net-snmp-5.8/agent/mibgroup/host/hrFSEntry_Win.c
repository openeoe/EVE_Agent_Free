/*****************************************************************************
 *
 * [hrFSEntry_Win.c]
 *
 *      Copyright (c) 2003 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name : Karthikeyan Subramani
 *
 * description :
 *      [ This file is used for MIB instrumentation for HOST MIB - hrFilesystem]
 *
 * TODO:
 *      [ Things to be improved ]
 *
 * CM Details:
 *
 * $Author: howonsuk $
 * $Log: hrFSEntry_Win.c,v $
 * Revision 1.2  2004/03/03 09:09:03  howonsuk
 * timecache계산에 절대값 사용
 *
 * Revision 1.1  2004/03/03 06:14:17  howonsuk
 * 로그모니터링: 정규식 추가
 * 프로세스모니터링 : 파라미터보여주기 및 파라미터에서 정규식으로 찾기 추가
 *
 * $State: Exp $  
 * $Id: hrFSEntry_Win.c,v 1.2 2004/03/03 09:09:03 howonsuk Exp $
 * $Name:  $
 *
 ****************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */


/********************************* includes *********************************/
#define _WIN32_WINNT 0x0501

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "hrFSEntry_Win.h"
#include "host_res_Win.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "hrDiskStorageEntry_Win.h"
#include <Winnetwk.h>






/****************************** local macros ********************************
 *
 * (Macros shareable with rest of the modules are present in .h file)
 */


#define HRFS_MONOTONICALLY_INCREASING
#define BUFSIZE MAX_PATH        
#define FILESYSNAMEBUFSIZE MAX_PATH
#define NOOFDRIVE 50
#define DRIVENAME 100



/********************* local structure/union definitions ********************/


/********************* prototypes for local functions ***********************/
void Get_Vol(char drive[50]);
BOOL ProcessVolumeMountPoint (HANDLE ,char *, DWORD ,  char *, DWORD );
BOOL ProcessVolume (char *, int );
void Get_Dat(void);
int Remotemount(void);
int Get_Next_HR_FS(void);
void Init_HR_FS(void);

/************************* Globals within this module ***********************/

// All data collected and maintained here 
int giFSind[BUFSIZE];
int giinde=0;
char gcstrnull[5];
int long glaccess[NOOFDRIVE];
int gicoun;  // Maintains Index Count
int gig;
int gierror;
int giret;
int ginl;
long gifs[NOOFDRIVE];
int gistatus;
NETRESOURCE gNR[NOOFDRIVE];
char gcvolume[NOOFDRIVE][DRIVENAME];
char giremote[NOOFDRIVE][DRIVENAME];
char gilocalname[NOOFDRIVE][DRIVENAME];
char gcDrive[NOOFDRIVE][DRIVENAME];
int  gsi[NOOFDRIVE];
int  giboot[NOOFDRIVE];
int gionce=0;
int gicd=0;
int gifunc_count = 0;
int      giHRP_index;


 /* 
 * hrFSEntry_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid hrFSEntry_variables_oid[] = { 1,3,6,1,2,1,25,3,8,1 };
    oid             fsys_type_id[] = { 1, 3, 6, 1, 2, 1, 25, 3, 9, 1 };     /* hrFSOther */
    int             fsys_type_len =
                         sizeof(fsys_type_id) / sizeof(fsys_type_id[0]);




/* 
 * variable4 hrFSEntry_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 hrFSEntry_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define HRFSMOUNTPOINT		1
{HRFSMOUNTPOINT,  ASN_OCTET_STR,  RONLY ,  var_hrFSEntry, 1,  { 2 }},
#define HRFSREMOTEMOUNTPOINT		2
{HRFSREMOTEMOUNTPOINT,  ASN_OCTET_STR,  RONLY ,  var_hrFSEntry, 1,  { 3 }},
#define HRFSINDEX		3
{HRFSINDEX,  ASN_INTEGER,  RONLY ,  var_hrFSEntry, 1,  { 1 }},
#define HRFSTYPE		4
{HRFSTYPE,  ASN_OBJECT_ID,  RONLY ,  var_hrFSEntry, 1,  { 4 }},
#define HRFSLASTFULLBACKUPDATE		5
{HRFSLASTFULLBACKUPDATE,  ASN_OCTET_STR,  RWRITE,  var_hrFSEntry, 1,  { 8 }},
#define HRFSLASTPARTIALBACKUPDATE		6
{HRFSLASTPARTIALBACKUPDATE,  ASN_OCTET_STR,  RWRITE,  var_hrFSEntry, 1,  { 9 }},
#define HRFSSTORAGEINDEX		7
{HRFSSTORAGEINDEX,  ASN_INTEGER,  RONLY ,  var_hrFSEntry, 1,  { 7 }},
#define HRFSACCESS		8
{HRFSACCESS,  ASN_INTEGER,  RONLY ,  var_hrFSEntry, 1,  { 5 }},
#define HRFSBOOTABLE		9
{HRFSBOOTABLE,  ASN_INTEGER,  RONLY ,  var_hrFSEntry, 1,  { 6 }},

};


/************************* externs  ***********************/



/* <start : WIP_NURI_WIN: Addition -added code to support the HOST FILE SYSTEM MIB Variables >*/

/*    (L = length of the oidsuffix) */

        /*********************
	 *
	 *  Internal implementation functions
	 *
	 *********************/




// Process each mount point found here. This makes maintenance easier 
// than doing it in line. The result indicates whether there is 
// another mount point to be scanned.

// This routine prints out the path to a mount point and its target.
// Supported OS version Windows XP and 2000 


/*****************************************************************************
 *
 * name             :   [ProcessVolumeMountPoint.c]
 * description      :   [Detect the volume mount]
 * input parameters :   [HANDLE hPt]  - Handler
 *                      [char *PtBuf]  - pointer to output string
 *                      [char *Buf] - root path of volume to be scanned
                        [DWORD dwBufSize] - size of output buffer
 * output parameters:   [volume[g]]  - Target of the volume mount point 
 *                      [datatype var2]  - description for var2, etc..
 * return type      :   [BOOL]
 * global variables :   [volume array]
 * calls            :   [ ProcessVolume ]  
 * Operating System :   Winodws 2000/ XP
 */




#ifndef WINNT

BOOL ProcessVolumeMountPoint (HANDLE hPt,
                         char *PtBuf, DWORD dwPtBufSize,
                                char *Buf, DWORD dwBufSize)
{
   BOOL bFlag;                   // Boolean result   
   char Path[BUFSIZE];           // construct a complete path here
   char Target[BUFSIZE];         // target of mount at mount point

   DEBUGMSGTL(("mountpoint","mount point:%s\n",PtBuf));

   sprintf (gcvolume[gig],"%s", PtBuf);
   gig++;

   /* Detect the volume mounted there. Unfortunately, there is no 
    * simple way to map a unique volume name to a DOS drive letter. 
    * One way to do that is to build an associative array, which we 
    * will "leave as an exercise for the student." 
	*/

   // Build a unique path to the mount point

   strcpy (Path, Buf);
   strcat (Path, PtBuf);

   /* osversion Windows 2000 / XP
    * input volume mount point or directory
    * output volume name buffer
    * size of volume name buffer
	*/

   bFlag = GetVolumeNameForVolumeMountPoint( 
                Path, 
              Target, 
              BUFSIZE 
           );

   
   /* Now, either get the next mount point and return it, or return a 
    * value indicating there are no more mount points.
    * osversion Windows 2000 / XP
    * handle to scan
    * pointer to output string
    * size of output buffer
	*/

   bFlag = FindNextVolumeMountPoint( 
                     hPt, 
                   PtBuf,
              dwPtBufSize 
           );
  return (bFlag);
}

/* End of ProcessVolumeMountPoint.c */


/*****************************************************************************
 *
 * name             :   [ProcessVolume]
 * description      :   [ Process each volume]
 * input parameters :   [HANDLE hVol]  - Handler
 *                      [char *Buf]  - unique volume name 
                        [int iBufSize]- Length of the buffer to receive the name 
 * output parameters:   [volume[g]]  -  Target of the volume mount point 
 *                     
 * return type      :   [BOOL]
 * global variables :   [ Volume array]
 * calls            :   [ Get_Vol ]
 * Operating Systems:   Windows 2000/XP
 */


/* Process each volume. This makes maintenance easier than doing it
 * in line. The Boolean result indicates whether there is another 
 * volume to be scanned. 
 */

BOOL ProcessVolume ( char *Buf, int iBufSize)
{
   BOOL bFlag;                  
   HANDLE hPt;                  
   char PtBuf[BUFSIZE];       
   DWORD dwSysFlags;            
   char FileSysNameBuf[FILESYSNAMEBUFSIZE];

   

   // Is this volume NTFS?   Windows OS Version NT / XP / 2000
   GetVolumeInformation( Buf, NULL, 0, NULL, NULL, 
                         &dwSysFlags, FileSysNameBuf, 
                         FILESYSNAMEBUFSIZE);

   // Detect support for reparse points, and therefore for volume 
   // mount points, which are implemented using reparse points.

   if (! (dwSysFlags & FILE_SUPPORTS_REPARSE_POINTS)) 
   {
      sprintf (gcvolume[gig],"This file system does not support volume mount points");
	  gig++;
   } 
   else 
   {
      /* Start processing mount points on this volume. 
	   * Windows Version 2000 / XP
	   * root path of volume to be scanned
	   * pointer to output string
	   * size of output buffer
	   */


      hPt = FindFirstVolumeMountPoint( 
                  Buf, 
                PtBuf, 
               BUFSIZE 
            );

      if (hPt == INVALID_HANDLE_VALUE)
      {
         sprintf (gcvolume[gig],"No volume mount points found!");
		 gig++;
      } 
      else 
      {
         // Process the volume mount point.
         bFlag = ProcessVolumeMountPoint (hPt, PtBuf, BUFSIZE, Buf, BUFSIZE); 

         // Do while we have volume mount points to process.
         while (bFlag) 
         {
            ginl++;
            bFlag = ProcessVolumeMountPoint (hPt, PtBuf, BUFSIZE, Buf, BUFSIZE);
         }

         FindVolumeMountPointClose(hPt);
       }
   }

   /* Stop processing mount points on this volume. 
    * OS Version Windows 2000 / XP
    * handle to scan being conducted
    * pointer to output
    * size of output buffer
	*/


   return (0); 
}

/* End of ProcessVolume.c */

/*****************************************************************************
 *
 * name             :   [Get_Vol]
 * description      :   [To intitate the detection of Volume mount point]
 * input parameters :   [void]  - input parameters will not be supplied 
 * output parameters:   [datatype var1]  - description for var1
 * return type      :   [void] - No output parameters
 * global variables :   [global variables will not be used]
 * calls            :   [var_hrFSEntry]
 * Operating Systems:   Windows 2000 / XP
 */


void Get_Vol(char drive[50])
{     
      char buf[BUFSIZE];            // buffer for unique volume identifiers
      BOOL bFlag;                   // generic results flag
      
  
	      bFlag = GetVolumeNameForVolumeMountPoint(
                 drive, 
                  buf, // output volume name buffer
               BUFSIZE // size of volume name buffer
           );
          DEBUGMSGTL(("drive","Drive :%s\n",drive));
		



		// We have a volume; process it.
		bFlag = ProcessVolume (buf, BUFSIZE);

		// Do while we have volumes to process.
	

                        
}
#endif
/* End of Get_Vol.c */

/*****************************************************************************
 *
 * name             :   [Get_Dat]
 * description      :   [Get all information regarding Filesystems except volume mount points]
 * input parameters :   [void]  - input parameters will not be supplied 
 * output parameters:   [datatype var1]  - description for var1
 * return type      :   [void] - No output parameters]
 * global variables :   [ access[NOOFDRIVE],coun,g,fs[NOOFDRIVE],status,volume[NOOFDRIVE][DRIVENAME];
 *			             Once,int func_count = 0;]
 * calls            :   [ var_hrFSEntry]
 * Operating Systems:   Windows 2000/XP, NT
 */



/**********************************************************************************************
*                                COMMENTS  
* This function will get the logical drive strings and seperate the strings and that string will 
* be used for FILESYSTEM as well as IOCTL DISK IS WRITABLE 
* Filesystem can be found out by using the API get volume information
* and disk is writable can be found out by using create file will be supplied with the string that 
* has been extracted from the logical drive strings. if this function suceeds that handle will 
* be given as argument to IOCTL inorder to check whether that particular disk is writable or not
************************************************************************************************/
// Supported OS Version windows NT , 2000 , XP 

void Get_Dat(void)
{	
	
	char Buf[BUFSIZE];
    static char str[BUFSIZE];
    static unsigned int i;
    static unsigned int j;
    static unsigned int l;
    static unsigned int m;
    static unsigned int n;
    static unsigned int k;
    DWORD buffer;
    DWORD count;
    char s[BUFSIZE];
    char d[BUFSIZE];
    DWORD dwSysFlags;            // flags that describe the file system
    char FileSysNameBuf[FILESYSNAMEBUFSIZE];
    DWORD sectorpercluster;
    DWORD bytespersector;
    DWORD nooffreeclust;
    DWORD totalclust;
    BOOL fr;
    UINT oldmode;
    UINT type;
    HANDLE hDevice;               // handle to the drive to be examined 
    BOOL bResult;                 // results flag
    DWORD junk; 
    char driverName[MAX_PATH];
    static int z;
    int p=0;
    int si=0;
    int tip,tap,tsi=0;
    int sti=0;
    int rc=0;
	DWORD bytesReturned;
	PARTITION_INFORMATION_EX dDrive;
    PPARTITION_INFORMATION pDrive;
	DWORD bytesret;
    HANDLE deviceHandle;
    BYTE Buffer[2048];
    int nResult;
	unsigned long lReturnByte;

    i=j=k=l=m=n=k=z=p=0;
	snmp_log(LOG_INFO,"Get_Dat\n");
    for(i=0;i<NOOFDRIVE;i++)
    memset(giremote[i],'\0',DRIVENAME);


    buffer=BUFSIZE;
    /* Used for Timer 
    * OS Version all windows version
    */
    gifunc_count=GetTickCount();
  
    /* used to get logical drives from the system
    * Os Version all windows version
    */
    count=GetLogicalDriveStrings(buffer,Buf);
	DEBUGMSGTL(("hrFSEntity","GetLogicalDriverString [%d]\n", count));
    for(i=0;i<count;i++)
    {   
        oldmode=SetErrorMode(SEM_FAILCRITICALERRORS); // Serious errors are handled by process 
        // OS Version all windows version

        if(Buf[i]!='\0' && Buf[i]!='\\')
        {
            s[j]=Buf[i];

            j++;
        }
	
        if(Buf[i]=='\0')
        {
            gicoun++;
            gsi[si++]=++sti;
            s[j]='\0';
            strcpy(str,"\\\\.\\");
            strcat(str,s); 
            strcpy(d,s);
            strcat(d,"\\");
            strcpy(gcDrive[m],d);
            ginl=0;
            //Get_Vol(d);
            type=GetDriveType(d);
            /* To get type of drive
            * OS Version all windows version 
            */
            switch(type)
            {

                case DRIVE_REMOVABLE :
                    gistatus=1;
                    break;
                case DRIVE_FIXED :
                    gistatus=2;
                    break;
                case DRIVE_REMOTE :
                   gistatus=3;
                   DEBUGMSGTL(("driveremote","Inside remote\n"));
				   
                   for(rc=0;rc<giret;rc++)
                   {
                     if(gNR[rc].lpLocalName)
                     if(!stricmp(gNR[rc].lpLocalName,s))
                      {
                            break;
                            
                      }

                    }
                    sprintf (giremote[gicoun-1],"%s",gNR[rc].lpRemoteName );
                    break;
                case DRIVE_CDROM :
                    gistatus=4;
                    break;
                case DRIVE_RAMDISK :
                    gistatus=5;
                    break;  
            }

                sprintf(driverName, "\\\\.\\%s", s);
				DEBUGMSGTL(("hrFSEntity","Find DriveName [%s]\n", driverName));
                deviceHandle = CreateFile(driverName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
		                NULL, OPEN_EXISTING, 0, NULL );
	                            
	                
				if (deviceHandle != INVALID_HANDLE_VALUE) 
				{
	                
						nResult = DeviceIoControl(	deviceHandle, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, 
						Buffer, sizeof(Buffer), &lReturnByte, NULL );
				   
					if(nResult)
					{
						pDrive=Buffer;
						giboot[k]=pDrive->BootIndicator;
						if(pDrive->BootIndicator==0)
						 giboot[k]=2;   

					}
					else
					{
					   giboot[k]=2;   
					}
				}
                else
				{  
				   giboot[k]=2;   
				}
            
                if(deviceHandle)
                CloseHandle(deviceHandle);


            if(gistatus==1 || gistatus==4)
            {
				
                SetLastError(ERROR_SUCCESS); 
                fr=GetDiskFreeSpace(d,&sectorpercluster,&bytespersector,&nooffreeclust,&totalclust);		 
                if(GetLastError( )!=ERROR_SUCCESS)
                {
                    gierror=1;
                    SetLastError(ERROR_SUCCESS);
                }
                else
                gierror=0;
            }
            else 
            gierror=0;
            if(gierror==0)
            { 
                /*To find out the Filesystem type
                *OS Version all windows verison
                */
                GetVolumeInformation( d, NULL, 0, NULL, NULL,
                &dwSysFlags, FileSysNameBuf, 
                FILESYSNAMEBUFSIZE);

                if(!strcmp(FileSysNameBuf,"NTFS"))
                {
                    gifs[m]=2;
                    m++;
                }
                if(!strcmp(FileSysNameBuf,"FAT"))
                {
                    gifs[m]=1;
                    m++;
                }
                if(!strcmp(FileSysNameBuf,"FAT32"))
                {
                    gifs[m]=3;
                    m++;
                }
                if(!strcmp(FileSysNameBuf,"CDFS"))
                {
                    gifs[m]=4;
                    m++;
                }
                
                      
                strcpy(s,"\0");
                j=0;

   
                /* OS Version all windows Version
                *  drive to open
                *  no access to the drive
                *  share mode
                *  default security attributes
                *  disposition
                *  file attributes
                *  do not copy file attributes
                */
                hDevice = CreateFile(str,
                0,             
                FILE_SHARE_WRITE,         
                NULL,          
                OPEN_EXISTING,    
                0,                
                NULL);          
                
                
                if (hDevice == INVALID_HANDLE_VALUE) 
                {
                    glaccess[k]=-1;
                    k++;
                    break;
                }

                                

				
                if(DeviceIoControl(hDevice,IOCTL_DISK_GET_PARTITION_INFO_EX,NULL,0, &dDrive,
                       sizeof(dDrive),&bytesret,
                        NULL))
               {
                  giboot[k]=dDrive.Mbr.BootIndicator;  
				  if(dDrive.Mbr.BootIndicator==0)
				  giboot[k]=2;    

               }
			    
                  
                
                /* OS Version Windows 2000/ XP 
                * device to be queried
                * operation to perform
                * no input buffer
                * output buffer
                * # bytes returned*/

                bResult = DeviceIoControl(hDevice, 
                IOCTL_DISK_IS_WRITABLE,  
                NULL, 0, 
                NULL,0,     
                &junk,                 
                (LPOVERLAPPED) NULL);

                CloseHandle(hDevice);

                if (bResult) 
                {
                    glaccess[k]=1;
                    k++;
                }
                else  
                {
                    glaccess[k]=2;
                    k++;
                }
            }
            else if (gierror==1)
            {
                glaccess[k]=2;  
				giboot[k++]=2;
                gifs[m++]=5;
            }
            j=0;		
            if(ginl>0)
            {
              tip=gifs[m-1]; 
              tap=glaccess[k-1];
              tsi=gsi[si-1];
              for(p=0;p<ginl;p++)
              {
                  glaccess[k++]=tap;
                  gifs[m++]=tip;
                  gsi[si++]=tsi;
              }
              gicoun+=ginl;
            }

        }
            
    }

}

/* End of Get_Dat.c */


/*****************************************************************************
 *
 * name             :   Init_HR_FS
 * description      :   It will intialize the index
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [giHRP_index]
 * calls            :   [header_hrfs() ]
 */
void
Init_HR_FS(void)
{
    giHRP_index = 1;
}

/* End of Init_HR_FS  */

/*****************************************************************************
 *
 * name             :   Get_Next_HR_FS
 * description      :   It will increment the index
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [giHRP_index,coun]
 * calls            :   [header_hrdisk() ]
 */
	

int
Get_Next_HR_FS(void)
{
    /*
	  This is the place where index variable coun has been used for index generation
     */

    if (giHRP_index <= gicoun)
        return (giHRP_index++);
    else
        return -1;
}
/* End of Init_HR_FS  */


/*****************************************************************************
 *
 * name             :   [Remotemount]
 * description      :   [Detect whether Remote Drives are mapped with logical Drives]
 * input parameters :   [void]  - No Input parameters supplied
 * output parameters:   [NETRESOURCE]  -  IP Address and attached path
 * return type      :   [int] - Count of Remote Mount Drives
 * global variables :   [NR]
 * calls            :   [ var_hrFSEntry]
 * Operating System :   Windows 2000/ XP, NT 4.0 Service Pack 6
 */

/* This function is used to check the remote drives available in the system.
This function will return the count of remote drives*/
int Remotemount(void)  
{           DWORD Co = 0xFFFFFFFF;
			DWORD Size = sizeof(NETRESOURCE) * 30;
			DWORD Res1;
			HANDLE EnumHandle;
    
	       /* OS Version all windows version
			*TO check for existing remote connections 
		    */
			Res1 = WNetOpenEnum( 
					RESOURCE_CONNECTED, RESOURCETYPE_DISK,
					0, 0, &EnumHandle);
			Res1 = WNetEnumResource(  
				EnumHandle, &Co, &gNR, &Size);
				WNetCloseEnum(EnumHandle); // closing the handle
				return Co;
}
/* End of Remotemount.c*/

/*****************************************************************************
 *
 * name             :   header_hrfs
 * description      :   It will generate the index
 * input parameters :   [struct variable *vp,
 *                       oid * name,
 *                        size_t * length,
 *                        int exact, size_t * var_len, WriteMethod ** write_method]   
 * output parameters:   [void] -  No output Parameters
 * return type      :   [int] - index  
 * global variables :   [giHRP_index]
 * calls            :   [var_hrDiskStorageEntry ]
 */
int
header_hrfs(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method)
{
#define HRFS_ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int             fs_idx, LowIndex = -1;
    int             result;

    DEBUGMSGTL(("host/hr_fs", "var_hrfs: "));
    DEBUGMSGOID(("host/hr_fs", name, *length));
    DEBUGMSG(("host/hr_fs", " %d\n", exact));
	

    memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));
    /*
     * Find "next" disk entry 
     */
 
    Init_HR_FS();
    for (;;) {
        fs_idx = Get_Next_HR_FS();
        if (fs_idx == -1)
            break;
        newname[HRFS_ENTRY_NAME_LENGTH] = fs_idx;
        result = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (result == 0)) {
            LowIndex = fs_idx;
            /*
             * Save diskessor status information 
             */
            break;
        }
        if ((!exact && (result < 0)) &&
            (LowIndex == -1 || fs_idx < LowIndex)) {
            LowIndex = fs_idx;
            /*
             * Save diskessor status information 
             */
#ifdef HRFS_MONOTONICALLY_INCREASING
          break;
#endif
        }
    }

    if (LowIndex == -1) {
        DEBUGMSGTL(("host/hr_fs", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,
           (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    DEBUGMSGTL(("host/hr_fs", "... get disk stats "));
    DEBUGMSGOID(("host/hr_fs", name, *length));
    DEBUGMSG(("host/hr_fs", "\n"));
	
	giinde=LowIndex;

    return LowIndex;
}

/*End of header_hrfs*/



/*
 * var_hrFSEntry():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */

unsigned char *
var_hrFSEntry(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    int             fs_idx;
 	static int i;
    static int l;
    static int remo;
    char *st= " ";
	int var_count;
	
	var_count = GetTickCount();

     fs_idx =
        header_hrfs(vp, name, length, exact, var_len, write_method);
    if (fs_idx == MATCH_FAILED)
        return NULL;
	    
	if(abs(var_count-gifunc_count)>500)
		  {     gig=0;
			    gicoun=0;
				remo=0;
			    giret=Remotemount();
                Get_Dat();
	            gionce=0;
			
		  }

	/* Inorder to maintain the value 
	 * because get volume mount point will give floppy drive at the end
	 * But normally all other functions will give floppy 
	 * drive at the beginning inorder to maintain
	 * the same index this swap required   
	 */

     /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
     case HRFSMOUNTPOINT:
             // *var_len=strlen(gcvolume[giinde-1]);
	          //return (u_char*) gcvolume[giinde-1];
           *var_len=strlen(gcDrive[giinde-1]);
           return (u_char*) gcDrive[giinde-1];
     case HRFSREMOTEMOUNTPOINT:                             
               *var_len=strlen(giremote[giinde-1]);
                return (u_char*) giremote[giinde-1];
               break;
    case HRFSINDEX:
		 *var_len=sizeof(giinde);
		 return (u_char*) &giinde;
         break;
    case HRFSTYPE:
		 if(gifs[giinde-1]== 3)
		 fsys_type_id[fsys_type_len - 1] = 22;
		 if(gifs[giinde-1]== 2)
			  fsys_type_id[fsys_type_len - 1] = 9;
         if(gifs[giinde-1]== 1)
			  fsys_type_id[fsys_type_len - 1] = 5; 
         if(gifs[giinde-1]== 4)
             fsys_type_id[fsys_type_len - 1] = 1;
         if(gifs[giinde-1]== 5)
             fsys_type_id[fsys_type_len - 1] = 2;

	     *var_len = sizeof(fsys_type_id);
         return (u_char *) fsys_type_id;
		 break;
         /*HRFSLASTFULLBACKUPDATE:
           *write_method = write_hrFSLastFullBackupDate;
           VAR = VALUE;	
           return (u_char*) &VAR;
           HRFSLASTPARTIALBACKUPDATE:
           *write_method = write_hrFSLastPartialBackupDate;
           VAR = VALUE;	
           return (u_char*) &VAR;*/
    case HRFSSTORAGEINDEX:
		 *var_len=sizeof(gsi[giinde-1]);
		 return (u_char*) &gsi[giinde-1];
         break;
    case HRFSACCESS:
		 *var_len=sizeof(glaccess[giinde-1]);
		 return (u_char*) &glaccess[giinde-1];
         break;
	case HRFSBOOTABLE:
		  *var_len=sizeof(giboot[giinde-1]);
		  return (u_char*) &giboot[giinde-1];
    default:
      ERROR_MSG("");
    }

    return NULL;
}


/* End : WIP_NURI_WIN */

/** Initializes the hrFSEntry module */
void
init_hrFSEntry(void)
{	

 DEBUGMSGTL(("hrFSEntry", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("hrFSEntry", hrFSEntry_variables, variable4,
               hrFSEntry_variables_oid);

    /* place any other initialization junk you need here */
	// all functions will collect the value and maintained in the array
    
    giret=Remotemount();     
	Get_Dat();
}





int
write_hrFSLastFullBackupDate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to hrFSEntry not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to hrFSEntry: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_hrFSLastPartialBackupDate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to hrFSEntry not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to hrFSEntry: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}





