/*****************************************************************************
 *
 * [hrProc_Win_PDH.c]
 *
 *      Copyright (c) 2002 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name : Ashok Shankar
 *
 * description :
 *      [ Collecting information about Processors present in the System ]
 *
 * TODO:
 *      [ Find the no. of Processors dynamically using PDH calls]
 *
 * CM Details:
 *
 * $Author: howonsuk $
 * $Log: hrProc_Win_PDH.c,v $
 * Revision 1.2  2004/03/03 09:09:03  howonsuk
 * timecache계산에 절대값 사용
 *
 * Revision 1.1  2004/03/03 06:14:19  howonsuk
 * 로그모니터링: 정규식 추가
 * 프로세스모니터링 : 파라미터보여주기 및 파라미터에서 정규식으로 찾기 추가
 *
 * Revision 1.8  2003/12/11 04:40:19  ashok
 * removed OS Version
 *
 * Revision 1.7  2003/12/11 04:37:57  ashok
 * removed OS Version
 *
 * Revision 1.6  2003/11/27 15:47:30  ashok
 * Minor Changes
 *
 * Revision 1.5  2003/11/20 06:22:07  ashok
 * Minor Corrections
 *
 * Revision 1.4  2003/11/14 15:11:34  ashok
 * Changes made to CollectTime Function
 *
 * Revision 1.3  2003/11/10 11:03:52  ashok
 * new version
 *
 * Revision 1.2  2003/11/10 06:46:02  ashok
 * no message
 *
 * Revision 1.1  2003/10/31 12:08:44  ashok
 * Added into CVS by Ashok
 *
 * $State: Exp $
 * $Id: hrProc_Win_PDH.c,v 1.2 2004/03/03 09:09:03 howonsuk Exp $
 * $Name:  $ 
 *
 ****************************************************************************/
/* Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/********************************* includes *********************************/
#include <net-snmp/net-snmp-config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <windows.h>
#include <pdh.h>
//#include <lib.h>
//For Registering with Device Table
#include "host_res_Win.h"
#include "hrProc_Win.h"
#include <net-snmp/agent/auto_nlist.h>
#include <net-snmp/agent/agent_read_config.h>
#include "NASCenter_EM_PDHCommon_Win.h"

#include <stdlib.h>
/****************************** local macros ********************************/
// For Index Genaration
#define HRPROC_MONOTONICALLY_INCREASING
#define	HRPROC_ID	 1
#define	HRPROC_LOAD	 2

// Cache Time
#define CACHETIME    5000

// Maximum processor count
#define MAXPROCESSOR 100

// PDH Instance Length
#define PDHBUFFLENGTH 4096

/********************* local structure/union definitions ********************/

/********************* prototypes for local functions ***********************/
int header_hrproc(struct variable *, oid *, size_t *, int,size_t *, 
				  WriteMethod **);
void HRPROCGet_Data(void);
void HRPROCGet_Data2(int num);

/************************ globals within this module*************************/
SYSTEM_INFO             gstSysInfo;

//Time Stamps
int                     giHRPROCTimeStamp;

//Count for number of processes
int                     giNoProcessors;


//PDH related Inits
TCHAR                   gaProcInstance [MAXPROCESSOR][MAX_PATH];
int                     gaProcessorID  [MAXPROCESSOR];
int                     gaProcLoad     [MAXPROCESSOR];

//counter structures 
PDH_FMT_COUNTERVALUE	gstHRPROCPDHFmtValue;

/************************ externs *************************/
extern void     Init_HR_Proc(void);
extern int      Get_Next_HR_Proc(void);

/************************ statics *************************/
static int      HRP_index;

 
/* 
 * variable4 hrproc_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 hrproc_variables[] = {
    {HRPROC_ID, ASN_OBJECT_ID, RONLY, var_hrproc, 2, {1, 1}},
    {HRPROC_LOAD, ASN_INTEGER, RONLY, var_hrproc, 2, {1, 2}}
};
/* 
 * hrproc_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             hrproc_variables_oid[] = { 1, 3, 6, 1, 2, 1, 25, 3, 3 };

/*****************************************************************************
 *
 * name             :   HRPROCGet_Data
 * description      :   Data Collection & Index Limitation Module
 * input parameters :   _
 * return type      :   _
 * global variables :   giHRPROCTimeStamp, gaProcInstance, giNoProcessors
 *                      gstHRPROCPDHFmtValue, gaProcLoad    
 * calls            :   _
 */
void HRPROCGet_Data(void)
{
    PDH_STATUS  status = 0;

    int         row = 0;
	int         col=0;
	int         i,j;
	char        pathName[MAX_PATH];
	int start_time = 0;
	int end_time = 0;
	
	TCHAR       mszCounterList   [PDHBUFFLENGTH];
	TCHAR       mszInstanceList  [PDHBUFFLENGTH];
	
	
	DWORD       ccghProcCounterList = sizeof(mszCounterList) / sizeof(TCHAR);
	DWORD       cchInstanceList = sizeof(mszInstanceList) / sizeof(TCHAR);
    
    //Get the TimeStamp during Entry
	giHRPROCTimeStamp = GetTickCount();

	//For Collecting Info From System
	status = PdhEnumObjectItems(NULL,NULL,"Processor",mszCounterList,
                &ccghProcCounterList,mszInstanceList,&cchInstanceList,
                PERF_DETAIL_WIZARD,0 );
	
	//Formatting the Arrays
	for(i = 0,j = 1;(mszInstanceList[i] != '\0' || mszInstanceList[j] != '\0')
          ;i++,j++)
	{
		//To Avoid adding Null at the begining of new string
		if(mszInstanceList[i] != '\0')
		{
			gaProcInstance[row][col] = mszInstanceList[i];
			col++;
		}

		//To Complete a Row
		if(mszInstanceList[j] == '\0')
		{
			//cout<<endl;
			gaProcInstance[row][col] = '\0';
			col = 0;
			row++;
		}
	}
    giNoProcessors = row-1;

	// Setting cpuID to Instance name
    for(i=0;i<giNoProcessors;i++){
		//DEBUGMSG(("host/hr_proc", "gaProcInstance[%d]=%s\n",i,gaProcInstance[i]));
        gaProcessorID[i] = atoi(gaProcInstance[i]);
	}
	
	//start_time = GetTickCount();
	//Collecting Actual Values
	for(i=0;i<giNoProcessors;i++)
	{
		//Performance Counter Monitoring
		strcpy(pathName,"\\Processor(");
		strcat(pathName,gaProcInstance[i]);
		strcat(pathName,")\\");
		
		strcat(pathName,"% Processor Time");
		// Collect Data using common PDH Function
        COMPDH_CollectionTime(pathName, &gstHRPROCPDHFmtValue);
        gaProcLoad[i] = gstHRPROCPDHFmtValue.longValue;
		
	}
	//end_time = GetTickCount() - start_time;
	//DEBUGMSG(("host/hr_proc", "Processor @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \t%d\n", end_time));
}

/*****************************************************************************
 *
 * name             :   HRPROCGet_Data
 * description      :   Data Collection & Index Limitation Module
 * input parameters :   _
 * return type      :   _
 * global variables :   giHRPROCTimeStamp, gaProcInstance, giNoProcessors
 *                      gstHRPROCPDHFmtValue, gaProcLoad    
 * calls            :   _
 */
void HRPROCGet_Data_Once(int num)
{
    PDH_STATUS  status = 0;

    int         row = 0;
	int         col=0;
	int         i,j;
	char        pathName[MAX_PATH];
	int start_time = 0;
	int end_time = 0;
	
	TCHAR       mszCounterList   [PDHBUFFLENGTH];
	TCHAR       mszInstanceList  [PDHBUFFLENGTH];
	
	
	DWORD       ccghProcCounterList = sizeof(mszCounterList) / sizeof(TCHAR);
	DWORD       cchInstanceList = sizeof(mszInstanceList) / sizeof(TCHAR);
    
    //Get the TimeStamp during Entry
	giHRPROCTimeStamp = GetTickCount();

	//For Collecting Info From System
	status = PdhEnumObjectItems(NULL,NULL,"Processor",mszCounterList,
                &ccghProcCounterList,mszInstanceList,&cchInstanceList,
                PERF_DETAIL_WIZARD,0 );
	
	//Formatting the Arrays
	for(i = 0,j = 1;(mszInstanceList[i] != '\0' || mszInstanceList[j] != '\0')
          ;i++,j++)
	{
		//To Avoid adding Null at the begining of new string
		if(mszInstanceList[i] != '\0')
		{
			gaProcInstance[row][col] = mszInstanceList[i];
			col++;
		}

		//To Complete a Row
		if(mszInstanceList[j] == '\0')
		{
			//cout<<endl;
			gaProcInstance[row][col] = '\0';
			col = 0;
			row++;
		}
	}
    giNoProcessors = row-1;

	// Setting cpuID to Instance name
    for(i=0;i<giNoProcessors;i++){
		//DEBUGMSG(("host/hr_proc", "gaProcInstance[%d]=%s\n",i,gaProcInstance[i]));
        gaProcessorID[i] = atoi(gaProcInstance[i]);
	}
	
	//start_time = GetTickCount();
	//Collecting Actual Values
	//for(i=0;i<giNoProcessors;i++)
	//{
	//Performance Counter Monitoring
	strcpy(pathName,"\\Processor(");
	strcat(pathName,gaProcInstance[num]);
	strcat(pathName,")\\");
	
	strcat(pathName,"% Processor Time");
	
	// Collect Data using common PDH Function
    COMPDH_CollectionTime(pathName, &gstHRPROCPDHFmtValue);
    gaProcLoad[num] = gstHRPROCPDHFmtValue.longValue;
	//}
	//end_time = GetTickCount() - start_time;
	//DEBUGMSG(("host/hr_proc", "Processor @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \t%d\n", end_time));
}

/** Initializes the hrproc module */
void init_hr_proc(void)
{
	//For Registering in hrDevice Table.
	int start_time=0;
	int end_time=0;

    init_device[HRDEV_PROC] = Init_HR_Proc;
    next_device[HRDEV_PROC] = Get_Next_HR_Proc;
#ifdef HRPROC_MONOTONICALLY_INCREASING
    dev_idx_inc[HRDEV_PROC] = 1;
#endif

    REGISTER_MIB("host/hr_proc", hrproc_variables, variable4,
                 hrproc_variables_oid);
	/* <Start: WIP_NURI_WIN: Addition - added code for collecting system 
	parameters> */
	
	start_time=GetTickCount();
	HRPROCGet_Data();
	
	end_time=GetTickCount()-start_time;

	//DEBUGMSG(("host/hr_proc", "init_time=%d\n", end_time));
}

/*
 * header_hrproc(...
 * Arguments:
 * vp     IN      - pointer to variable entry that points here
 * name    IN/OUT  - IN/name requested, OUT/name found
 * length  IN/OUT  - length of IN/OUT oid's 
 * exact   IN      - TRUE if an exact match was requested
 * var_len OUT     - length of variable or 0 if function returned
 * write_method
 * 
 */

int header_hrproc(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method)
{
	
#define HRPROC_ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int             proc_idx, LowIndex = -1;
    int             result;
	
    DEBUGMSGTL(("host/hr_proc", "var_hrproc: "));
    DEBUGMSGOID(("host/hr_proc", name, *length));
    DEBUGMSG(("host/hr_proc", " %d\n", exact));

    memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));
    /*
     * Find "next" proc entry 
     */

    Init_HR_Proc();

    for (;;) {
		
		proc_idx = Get_Next_HR_Proc();
		//DEBUGMSG(("host/hr_proc", "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%d\n", proc_idx));
		//DEBUGMSG(("host/hr_proc", " %d\n", exact));
        if (proc_idx == -1)
            break;
        newname[HRPROC_ENTRY_NAME_LENGTH] = proc_idx;
        result = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (result == 0)) {
            LowIndex = proc_idx;
            /*
             * Save processor status information 
             */
            break;
        }
        if ((!exact && (result < 0)) &&
            (LowIndex == -1 || proc_idx < LowIndex)) {
            LowIndex = proc_idx;
            /*
             * Save processor status information 
             */
#ifdef HRPROC_MONOTONICALLY_INCREASING
            break;
#endif
        }
    }

    if (LowIndex == -1) {
        DEBUGMSGTL(("host/hr_proc", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,
           (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    DEBUGMSGTL(("host/hr_proc", "... get proc stats "));
    DEBUGMSGOID(("host/hr_proc", name, *length));
    DEBUGMSG(("host/hr_proc", "\n"));
	
    return LowIndex;
}

    /*********************
 *
 *  System specific implementation functions
 *
 *********************/

u_char * var_hrproc(struct variable * vp,
           oid * name,
           size_t * length,
           int exact, size_t * var_len, WriteMethod ** write_method)
{
    int             proc_idx;

    //TimeStamp.
	int var_hrpro=0;
    //int start_time=0;
	//int end_time=0;
	//Get the TimeStamp during Entry
	var_hrpro = GetTickCount();
	proc_idx = header_hrproc(vp, name, length, exact, var_len, write_method);
	
    //Decide whether to call HRPROCGet_Data( )
    //if(abs(var_hrpro - giHRPROCTimeStamp) > CACHETIME){
	//start_time=GetTickCount();
	HRPROCGet_Data_Once(HRP_index);
	//end_time=GetTickCount()-start_time;

	//DEBUGMSG(("host/hr_proc", "init_time=%d\n", end_time));
	//}

    if (proc_idx == MATCH_FAILED)
        return NULL;

    switch (vp->magic) {
    case HRPROC_ID:
        /*var_len = sizeof(gstSysInfo.wProcessorArchitecture);
        return (u_char *) &gstSysInfo.wProcessorArchitecture;*/
		DEBUGMSG(("host/hr_proc", "gaProcessorID[%d]=%d\n",HRP_index,gaProcessorID[HRP_index] ));
        *var_len = sizeof(gaProcessorID[HRP_index]);
        return (u_char *) &gaProcessorID[HRP_index];
		
    case HRPROC_LOAD:
		DEBUGMSG(("host/hr_proc", "gaProcLoad[%d]=%d\n",HRP_index,gaProcLoad[HRP_index] ));
        *var_len = sizeof(gaProcLoad[HRP_index]);
        return (u_char *) &gaProcLoad[HRP_index];

    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_hrproc\n",
                    vp->magic));
    }
	
    return NULL;
		
}


/*********************
 *
 *  Internal implementation functions for Index Generation
 *
 *********************/
/*****************************************************************************
 *
 * name             :   Init_HR_Proc
 * description      :   Initializing the static Index variable HRP_index
 * input parameters :   _
 * return type      :   _
 * global variables :   _
 * calls            :   _
 */
void Init_HR_Proc(void)
{
    HRP_index = -1;
}

/*****************************************************************************
 *
 * name             :   Get_Next_HR_Proc
 * description      :   Increments the static Index variable HRP_index and 
 *						generates the index
 * input parameters :   _
 * return type      :   int
 * global variables :   _
 * calls            :   _
 */
int Get_Next_HR_Proc(void)
{    
    if (HRP_index < giNoProcessors-1)
        return ((HRDEV_PROC << HRDEV_TYPE_SHIFT) + ++HRP_index);
    else
        return -1;
}

