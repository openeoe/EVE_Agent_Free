/*****************************************************************************
 *
 * [hrNetworkEntry_Win.c]
 *
 *      Copyright (c) 2002 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name : Ashok Shankar
 *
 * description :
 *      [ Collecting information about the Network devices present in the 
 *		  System ]
 *
 * TODO:
 *      [ ]
 *
 * CM Details:
 * 
 * $Author: ashok $
 * $Log: hrNetworkEntry_Win.c,v $
 * Revision 1.6  2003/12/25 08:12:29  ashok
 * Added Variable to save the values before freeing the structure
 *
 * Revision 1.5  2003/12/04 06:25:18  ashok
 * Minor Changes
 *
 * Revision 1.4  2003/11/27 15:46:57  ashok
 * Minor Changes
 *
 * Revision 1.3  2003/11/20 06:21:50  ashok
 * Minor Corrections
 *
 * Revision 1.2  2003/11/08 15:22:11  ashok
 * no message
 *
 * Revision 1.1  2003/10/31 12:08:44  ashok
 * Added into CVS by Ashok
 *
 * $State: Exp $
 * $Id: hrNetworkEntry_Win.c,v 1.6 2003/12/25 08:12:29 ashok Exp $
 * $Name: NASCenterAgent_29Jan2004_Patch3_SrcRls $ 
 *
 ****************************************************************************/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */
/********************************* includes *********************************/
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "hrNetworkEntry_Win.h"

// For Registering with Device Table
#include "host_res_Win.h"
#include <windows.h>
#include <Iphlpapi.h>

/****************************** local macros ********************************/
// For Index Genaration
#define HRN_MONOTONICALLY_INCREASING
#define MAX_INTERFACES 1000

/********************* local structure/union definitions ********************/

/********************* prototypes for local functions ***********************/
int     header_hrnet(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method);

//Function Prototypes for Index Generation
void    Init_HR_Network(void);
int     Get_Next_HR_Network(void);

/************************ globals within this module*************************/
// Variables for Collecting System Parameters
PMIB_IFTABLE gpstIfTable;
int          giNetInterfaceIndex[MAX_INTERFACES];

// Variable for Index No.
int giNetIndex;

/************************ externs *************************/

/************************ statics *************************/
static int HRN_index;

/* 
 * variable4 hrNetworkEntry_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 hrNetworkEntry_variables[] = 
{
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define HRNETWORKIFINDEX		1
	{HRNETWORKIFINDEX,  ASN_INTEGER,  RONLY ,  var_hrNetworkEntry, 1,  { 1 }},

};
/* 
 * hrNetworkEntry_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid hrNetworkEntry_variables_oid[] = { 1,3,6,1,2,1,25,3,4,1 };

/*    (L = length of the oidsuffix) */

/** Initializes the hrNetworkEntry module */
void init_hrNetworkEntry(void)
{
	ULONG pdwSize = 0;
	DWORD result = NO_ERROR;
    int i;
	
	//For Registering in hrDevice Table.
	init_device[HRDEV_NETWORK] = Init_HR_Network;
    next_device[HRDEV_NETWORK] = Get_Next_HR_Network;
	
    DEBUGMSGTL(("hrNetworkEntry", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("hrNetworkEntry", hrNetworkEntry_variables, variable4,
               hrNetworkEntry_variables_oid);

    /* place any other initialization junk you need here */
	/* <Start: WIP_NURI_WIN: Addition - added code for collecting system 
	parameters> */
	result = GetIfTable(gpstIfTable,&pdwSize,TRUE);

	if(result == ERROR_INSUFFICIENT_BUFFER)
	{
		gpstIfTable = (PMIB_IFTABLE) malloc(pdwSize);
		if (gpstIfTable != NULL)
			result = GetIfTable(gpstIfTable,&pdwSize,TRUE);
	}
	if(result != NO_ERROR)
	{
		giNetIndex = 0;
		return;
	}
    giNetIndex = gpstIfTable->dwNumEntries;

    for(i=0;i<giNetIndex;i++)
        giNetInterfaceIndex[i] = gpstIfTable->table[i].dwIndex;
	free(gpstIfTable);
}


/*
 * header_hrnet(...
 * Arguments:
 * vp     IN      - pointer to variable entry that points here
 * name    IN/OUT  - IN/name requested, OUT/name found
 * length  IN/OUT  - length of IN/OUT oid's 
 * exact   IN      - TRUE if an exact match was requested
 * var_len OUT     - length of variable or 0 if function returned
 * write_method
 * 
 */
int header_hrnet(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method)
{
	
#define HRNET_ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int             net_idx, LowIndex = -1;
    int             result;
	//int				i;
	

	
    DEBUGMSGTL(("host/hr_nettab", "var_nettab: "));
    DEBUGMSGOID(("host/hr_nettab", name, *length));
    DEBUGMSG(("host/hr_nettab", " %d\n", exact));

    memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));
    /*
     * Find "next" nettab entry 
     */
	
    Init_HR_Network();

    for (;;)
	{
        net_idx = Get_Next_HR_Network();
        if (net_idx == -1)
            break;
        newname[HRNET_ENTRY_NAME_LENGTH] = net_idx;
        result = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (result == 0))
		{
            LowIndex = net_idx;

            /*
             * Save network status information 
             */
            break;
        }
        if ((!exact && (result < 0)) &&
            (LowIndex == -1 || net_idx < LowIndex))
		{
            LowIndex = net_idx;
            /*
             * Save network status information 
             */
#ifdef HRN_MONOTONICALLY_INCREASING
            break;
#endif
        }
    }

    if (LowIndex == -1)
	{
        DEBUGMSGTL(("host/hr_nettab", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,
           (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    DEBUGMSGTL(("host/hr_nettab", "... get nettab stats "));
    DEBUGMSGOID(("host/hr_nettab", name, *length));
    DEBUGMSG(("host/hr_nettab", "\n"));
	

    return LowIndex;
}



/*
 * var_hrNetworkEntry():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char * var_hrNetworkEntry(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

	// For Index generation.
	int             net_idx;
   

    net_idx = header_hrnet(vp, name, length, exact, var_len, write_method);
    
	if (net_idx == MATCH_FAILED)

        return NULL;

     /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case HRNETWORKIFINDEX:
		*var_len = sizeof(giNetInterfaceIndex[HRN_index-1]);
		return (u_char*) &(giNetInterfaceIndex[HRN_index-1]);
        //VAR = VALUE;	/* XXX */
        //return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*********************
 *
 *  Internal implementation functions for Index Generation
 *
 *********************/
/*****************************************************************************
 *
 * name             :   Init_HR_Network
 * description      :   Initializing the static Index variable HRN_index
 * input parameters :   _
 * return type      :   _
 * global variables :   _
 * calls            :   _
 */
void  Init_HR_Network(void)
{
    HRN_index = 0;
}

/*****************************************************************************
 *
 * name             :   Get_Next_HR_Network
 * description      :   Increments the static Index variable HRN_index and 
 *						generates the index
 * input parameters :   _
 * return type      :   int
 * global variables :   _
 * calls            :   _
 */
int Get_Next_HR_Network(void)
{
	if (HRN_index < giNetIndex)
		return ((HRDEV_NETWORK << HRDEV_TYPE_SHIFT) + ++HRN_index);
	else
        return -1;
}



