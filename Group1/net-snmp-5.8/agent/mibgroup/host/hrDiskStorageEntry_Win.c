/*****************************************************************************
 *
 * [hrDiskStorageEntry_Win.c]
 *
 *      Copyright (c) 2002 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name Karthikeyan Subramani
 *
 * description :
 *      [ TO get the disk storage details]
 *
 * TODO:
 *      [ Things to be improved ]
 *
 * CM Details:
 *
 * $Author: howonsuk $
 * $Log: hrDiskStorageEntry_Win.c,v $
 * Revision 1.2  2004/03/03 09:09:03  howonsuk
 * timecache계산에 절대값 사용
 *
 * Revision 1.1  2004/03/03 06:14:17  howonsuk
 * 로그모니터링: 정규식 추가
 * 프로세스모니터링 : 파라미터보여주기 및 파라미터에서 정규식으로 찾기 추가
 *
 * $State: Exp $  
 * $Id: hrDiskStorageEntry_Win.c,v 1.2 2004/03/03 09:09:03 howonsuk Exp $
 * $Name:  $
 ****************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/********************************* includes *********************************/

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "hrDiskStorageEntry_Win.h"
#include "host_res_Win.h"
#include <windows.h>
#include <winioctl.h>
#include <stdlib.h>

#define HRDISK_MONOTONICALLY_INCREASING
#define BUFSIZE MAX_PATH        
#define FILESYSNAMEBUFSIZE MAX_PATH
#define NOOFDRIVE 50




/****************************** local macros ********************************
 *
 * (Macros shareable with rest of the modules are present in .h file)
 */




/********************* local structure/union definitions ********************/



/********************* prototypes for local functions ***********************/
void Get_Data(void);
void Init_HR_Disk(void);
int Get_Next_HR_Disk(void);
int header_hrdisk(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method);



/************************* Globals within this module ***********************/

oid hrDiskStorageEntry_variables_oid[] = { 1,3,6,1,2,1,25,3,6,1 };


long glaccess[NOOFDRIVE];
int  gifunc=0;
long glrem[NOOFDRIVE];
long glrr[NOOFDRIVE];
unsigned long glspace[NOOFDRIVE];
int  giFix=0;
int  gierror=0;
int  giHRP_index;
int Dcoun=0;
 
 /* 
 * hrDiskStorageEntry_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/* 
 * variable4 hrDiskStorageEntry_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 hrDiskStorageEntry_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define HRDISKSTORAGEACCESS		1
{HRDISKSTORAGEACCESS,  ASN_INTEGER,  RONLY ,  var_hrDiskStorageEntry, 1,  { 1 }},
#define HRDISKSTORAGEREMOVEBLE		2
{HRDISKSTORAGEREMOVEBLE,  ASN_INTEGER,  RONLY ,  var_hrDiskStorageEntry, 1,  { 3 }},
#define HRDISKSTORAGEMEDIA		3
{HRDISKSTORAGEMEDIA,  ASN_INTEGER,  RONLY ,  var_hrDiskStorageEntry, 1,  { 2 }},
#define HRDISKSTORAGECAPACITY		4
{HRDISKSTORAGECAPACITY,  ASN_INTEGER,  RONLY ,  var_hrDiskStorageEntry, 1,  { 4 }},

};
/*    (L = length of the oidsuffix) */

        /*********************
	 *
	 *  Internal implementation functions
	 *
	 *********************/


/************************* externs  ***********************/


/*****************************************************************************
 *
 * name             :   Init_HR_Disk
 * description      :   It will intialize the index
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [giHRP_index]
 * calls            :   [header_hrdisk() ]
 */
void Init_HR_Disk(void)
{
    giHRP_index = 1;
}

/* End of Init_HR_Disk  */


/*****************************************************************************
 *
 * name             :   Get_Data
 * description      :   It will collect entire details of the disk
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [glrem,glrr,giFix,glspace,glaccess]
 * calls            :   [var_hrDiskStorageEntry() ]
 */
 
void Get_Data(void)
{	
    char Buf[1024];
  //  static char *str;
	char str[MAX_PATH] = {0,};
    static char *p;
    int phy=48;
    static unsigned int i;
    static unsigned int j;
    static unsigned int k;
    static unsigned int l;
    static unsigned int m;
    static unsigned int n;
    DWORD buffer,count;
    char s[50];
    char d[50];
    int gierror;
    UINT oldmode;

    DISK_GEOMETRY pdg; 
    ULONGLONG DiskSize;
    HANDLE hDevice;               // handle to the drive to be examined 
    BOOL bResult;                 // results flag
    BOOL bRes,fr;
    DWORD junk; 
    DWORD sectorpercluster,bytespersector,nooffreeclust,totalclust;
    UINT type;

    gifunc=GetTickCount();
//    str=(char*) malloc(MAX_PATH);
    if(str !=NULL)
    {
        memset(str,MAX_PATH,sizeof(char)); 
        buffer=BUFSIZE;
        l=j=k=l=m=n=0;
        gierror=0;
        count=GetLogicalDriveStrings(buffer,Buf);  // To separate the Drive Strings
        for(i=0;i<count;i++)
        {
            if(Buf[i]!='\0' && Buf[i]!='\\')
            {
                s[j]=Buf[i];
                j++;
            }
             // If a Drive String is seperated  get drive type and disk free space
            oldmode=SetErrorMode(SEM_FAILCRITICALERRORS);
            if(Buf[i]=='\0')  
            {	
                s[j]='\0';    
                strcpy(str,"\\\\.\\");
                strcat(str,s); 
                strcpy(d,s);
                strcat(d,"\\");
                SetLastError(ERROR_SUCCESS); 

                fr=GetDiskFreeSpace(d,&sectorpercluster,
                   &bytespersector,&nooffreeclust,&totalclust);		 
                if(GetLastError()!=ERROR_SUCCESS)
                {
                    gierror=1;
                    SetLastError(ERROR_SUCCESS);
                }
                else
                gierror=0;
                type=GetDriveType(d);
                switch(type)
                {
                    case DRIVE_UNKNOWN : 
                        glrem[l]= 2;
                        l++;   
                        Dcoun++;
                        break;
                    case DRIVE_NO_ROOT_DIR : 
                        glrem[l]= 1;
                        l++;
                        Dcoun++;
                        break;
                    case DRIVE_REMOVABLE :
                        glrem[l]= 4;
                        glrr[m]=1;
                        m++;
                        l++;
                        Dcoun++;
                        giFix=0;
                        break;
                    case DRIVE_FIXED :
                    if(giFix!=-1)
                        giFix=1; 
                    break;
                    case DRIVE_CDROM :
                        glrem[l]= 5;
                        glrr[m]=1;
                        m++;
                        l++;
                        Dcoun++;
                        giFix=0;
                        break;
                    case DRIVE_REMOTE :
                        giFix=5;
                        break;
                    case DRIVE_RAMDISK :
                        glrem[l]= 8;
                        l++;
                        glrr[m]=1;
                        m++;
                        giFix=0;
                        Dcoun++;
                        break;  

                }

                if(giFix ==1) 
                {            
                    p=str;   
                    strcpy(str,"\\\\.\\PhysicalDrive0");
                    while(*p)
                    p++;
                    if(*p=='\0')
                    {
                        p--;
                        *p=(char)phy;
                        phy++;
                    }

                }
                /* OS Version all windows Version
                *  drive to open
                *  no access to the drive
                *  share mode
                *  default security attributes
                *  disposition
                *  file attributes
                *  do not copy file attributes
                */
         if(giFix!=5)
             {
                hDevice = CreateFile(str, 
                0,                 
                FILE_SHARE_READ |  
                FILE_SHARE_WRITE, 
                NULL,              
                OPEN_EXISTING,     
                0,                 
                NULL);             

                if (hDevice == INVALID_HANDLE_VALUE)  
                    giFix=-1;

                if(giFix==1)
                { 
                    glrem[l]= 3;
                    l++;
                    glrr[m]=2;
                    m++;
                    Dcoun++;
                }

                /* device to be queried
                * operation to perform
                * no input buffer
                * output buffer
                * # bytes returned
                */

                if(giFix!=-1)  
                {
                    bResult = DeviceIoControl(hDevice,
                    IOCTL_DISK_IS_WRITABLE, 
                    NULL, 0, 
                    NULL,0,     
                    &junk,      
                    (LPOVERLAPPED) NULL);


                    /* OS Version Windows NT 4.0 service pack 6/XP/2000
                    * device to be queried
                    * operation to perform
                    * no input buffer
                    * output buffer
                    *  # bytes returned
                    *  synchronous I/O
                    */
                  if(giFix==1)
                  {
                    bRes = DeviceIoControl(hDevice,  
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,  
                    NULL, 0, 
                    &pdg, sizeof(pdg),     
                    &junk,               
                    (LPOVERLAPPED) NULL); 
                     CloseHandle(hDevice); 
                       


                    if(bRes)
                    {  // Caluclating Disk Size in terms of kilobytes

                        DiskSize = pdg.Cylinders.QuadPart * (ULONG)pdg.TracksPerCylinder *
                        (ULONG)pdg.SectorsPerTrack * (ULONG)pdg.BytesPerSector;
                        glspace[n]=DiskSize / 1024;
                        if(gierror==1)
                        glspace[n]=0;
                        n++;
                    } 
                   }

                    /* sometimes create file will return invalid handle for floppy drive
                    * inorder to avoid the incorrect value to be returned in that case 
                    * get disk free space is used to calculate the disk value.
                    */
                    if (giFix!=1)
                    {
                        DiskSize=(sectorpercluster*totalclust);
                        DiskSize*=bytespersector;
                        DiskSize/=1024;
                        glspace[n]=DiskSize;
                        if(gierror==1)
                        glspace[n]=0;
                        n++;
                        CloseHandle(hDevice);
						hDevice = INVALID_HANDLE_VALUE;
                    }
                    if (bResult) 
                    {
                        glaccess[k]=1;
                        k++;
                    }
                    else if (hDevice != INVALID_HANDLE_VALUE)
                    {
                        glaccess[k]=2;
                        k++;
                    }
                }
             }
            j=0;
            }
        }
    }
    //if(str!=NULL)
    //free(str);
	if(INVALID_HANDLE_VALUE != hDevice)
		CloseHandle(hDevice);
    SetErrorMode(0);
}

/* End of Get_Data  */

/*****************************************************************************
 *
 * name             :   Get_Next_HR_Disk
 * description      :   It will increment the index
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [giHRP_index,coun]
 * calls            :   [header_hrdisk() ]
 */

int
Get_Next_HR_Disk(void)
{
    /*
     * This is used for index generation and index coun variable is give nhere
	 */

    if (giHRP_index <= Dcoun)
       // return (giHRP_index++);
	    return ((HRDEV_DISK << HRDEV_TYPE_SHIFT)+giHRP_index++);
    else
	    return -1;
	
	
}

/*End of Get_Next_HR_Disk*/

/** Initializes the hrDiskStorageEntry module */
void
init_hrDiskStorageEntry(void)
{

	
	init_device[HRDEV_DISK] = Init_HR_Disk;
    next_device[HRDEV_DISK] = Get_Next_HR_Disk;

	

#ifdef HR_MONOTONICALLY_INCREASING
    dev_idx_inc[HRDEV_DISK] = 1;
#endif




    DEBUGMSGTL(("hrDiskStorageEntry", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("hrDiskStorageEntry", hrDiskStorageEntry_variables, variable4,
               hrDiskStorageEntry_variables_oid);

    /* place any other initialization junk you need here */
	/*place where we call a function inorder to collect the data*/
	 
     Get_Data();
	 

}


/*****************************************************************************
 *
 * name             :   header_hrdisk
 * description      :   It will generate the index
 * input parameters :   [struct variable *vp,
 *                       oid * name,
 *                        size_t * length,
 *                        int exact, size_t * var_len, WriteMethod ** write_method]   
 * output parameters:   [void] -  No output Parameters
 * return type      :   [int] - index  
 * global variables :   [giHRP_index]
 * calls            :   [var_hrDiskStorageEntry ]
 */

int header_hrdisk(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method)
{
	#define HRDISK_ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int             disk_idx, LowIndex = -1;
    int             result;

    DEBUGMSGTL(("host/hr_disk", "var_hrdisk: "));
    DEBUGMSGOID(("host/hr_disk", name, *length));
    DEBUGMSG(("host/hr_disk", " %d\n", exact));

    memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));
    /*
     * Find "next" disk entry 
     */
     Init_HR_Disk();
    for (;;) {
        disk_idx = Get_Next_HR_Disk();
        if (disk_idx == -1)
            break;
        newname[HRDISK_ENTRY_NAME_LENGTH] = disk_idx;
        result = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (result == 0)) {
            LowIndex = disk_idx;
            /*
             * Save diskessor status information 
             */
            break;
        }
        if ((!exact && (result < 0)) &&
            (LowIndex == -1 || disk_idx < LowIndex)) {
            LowIndex = disk_idx;
            /*
             * Save diskessor status information 
             */
	#ifdef HRDISK_MONOTONICALLY_INCREASING
            break;
	#endif
        }
    }

    if (LowIndex == -1) {
        DEBUGMSGTL(("host/hr_disk", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,
           (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    DEBUGMSGTL(("host/hr_disk", "... get disk stats "));
    DEBUGMSGOID(("host/hr_disk", name, *length));
    DEBUGMSG(("host/hr_disk", "\n"));
    return LowIndex;
}

/* End of header_hrdisk  */



/*
 * var_hrDiskStorageEntry():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_hrDiskStorageEntry(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
	static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
	static int in;
	 int             disk_idx;
	 int var_count;
	
	var_count = GetTickCount();
	
      disk_idx =
        header_hrdisk(vp, name, length, exact, var_len, write_method);
    if (disk_idx == MATCH_FAILED)
	    return NULL;
		
 
	if(abs(var_count-gifunc)>500)
		 { Dcoun=0;
	     giFix=0;
	     Get_Data();
	  	 }

  /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case HRDISKSTORAGEACCESS:
   		 *var_len=sizeof(glaccess[giHRP_index-2]);      //ind-1
		 return (u_char*) &glaccess[giHRP_index-2];
	     break;
   case HRDISKSTORAGEREMOVEBLE:
	    *var_len=sizeof(glrr[giHRP_index-2]);
	     return (u_char*) &glrr[giHRP_index-2];
	     break;
   case HRDISKSTORAGEMEDIA:
	    *var_len=sizeof(glrem[giHRP_index-2]);
		 return (u_char*) &glrem[giHRP_index-2];
		 break;
   case HRDISKSTORAGECAPACITY:
	     *var_len=sizeof(glspace[giHRP_index-2]);
	 	 return (u_char*) &glspace[giHRP_index-2];
         break;
   default:
      ERROR_MSG("");
    }
    return NULL;
}




