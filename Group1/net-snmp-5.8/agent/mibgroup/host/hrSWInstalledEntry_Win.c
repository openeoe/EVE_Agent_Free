/*****************************************************************************
 *
 * [hrSWInstalledEntry_Win.c]
 *
 *      Copyright (c) 2002 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name : Karthikeyan Subramani
 *
 * description :
 *      [ Collecting information about software installed ]
 *
 * TODO:
 *      [ Things to be improved ]
 *
 * CM Details:
 *
 * $Author: howonsuk $
 * $Log: hrSWInstalledEntry_Win.c,v $
 * Revision 1.2  2004/03/03 09:09:03  howonsuk
 * timecache계산에 절대값 사용
 *
 * Revision 1.1  2004/03/03 06:14:19  howonsuk
 * 로그모니터링: 정규식 추가
 * 프로세스모니터링 : 파라미터보여주기 및 파라미터에서 정규식으로 찾기 추가
 *
 * $State: Exp $
 * $Id: hrSWInstalledEntry_Win.c,v 1.2 2004/03/03 09:09:03 howonsuk Exp $
 * $Name:  $
 *
 ****************************************************************************/



/********************************* includes *********************************/


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "hrSWInstalledEntry_Win.h"
#include <Msi.h>
#include <malloc.h>
#include <stdlib.h>


/****************************** local macros ********************************
 *
 * (Macros shareable with rest of the modules are present in .h file)
 */


/********************* local structure/union definitions ********************/
struct software
    {
       char name[255];
       char swdate[255];
    };
struct software *gHead=NULL;





/********************* prototypes for local functions ***********************/
void date(void);
int Get_Next_HR_SW(void);
void Init_HR_SW(void);
int header_hrSWInstall(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method);
void Display(struct software *);

//void Freehead(struct software **b);
 

void addlink(char Dname[1024],char Ddate[1024]);

//int Sort_Linked_ListSW (struct software *pstStart);
void Sort_ListSW(void);

#define BUFFERSIZE 1024



/************************* Globals within this module ***********************/

/* 
 * hrSWInstalledEntry_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid hrSWInstalledEntry_variables_oid[] = { 1,3,6,1,2,1,25,6,3,1 };
static int giinds;
static int gicoun;
static int giex;
static int      HRP_index;
#define BUFSIZE MAX_PATH 
#define HRSW_MONOTONICALLY_INCREASING
oid array[]={ 0,0};
static SYSTEMTIME st;
char dest[BUFSIZE];
char gcout[BUFSIZE];
long gifuncsw=0;

int gSWInstallType = 4;/* 4 - application*/

/************************* externs  ***********************/

/* 
 * variable4 hrSWInstalledEntry_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 hrSWInstalledEntry_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define HRSWINSTALLEDDATE		1
{HRSWINSTALLEDDATE,  ASN_OCTET_STR,  RONLY ,  var_hrSWInstalledEntry, 1,  { 5 }},
#define HRSWINSTALLEDTYPE		2
{HRSWINSTALLEDTYPE,  ASN_INTEGER,  RONLY ,  var_hrSWInstalledEntry, 1,  { 4 }},
#define HRSWINSTALLEDINDEX		3
{HRSWINSTALLEDINDEX,  ASN_INTEGER,  RONLY ,  var_hrSWInstalledEntry, 1,  { 1 }},
#define HRSWINSTALLEDNAME		4
{HRSWINSTALLEDNAME,  ASN_OCTET_STR,  RONLY ,  var_hrSWInstalledEntry, 1,  { 2 }},
#define HRSWINSTALLEDID		5
{HRSWINSTALLEDID, ASN_OBJECT_ID,  RONLY ,  var_hrSWInstalledEntry, 1,  { 3 }},   //ASN_OBJECT_ID

};
/*    (L = length of the oidsuffix) */


      /*********************
	 *
	 *  Internal implementation functions
	 *
	 *********************/


/*****************************************************************************
 *
 * name             :   Init_HR_SW
 * description      :   It will intialize the index
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [giHRP_index]
 * calls            :   [hrSWInstalledEntry ]
 */
void
Init_HR_SW(void)
{
    HRP_index = 1;
    
        
}

/*End of Init_HR_SW*/

/*****************************************************************************
 *
 * name             :   Get_Next_HR_SW
 * description      :   It will increment the index
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [giHRP_index,coun]
 * calls            :   [hrSWInstalledEntry ]
 */
int
Get_Next_HR_SW(void)
{
    /*
     * Silly question time:
     *   How do you detect processors?
     *   Assume we've just got one.
     */
    

    if (HRP_index <=gicoun)
        { 
        DEBUGMSGTL(("Link","gcoun : %d\n, index: %d\n",gicoun,HRP_index));
        return (HRP_index++);
        }
    else
        return -1;
}

/*End of Get_Next_HR_SW*/

/* These are the API calls that supports windows for getting information about software installation*/


/*****************************************************************************
 *
 * name             :   [softinstalled]
 * description      :   [Collects information about software installation]
 * input parameters :   [datatype arg1]  - void
 * output parameters:   [datatype var1]  - void
 * return type      :   [void]
 * global variables :   [gHead]
 * calls            :   [ var_hrSWInstalledEntry ]
 */


void softinstalled(void)
{        
      DWORD data,Ddata;
      HKEY hkey;
      HKEY hSubKey;
      char Dname[BUFFERSIZE];
      DWORD Dlen=BUFFERSIZE;
	  char name[BUFFERSIZE];
	  DWORD bufferlen=BUFFERSIZE;
	  FILETIME ft;
	  char subname[BUFFERSIZE];
	  DWORD num=sizeof(subname);
      char subn[BUFFERSIZE];
      DWORD value,svalue,sclass,csize,namelen,snamelen;
	  FILETIME ff;
	  DWORD security;
      DWORD len=BUFFERSIZE; 		 
      int j;
      char caPATH[BUFFERSIZE];
      char Ddate[BUFFERSIZE];
      struct software *stNewHead=NULL;
      gicoun=0;

      memset(caPATH,'\0',BUFFERSIZE);   
      memset(subn,'\0',BUFFERSIZE); 
      memset(subname,'\0',BUFFERSIZE); 
      memset(name,'\0',BUFFERSIZE);
      memset(Dname,'\0',BUFFERSIZE);
      gifuncsw=GetTickCount();

	  data=RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall",0,
                          KEY_QUERY_VALUE,&hkey);
      svalue=sizeof(value);
      csize=sizeof(sclass);
 	  snamelen=sizeof(namelen);
	 

	  data=RegQueryInfoKey(hkey,(LPTSTR)subn,&len,NULL,&value,&svalue,
                          &sclass,&csize,&namelen,&snamelen,&security,&ff);
      
      RegCloseKey(hkey);  
      data=RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall",0,
                          KEY_ENUMERATE_SUB_KEYS,&hkey);

       for(j=0;j<value;j++)    
           {
                bufferlen=BUFFERSIZE;
                memset(name,'\0',BUFFERSIZE);
                data=RegEnumKeyEx(hkey,j,(LPTSTR) name,&bufferlen,NULL,(LPTSTR) subname,&num,&ft);  
                memset(caPATH,'\0',BUFFERSIZE);   
                strcpy(caPATH,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
                strcat(caPATH,"\\");
                strcat(caPATH,name);
                data=RegOpenKeyEx(HKEY_LOCAL_MACHINE,caPATH,0,
                KEY_QUERY_VALUE,&hSubKey);
                Dlen = BUFFERSIZE;
                memset(Dname,'\0',BUFFERSIZE);
                data=RegQueryValueEx(hSubKey,"UninstallString",NULL,NULL,(LPBYTE)Dname,&Dlen);
                if(data==ERROR_SUCCESS)
                {
                    Dlen = BUFFERSIZE;
                    data=RegQueryValueEx(hSubKey,"DisplayName",NULL,NULL,(LPBYTE)Dname,&Dlen);
                    Dlen = BUFFERSIZE; 
                    Ddata=RegQueryValueEx(hSubKey,"InstallDate",NULL,NULL,(LPBYTE)Ddate,&Dlen);
                    if(Ddata!=ERROR_SUCCESS)
                    strcpy(Ddate,"");
                    if(data==ERROR_SUCCESS)
                    {
                      gicoun++;
                      addlink(Dname,Ddate);

                        
                    }
                }
                RegCloseKey(hSubKey);
           }

      RegCloseKey(hkey);  
 
    Sort_ListSW();

      // Free the created dummy node for sorting 
    
}

/*****************************************************************************
 *
 * name             :  void addlink()
 * description      :  It will allocate memory for the software and date
 * input parameters :  Dname,Ddate
 * output parameters:  [void] -  No output Parameters
 * return type      :  [void]
 * global variables :  [gicoun]
 * calls            :  [softinstalled()]
 */

void addlink(char Dname[1024],char Ddate[1024])
    {
 
      gHead=(struct software *) realloc(gHead,gicoun*sizeof(struct software));
      strcpy(gHead[gicoun-1].name,Dname);
      if(strlen(Ddate)>0)
      strcpy(gHead[gicoun-1].swdate,Ddate);

    }

/*****************************************************************************
 *
 * name             :   Sort_ListSW
 * description      :   software installed names will be sorted in ascending order
 * input parameters :   [void]
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] 
 * global variables :   [gicoun]
 * calls            :   [softinstalled()]
 */

void Sort_ListSW(void)
  {
    int i,j;
    struct software tname;
    for(i=0;i<gicoun;i++)
        {
            for(j=i+1;j<gicoun;j++)
                {
                    if(stricmp(gHead[i].name,gHead[j].name)>0)
                        {
                           tname=gHead[i];
                           gHead[i]=gHead[j];
                           gHead[j]=tname;
                        }
                }
        }
    }
                           



/*End of date */



/** Initializes the hrSWInstalledEntry module */
void
init_hrSWInstalledEntry(void)
{

    DEBUGMSGTL(("hrSWInstalledEntry", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("hrSWInstalledEntry", hrSWInstalledEntry_variables, variable4,
               hrSWInstalledEntry_variables_oid);
	softinstalled( );
    

    /* place any other initialization junk you need here */
}

/*****************************************************************************
 *
 * name             :  Header_hrSWInstall
 * description      :   It will generate the index
 * input parameters :   [struct variable *vp,
 *                       oid * name,
 *                        size_t * length,
 *                        int exact, size_t * var_len, WriteMethod ** write_method]   
 * output parameters:   [void] -  No output Parameters
 * return type      :   [int] - index  
 * global variables :   [giHRP_index]
 * calls            :   [var_hrSWInstalledEntry]
 */

int
header_hrSWInstall(struct variable *vp,
              oid * name,
              size_t * length,
              int exact, size_t * var_len, WriteMethod ** write_method)
{
#define HRSW_ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int             hrsw_idx, LowIndex = -1;
    int             result;

    DEBUGMSGTL(("host/hr_sw", "var_hrdisk: "));
    DEBUGMSGOID(("host/hr_sw", name, *length));
    DEBUGMSG(("host/hr_sw", " %d\n", exact));

    memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));
    /*
     * Find "next" disk entry 
     */
     if(exact==1)
		 giex=1;
	
    Init_HR_SW();
    for (;;) {
        hrsw_idx = Get_Next_HR_SW();
        if (hrsw_idx == -1)
            break;
        newname[HRSW_ENTRY_NAME_LENGTH] = hrsw_idx;
        result = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (result == 0)) {
            LowIndex = hrsw_idx;
			
            /*
             * Save diskessor status information 
             */
            break;
        }
        if ((!exact && (result < 0)) &&
            (LowIndex == -1 || hrsw_idx < LowIndex)) {
            LowIndex = hrsw_idx;
			
            /*
             * Save diskessor status information 
             */
#ifdef HRSW_MONOTONICALLY_INCREASING
			break;
#endif
        }
    }

    if (LowIndex == -1) {
        DEBUGMSGTL(("host/hr_disk", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,
           (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    DEBUGMSGTL(("host/hr_disk", "... get disk stats "));
    DEBUGMSGOID(("host/hr_disk", name, *length));
    DEBUGMSG(("host/hr_disk", "\n"));

	giinds=LowIndex;

    return LowIndex;
}


/*End of header_hrSWInstall*/



/*
 * var_hrSWInstalledEntry():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_hrSWInstalledEntry(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
	int hrswidx;
    long var_countsw;
    int nSWNameLen=0;
  
    var_countsw=GetTickCount();
    
    if(abs(var_countsw-gifuncsw)>500)
		 {
			
            gicoun=0;
            if (gHead != NULL)
            free(gHead);
            gHead = NULL;
            softinstalled( );
 			giex=0;
            
		 }
    
    hrswidx=header_hrSWInstall(vp,name,length,exact,var_len,write_method);
    if(hrswidx== MATCH_FAILED )                     
    return NULL;
        
     

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case HRSWINSTALLEDDATE:
         memset(gcout,'\0',BUFSIZE);
         strncpy(gcout,gHead[giinds-1].swdate,4);
         st.wYear=atoi(gcout);
         memset(gcout,'\0',BUFSIZE);
         strncpy(gcout,gHead[giinds-1].swdate+4,2);
         st.wMonth=atoi(gcout);    
         memset(gcout,'\0',BUFSIZE);
         strncpy(gcout,gHead[giinds-1].swdate+6,2);
         st.wDay=atoi(gcout);
         st.wHour=0;
         st.wMinute=0;
         st.wSecond=0;
         dest[1]=(char)(st.wYear&0xff);
         dest[0]=(char)((st.wYear>>8)&0xff);
         dest[2]=(char)st.wMonth;
         dest[3]=(char)st.wDay;
         dest[4]=(char)st.wHour;
         dest[5]=(char)st.wMinute;
         dest[6]=(char)st.wSecond;
		 *var_len=strlen(dest); 
         return (u_char*) (dest);
		 break;
    case HRSWINSTALLEDTYPE:
        *var_len=sizeof(gSWInstallType);; 
         return (u_char*) &gSWInstallType;
		 break;
	case HRSWINSTALLEDINDEX:
         *var_len=sizeof(giinds); 
         return (u_char*) &giinds;
		 break;
    case HRSWINSTALLEDNAME:
         *var_len=strlen(gHead[giinds-1].name); 
         return (u_char*) (gHead[giinds-1].name);
//        return NULL;
		 break;
    case HRSWINSTALLEDID:
	 	 *var_len=sizeof(array); 
         return (u_char*) array;
		 break;
        default:
        ERROR_MSG("");
    }
    return NULL;
}




	   
