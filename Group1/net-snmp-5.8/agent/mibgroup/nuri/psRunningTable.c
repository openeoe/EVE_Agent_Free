/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "psRunningTable.h"
#include <fcntl.h>
#include <pwd.h>
#include <sys/stat.h>
#include <sys/user.h>   /* PAGE_SIZE */
#include <dirent.h>

#define CACHE_TIMEOUT 5
#define MICROSEC 1000000
#define KBYTE 1024
#define PWD "PWD="

/* 
 * psRunningTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid psRunningTable_variables_oid[] = { 1,3,6,1,4,1,3204,1,3,33 };

/* 
 * variable4 psRunningTable_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 psRunningTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define PSRUNNINGPID		1
{PSRUNNINGPID,  ASN_UNSIGNED,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 1 }},
#define PSRUNNINGPGID		2
{PSRUNNINGPGID,  ASN_UNSIGNED,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 2 }},
#define PSRUNNINGPPID		3
{PSRUNNINGPPID,  ASN_UNSIGNED,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 3 }},
#define PSRUNNINGNAME		4
{PSRUNNINGNAME,  ASN_OCTET_STR,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 4 }},
#define PSRUNNINGSTATE		5
{PSRUNNINGSTATE,  ASN_INTEGER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 5 }},
#define PSAGE		6
{PSAGE,  ASN_TIMETICKS,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 6 }},
#define PSRUNNINGPRIORITY		7
{PSRUNNINGPRIORITY,  ASN_INTEGER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 7 }},
#define PSRUNNINGSIZE		8
{PSRUNNINGSIZE,  ASN_INTEGER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 8 }},
#define PSRUNNINGRSS		9
{PSRUNNINGRSS,  ASN_INTEGER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 9 }},
#define PSRUNNINGPAGEFAULTS		10
{PSRUNNINGPAGEFAULTS,  ASN_COUNTER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 10 }},
#define PSRUNNINGHARDPAGEFAULTS		11
{PSRUNNINGHARDPAGEFAULTS,  ASN_COUNTER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 11 }},
#define PSRUNNINGCONTEXTSWITCHES		12
{PSRUNNINGCONTEXTSWITCHES,  ASN_COUNTER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 12 }},
#define PSRUNNINGTHREADS		13
{PSRUNNINGTHREADS,  ASN_GAUGE,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 13 }},
#define PSRUNNINGHANDLES		14
{PSRUNNINGHANDLES,  ASN_GAUGE,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 14 }},
#define PSRUNNINGPERCENTCPU		15
{PSRUNNINGPERCENTCPU,  ASN_INTEGER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 15 }},
#define PSRUNNINGKERNELTIME		16
{PSRUNNINGKERNELTIME,  ASN_TIMETICKS,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 16 }},
#define PSRUNNINGUSERTIME		17
{PSRUNNINGUSERTIME,  ASN_TIMETICKS,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 17 }},
#define PSRUNNINGSTARTTIME		18
{PSRUNNINGSTARTTIME,  ASN_OCTET_STR,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 18 }},
#define PSRUNNINGUID		19
{PSRUNNINGUID,  ASN_UNSIGNED,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 19 }},
#define PSRUNNINGUSERNAME		20
{PSRUNNINGUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 20 }},
#define PSRUNNINGDEVICE		21
{PSRUNNINGDEVICE,  ASN_OCTET_STR,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 21 }},
#define PSRUNNINGCOMMANDLINE		22
{PSRUNNINGCOMMANDLINE,  ASN_OCTET_STR,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 22 }},
#define PSRUNNINGFILEPATH		23
{PSRUNNINGFILEPATH,  ASN_OCTET_STR,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 23 }},
#define PSRUNNINGCWD		24
{PSRUNNINGCWD,  ASN_OCTET_STR,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 24 }},
#define PSRUNNINGPERCENTRSS		25
{PSRUNNINGPERCENTRSS,  ASN_INTEGER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 25 }},
#define PSRUNNINGPERCENTSIZE		26
{PSRUNNINGPERCENTSIZE,  ASN_INTEGER,  RWRITE,  var_psRunningTable, 3,  { 1, 1, 26 }},
};
/*    (L = length of the oidsuffix) */

typedef struct{
	
	int  iPsPid;			                       /* 1 */
	char szPsName[128];                            /* 2 */
	char cPsState;                                 /* 3 */

	int  iPsUid;	
	int  iPsPPid;           						/* 4 */
	int  iPsGid;            						/* 5 */
	int  iPsSid;            						/* 6 */
	int  iPsSession;        						/* 7 */
	int  iPsTTY;								    /* 8 */
	int  iPsTpGID;								    /* 9 */
	
	unsigned long ulPsFlags;	       				/* 10 */
	unsigned long ulPsMin_Flt;						/* 11 */
	unsigned long ulPsCMin_Flt;						/* 12 */
	unsigned long ulPsMaj_Flt;						/* 13 */
	unsigned long ulPsCMaj_Flt;						/* 14 */
	
	long lPsUTime;								    /* 15 */
	long lPsSTime;								    /* 16 */
	
	long lPsCUTime;								    /* 17 */
	long lPsCSTime;								    /* 18 */
	long lPsPriority;							    /* 19 */
	long lPsNice;								    /* 20 */
	long lPsTimeout;							    /* 21 */
	long lPsIt_Real_Value;					        /* 22 */

	unsigned long ulPsStartTime;			    	/* 23 */
	unsigned long ulPsVmSize;						/* 24 */
	unsigned long ulPsVmRSS;						/* 25 */
	unsigned long ulPsVmRSS_rlimit;					/* 26 */

	unsigned long ulPsStart_Code;					/* 27 */
	unsigned long ulPsEnd_Code;						/* 28 */
	unsigned long ulPsStart_Stack;			   		/* 29 */
	unsigned long ulPsStack_sp;						/* 30 */
	unsigned long ulPsStack_ip;						/* 31 */

	unsigned long ulPsSignal;						/* 32 */
	unsigned long ulPsBlocked;						/* 33 */
	unsigned long ulPsSigIgnore;		    		/* 34 */
	unsigned long ulPsSigCatch;						/* 35 */
	unsigned long ulPsKernelFn;						/* 36 */
	unsigned long ulPSNumSwap;						/* 37 */
	unsigned long ulPSCNumSwap;						/* 38 */

	
}gstPsStat;

/* Prototype for local function */
static void psRunningTable_Init();
static int  psRunningTable_GetNextProc();
static void psRunningTable_End();
static int psRunningTable_GetProcStat(int, gstPsStat *);
static int psRunningTable_GetHandles(int);

/* Global Declaration */
static int gILowProcIndex;
static unsigned char gString[SPRINT_MAX_LEN];
static struct timeval gstDCTimeVal={0};
DIR *fdDir = NULL;
struct dirent *pstFdDir=NULL;

/* Extern Declaration */
extern int nproc;
extern struct procsinfo *proc_table;
extern int current_proc_entry;

/* static declaration */
static FILE *fpProc = NULL;

/** Initializes the psRunningTable module */
void
init_psRunningTable(void)
{

    DEBUGMSGTL(("psRunningTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("psRunningTable", psRunningTable_variables, variable4,
               psRunningTable_variables_oid);

    /* place any other initialization junk you need here */
}

int
header_psRunningTable(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
   /* variables we may use later */
   #define NAME_LENGTH 13
   static long long_ret;
   static u_long ulong_ret;
   static unsigned char string[SPRINT_MAX_LEN];
   static oid newname[MAX_OID_LEN];
   static struct counter64 c64;

   static int IPid;
   static int IResult;
   int ILowPid=-1;

   memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));

    /*
     *  Find the "next" running process
     */
    
   psRunningTable_Init();
    for (;;) {
    IPid = psRunningTable_GetNextProc();
    if (IPid == -1)
        break;
    newname[NAME_LENGTH] = IPid;
    DEBUGMSGOID(("nuri/Process", newname, *length));
    DEBUGMSG(("nuri/Process", "\n"));
    IResult = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
    if (exact && (IResult == 0)) 
    {
            ILowPid = IPid;
            DEBUGMSGTL(("nuri/Process", " saved\n"));
            /*
             * Save process status information
             */
            break;
    }
    if ((!exact && (IResult < 0)) && (ILowPid == -1 || IPid < ILowPid)) {
    	ILowPid = IPid;
            /*
             * Save process status information
             */
            DEBUGMSG(("nuri/Process", " saved"));
        }
        DEBUGMSG(("nuri/Process", "\n"));
  }
    psRunningTable_End();

    if (ILowPid == -1) {
        DEBUGMSGTL(("nuri/Process", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    newname[NAME_LENGTH] = ILowPid;
    memcpy((char *) name, (char *) newname, (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    DEBUGMSGTL(("nuri/Process", "... get process stats "));
    DEBUGMSGOID(("nuri/Process", name, *length));
    DEBUGMSG(("nuri/Process", "\n"));
    return ILowPid;

}

/*
 * var_psRunningTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_psRunningTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static unsigned char string[SPRINT_MAX_LEN];
    static struct passwd *psPasswd = NULL;

    static gstPsStat stPsStat;
    static char szBuff [128];
    static unsigned long   ulUptime = 0, ulTemp1, ulTemp2;
    static unsigned long long ullTotalUtlTime = 0;
    static unsigned long long ullTotalTime = 0;
    static unsigned long ulMemTotal = 0;
    static unsigned uPCpu = 0;
    static unsigned uPMem = 0;
    static int      fd;
    static int      iResult;
    static char    *buff = NULL;
    static int      iBuffSize = 0;
    static char     *pcPos;
    time_t tTempTime = 0;
    time_t tCurTime = 0;
    int iPid;
    struct timeval stDCTimeStamp = {0};

 
  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */

    iPid = header_psRunningTable(vp,name,length,exact,var_len,write_method);
    if (iPid == MATCH_FAILED )
	    return NULL;
    psRunningTable_GetProcStat(iPid, &stPsStat);
/*
    gettimeofday(&stDCTimeStamp, NULL);

    stDCTimeStamp.tv_sec = stDCTimeStamp.tv_sec - gstDCTimeVal.tv_sec;
    stDCTimeStamp.tv_usec = stDCTimeStamp.tv_usec - gstDCTimeVal.tv_usec;
    ulong_ret = stDCTimeStamp.tv_sec + (stDCTimeStamp.tv_usec / MICROSEC); 
    if(ulong_ret > CACHE_TIMEOUT){
         psRunningTable_GetProcStat(iPid, &stPsStat);
    }
*/
    *var_len = sizeof(unsigned long);	

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PSRUNNINGPID:
        ulong_ret = iPid;
        DEBUGMSGTL(("psRunningTable", "PSRUNNINGPID: %d\n",iPid));
        return (u_char*) &ulong_ret;
    case PSRUNNINGPGID:
        ulong_ret =  stPsStat.iPsGid;
	DEBUGMSGTL(("psRunningTable", "PSRUNNINGPID: %d\n",iPid));
	return (u_char*) &ulong_ret;
    case PSRUNNINGPPID:
        ulong_ret = stPsStat.iPsPPid;
   	DEBUGMSGTL(("psRunningTable", "PSRUNNINGPID: %d\n",iPid));
        return (u_char*) &ulong_ret;
    case PSRUNNINGNAME:
    	sprintf(gString, "%s", stPsStat.szPsName);	
       	*var_len = strlen(gString);
        DEBUGMSGTL(("psRunningTable", "PSRUNNINGNAME: %s\n", gString));
       	return (u_char*) gString;
    case PSRUNNINGSTATE:
     	DEBUGMSGTL(("psRunningTable", "PSRUNNINGSTATE: %c\n", stPsStat.cPsState));
       	switch(stPsStat.cPsState){
#if 0
	    case 'T':
	        ulong_ret = 0;  /* T is traced or stopped on a signal */
		break;
#endif
	    case 'S':
	    	ulong_ret = 3;  /* sleeping in an interruptible wait */
		break;
	    case 'R':
		ulong_ret = 4;  /* Running */
		break;
	    case 'Z':  
		ulong_ret = 5;  /* Zombie  */
		break;
	    default:
		ulong_ret = 6;  /* D is sleeping in an uninterruptible wait or swapping */
       	}
       	return (u_char*) &ulong_ret;
    case PSAGE:
	ullTotalTime = ulUptime = 0;
	fpProc = fopen("/proc/uptime", "r");
    	if (fpProc){
            if (2 == fscanf(fpProc, "%lu.%lu", &ulTemp1, &ulTemp2))
            	ulUptime = ulTemp1;
            if(fpProc)
	        fclose(fpProc);
    	}
	else{
	    snmp_log(LOG_ERR, "/proc/uptime open error\n");
	}
        ullTotalTime = (ulUptime - (stPsStat.ulPsStartTime / 100)) * 100;/* in jiffies */
	*var_len = sizeof(unsigned long);
	return (u_char*) &ullTotalTime;
    case PSRUNNINGPRIORITY:
        ulong_ret = stPsStat.lPsPriority;
   	DEBUGMSGTL(("psRunningTable", "PSRUNNINGPRIORITY: %ld\n", ulong_ret));
        return (u_char*) &ulong_ret;
    case PSRUNNINGSIZE:
        ulong_ret = stPsStat.ulPsVmSize;
   	DEBUGMSGTL(("psRunningTable", "PSRUNNINGSIZE: %ld\n", ulong_ret));
        return (u_char*) &ulong_ret;
    case PSRUNNINGRSS:
        ulong_ret = stPsStat.ulPsVmRSS;
   	DEBUGMSGTL(("psRunningTable",  "PSRUNNINGRSS: %ld\n", ulong_ret));
        return (u_char*) &ulong_ret;
    case PSRUNNINGPAGEFAULTS:
        ulong_ret = stPsStat.ulPsMin_Flt + stPsStat.ulPsMaj_Flt;
        DEBUGMSGTL(("psRunningTable", "PSRUNNINGPAGEFAULTS: %ld\n", ulong_ret));
        return (u_char*) &ulong_ret;
    case PSRUNNINGHARDPAGEFAULTS:
        ulong_ret = stPsStat.ulPsMaj_Flt;
   	DEBUGMSGTL(("psRunningTable", "PSRUNNINGPAGEFAULTS: %ld\n", ulong_ret));
        return (u_char*) &ulong_ret;
    case PSRUNNINGHANDLES:
        ulong_ret = psRunningTable_GetHandles(iPid);
   	DEBUGMSGTL(("psRunningTable", "PSRUNNINGHANDLES: %ld\n", ulong_ret));
	return (u_char*) &ulong_ret;
   case PSRUNNINGPERCENTCPU:
    	ullTotalUtlTime = (stPsStat.lPsSTime + stPsStat.lPsUTime)/100;/* in seconds *//*      ullTotalUtlTime = (stPsStat.lPsSTime + stPsStat.lPsUTime); // in jiffies */
	fpProc = fopen("/proc/uptime", "r");
    	if (fpProc) {
        	if (2 == fscanf(fpProc, "%lu.%lu", &ulTemp1, &ulTemp2))
            		ulUptime = ulTemp1;
        	if(fpProc)
	            fclose(fpProc);
    	}
        ullTotalTime = ulUptime - (stPsStat.ulPsStartTime / 100);
	if(ullTotalTime == 0)
	    uPCpu = 0;
	else
	    uPCpu = (ullTotalUtlTime * 100) / ullTotalTime;
	if(uPCpu > 99)
	    uPCpu = 99;	
	DEBUGMSGTL(("psRunningTable", "PSRUNNINGPERCENTCPU: %ld\n", uPCpu));
        return (u_char*) &uPCpu;
    case PSRUNNINGKERNELTIME:
        ulong_ret = stPsStat.lPsSTime;  /* in jiffies */
        return (u_char*) &ulong_ret; 
    case PSRUNNINGUSERTIME:
      	ulong_ret = stPsStat.lPsUTime; /* in jiffies */
   	DEBUGMSGTL(("psRunningTable", "PSRUNNINGUSERTIME: %ld\n", ulong_ret));
        return (u_char*) &ulong_ret;
    case PSRUNNINGSTARTTIME:
        fpProc = fopen("/proc/uptime", "r");
    	if (fpProc){
            if (1 == fscanf(fpProc, "%lu", &ulTemp1))
            	ulUptime = ulTemp1;
            if(fpProc)
	        fclose(fpProc);
    	}
	else{
	    snmp_log(LOG_ERR, "/proc/uptime open error\n");
	}
        time(&tCurTime);
	*var_len = 0;
	tTempTime = tCurTime  - ulUptime  + stPsStat.ulPsStartTime/100 ;
        strcpy(gString, date_n_time(&tTempTime, var_len)); /* in jiffies */
	DEBUGMSGTL(("psRunningTable", "PSRUNNINGSTARTTIME: %s\n", gString));
	*var_len = strlen(gString);
        return (u_char*) gString;    
    case PSRUNNINGUID:
        ulong_ret = stPsStat.iPsUid;
        return (u_char*) &ulong_ret; 
    case PSRUNNINGUSERNAME:
	psPasswd = getpwuid(stPsStat.iPsUid);
	if(psPasswd != NULL)
		sprintf(gString,"%s", psPasswd->pw_name); 
	else
		strcpy(gString, "");
 	*var_len = strlen(gString);
	return (u_char*) gString;
    case PSRUNNINGDEVICE:
	if(stPsStat.iPsTTY == 0)
            strcpy(gString, "?");
	else{
            strcpy(gString,"/proc/devices");
	    fpProc = fopen(gString, "r");
    	    if(fpProc){
                while(fgets(szBuff, 80, fpProc) != NULL){
		    sprintf(string, "%d", major(stPsStat.iPsTTY));
	            pcPos = strstr(szBuff, string);
    	            if(pcPos){
	               sscanf(szBuff, "%lu %s", &ulTemp1, string);
	               break;
		    }
	        }
		sprintf(gString, "/dev/%s/%d", string, minor(stPsStat.iPsTTY));/* ttyS not fixed */
	        fclose(fpProc);
	    }
	    else{
		DEBUGMSGTL(("psRunningTable", "%s open error\n", gString));
	        sprintf(gString, "/dev/pts/%d", minor(stPsStat.iPsTTY)); /* wont be pts always...fix it */
            }
	}
   	DEBUGMSGTL(("psRunningTable", "PSRUNNINGPAGEFAULTS: %s\n", gString));
	*var_len = strlen(gString);
        return (u_char*) gString;   
    case PSRUNNINGCOMMANDLINE:
	sprintf(gString,"/proc/%d/cmdline", iPid);
	if ((fpProc = fopen(gString, "r")) == NULL)
	    return NULL;
	memset(szBuff, 0, sizeof(szBuff));
	/*
	 * argv[0] '\0' argv[1] '\0' ....
	 */
	if (!fgets(szBuff, sizeof(szBuff) - 2, fpProc)) {
	    /*
	     * maybe be empty (even argv[0] is missing)
	     */
	    gString[0] = '\0';
	    *var_len = 0;
	    fclose(fpProc);
	    return gString;
	}

	/*
	 * Skip over argv[0]
	 */
	pcPos = szBuff;
	while (*pcPos)
	    ++pcPos;
	++pcPos;
	/*
	 * Now join together separate arguments.
	 */
	while (1) {
	    while (*pcPos)
		++pcPos;
	    if (*(pcPos + 1) == '\0')
		break;		/* '\0''\0' => End of command line */
	    *pcPos = ' ';
	}

	pcPos = szBuff;
	while (*pcPos)
	    ++pcPos;
	++pcPos;
	strcpy(gString, pcPos);
	fclose(fpProc);
	*var_len = strlen(gString);
	return (u_char*) gString;
    case PSRUNNINGFILEPATH:
	sprintf(gString,"/proc/%d/exe", iPid);
	iResult = readlink(gString, szBuff, sizeof(szBuff));
	if(iResult == -1){
		strcpy(gString, "");
	}
	else{
		szBuff[iResult] = '\0';
		strcpy(gString, szBuff);
	}
	*var_len = strlen(gString);
	return (u_char*) gString;
    case PSRUNNINGCWD:
       sprintf(gString, "/proc/%d/environ", iPid);
       fpProc = fopen(gString, "r");
       strcpy(gString, "");
       if(fpProc != NULL){
           while(fgets(szBuff, 128, fpProc) != NULL){
	       pcPos = strstr(szBuff, "PWD");
    	       if (pcPos){
	           pcPos += strlen(PWD);
	           strcpy(gString, pcPos);
	           break;
		}
	    }
	    if(fpProc)
	        fclose(fpProc);
	}else{
	    snmp_log(LOG_ERR, "/proc/%d/environ error\n", iPid);
	}
	*var_len = strlen(gString); 
        return (u_char*) &gString;
    case PSRUNNINGPERCENTRSS:
        if(stPsStat.ulPsVmRSS_rlimit)
            ulong_ret = ( stPsStat.ulPsVmRSS * 100 ) / stPsStat.ulPsVmRSS_rlimit;
        else
            ulong_ret = 0;
	return (u_char*) &ulong_ret;
    case PSRUNNINGPERCENTSIZE:
        fpProc = fopen("/proc/meminfo", "r");
    	if (fpProc){
            while(fgets(szBuff, 128, fpProc) != NULL){
        	if(!strncmp(szBuff, "MemTotal:", 9)){
                    sscanf(szBuff + 10, "%lu", &ulMemTotal);
		}
	    }
	    if(fpProc)
	        fclose(fpProc);
	    if(ulMemTotal == 0)
		uPMem = 0;
	    else
		uPMem = (stPsStat.ulPsVmRSS * 100) / ulMemTotal;
	}
	else{
	   snmp_log(LOG_ERR, "/proc/meminfo open error\n");
	}
        
	return (u_char*) &uPMem;
    default:
     // error_msg("");
     return NULL;
    }
    return NULL;
}


/*****************************************************************************
 * name             :   psRunningTable_Init
 * description      :   
 * input parameters :   None
 * output parameters:   None
 * return type      :   void
 * global variables :   None
 * calls            :   None
 *****************************************************************************/
static void psRunningTable_Init(){
    if (fdDir != NULL)
        closedir(fdDir);
    fdDir = opendir("/proc");
}

/*****************************************************************************
 * name             :   psRunningTable_GetNextProc
 * description      :   
 * input parameters :   None
 * output parameters:   None
 * return type      :   int
 * global variables :   None
 * calls            :   None
 *****************************************************************************/
static int psRunningTable_GetNextProc(){
    int       pid;
    pstFdDir = readdir(fdDir);

    if (pstFdDir == NULL)
        return -1;

    pid = atoi(pstFdDir->d_name);
    if (pid == 0)
        return (psRunningTable_GetNextProc());
    return pid;
}

/*****************************************************************************
 * name             :   psRunningTable_End
 * description      :   
 * input parameters :   None
 * output parameters:   None
 * return type      :   void
 * global variables :   None
 * calls            :   None
 *****************************************************************************/
static void psRunningTable_End(){
    if (fdDir)
        closedir(fdDir);
    fdDir = NULL;
}

/*****************************************************************************
 * name             :   psRunningTable_GetProcStat
 * description      :   
 * input parameters :   pid
 * output parameters:   pstPsStat
 * return type      :   int
 * global variables :   None
 * calls            :   void
 *****************************************************************************/
static int 
psRunningTable_GetProcStat(int pid, gstPsStat *pstPsStat) {
    char buf[800]; /* about 40 fields, 64-bit decimal is about 20 chars */
    int num;	
    int fd;
    char* tmp;
    struct stat sb; /* stat() used to get EUID */
    
    gettimeofday(&gstDCTimeVal, NULL);
    snprintf(buf, 32, "/proc/%d/stat", pid);
    if ( (fd = open(buf, O_RDONLY, 0) ) == -1 ) return 0;
    num = read(fd, buf, sizeof buf - 1);
    fstat(fd, &sb);
    pstPsStat->iPsUid = sb.st_uid;
    close(fd);
    if(num<80) return 0;
    buf[num] = '\0';
    tmp = strrchr(buf, ')');      /* split into "PID (cmd" and "<rest>" */
    *tmp = '\0';                  /* replace trailing ')' with NUL */
    /* parse these two gStrings separately, skipping the leading "(". */
    memset(pstPsStat->szPsName, 0, sizeof(pstPsStat->szPsName));          /* clear */

    sscanf(buf, "%d (%15c", &pstPsStat->iPsPid, pstPsStat->szPsName);  /* comm[16] in kernel */
	num = sscanf(tmp + 2,                    /* skip space after ')' too */
       "%c "
       "%d %d %d %d %d "
       "%lu %lu %lu %lu %lu %ld %ld "
       "%ld %ld %ld %ld %ld %ld "
       "%lu %lu "
       "%lu %lu ",
           &pstPsStat->cPsState,
           &pstPsStat->iPsPPid, 
	   &pstPsStat->iPsGid, 
	   &pstPsStat->iPsSession, 
	   &pstPsStat->iPsTTY, 
	   &pstPsStat->iPsTpGID,
           &pstPsStat->ulPsFlags, 
	   &pstPsStat->ulPsMin_Flt, 
	   &pstPsStat->ulPsCMin_Flt, 
	   &pstPsStat->ulPsMaj_Flt, 
	   &pstPsStat->ulPsCMaj_Flt, 
	   &pstPsStat->lPsUTime, 
	   &pstPsStat->lPsSTime,
           &pstPsStat->lPsCUTime, 
	   &pstPsStat->lPsCSTime, 
	   &pstPsStat->lPsPriority, 
	   &pstPsStat->lPsNice, 
	   &pstPsStat->lPsTimeout, 
	   &pstPsStat->lPsIt_Real_Value,
           &pstPsStat->ulPsStartTime, 
	   &pstPsStat->ulPsVmSize,
           &pstPsStat->ulPsVmRSS, 
	   &pstPsStat->ulPsVmRSS_rlimit);
    pstPsStat->ulPsVmSize /= KBYTE;
    pstPsStat->ulPsVmRSS *= (PAGE_SIZE/KBYTE);
}

/*****************************************************************************
 * name             :   psRunningTable_GetHandles
 * description      :   
 * input parameters :   pid
 * output parameters:   None
 * return type      :   int
 * global variables :   None
 * calls            :   void
 *****************************************************************************/
static int 
psRunningTable_GetHandles(int iPid){
	
	int iHandles= 0;
	static char szBuff[100];
	static DIR *fdDir = NULL;
	static struct dirent *pstFdDir=NULL;
	strcpy(gString, "");
	sprintf(gString, "/proc/%d/fd", iPid);
	fdDir = opendir(gString);
	if(fdDir == NULL)
	    return iHandles;
	while((pstFdDir = readdir(fdDir)) != NULL){
	  if(!(strcmp(pstFdDir->d_name,".") && strcmp(pstFdDir->d_name,"..")))
                continue;
	   iHandles++;
	}
	closedir(fdDir);
	return iHandles;
}

/*****************************************************************************
 * name             :   Date_n_time
 * description      :   
 * input parameters :   
 * output parameters:   None
 * return type      :   
 * global variables :   None
 * calls            :   void
 *****************************************************************************/
u_char *
Date_n_time(time_t * when, size_t * length){
    struct tm      *tm_p;
    static u_char   string[11];

    /*
     * Null time
     */
    if (when == NULL || *when == 0 || *when == (time_t) - 1) {
        string[0] = 0;
        string[1] = 0;
        string[2] = 1;
        string[3] = 1;
        string[4] = 0;
        string[5] = 0;
        string[6] = 0;
        string[7] = 0;
        *length = 8;
        return string;
    }


    /*
     * Basic 'local' time handling
     */
    tm_p = localtime(when);
    *(short *) string = htons(tm_p->tm_year);
    string[2] = tm_p->tm_mon + 1;
    string[3] = tm_p->tm_mday;
    string[4] = tm_p->tm_hour;
    string[5] = tm_p->tm_min;
    string[6] = tm_p->tm_sec;
    string[7] = 0;
    *length = 8;

#ifndef cygwin
    /*
     * Timezone offset
     */
#if !defined(SYSV) && !defined(aix4) && !defined(aix5) && !defined(WIN32) && !defined(irix6)
#define timezone tm_p->tm_gmtoff
#endif
    if (timezone > 0)
        string[8] = '-';
    else
        string[8] = '+';
    string[9] = abs(timezone) / 3600;
    string[10] = (abs(timezone) - string[9] * 3600) / 60;
    *length = 11;
#endif


    return string;
}