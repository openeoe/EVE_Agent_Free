/*****************************************************************************
 *
 * [userGroupTable.c]
 *
 *      Copyright (c) 2002 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name Karthikeyan Subramani
 *
 * description :
 *      [ TO get the Group details]
 *
 * TODO:
 *      [ Things to be improved ]
 *
 * CM Details:
 *
 * $Author: karthis $
 * $Log: userGroupTable.c,v $
 * Revision 1.3  2004/01/21 07:24:48  karthis
 * fixed crash copied the UAC UGC from hp src
 *
 * Revision 1.3  2004/01/19 07:17:53  vijaysp
 * endgrent() added to solve agent crash
 *
 * Revision 1.2  2004/01/05 14:57:46  karthis
 * update coding standard
 *
 * Revision 1.3  2004/01/05 14:44:18  karthis
 * update coding standard
 *
 * $State: Exp $  
 * $Id: userGroupTable.c,v 1.3 2004/01/21 07:24:48 karthis Exp $
 * $Name: NASCenterAgent_29Jan2004_Patch3_SrcRls $
 ****************************************************************************/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */
/********************************* includes *********************************/
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "userGroupTable.h"
#include <grp.h>
#include <sys/time.h>
/* 
 * userGroupTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/****************************** local macros ********************************
 *
 * (Macros shareable with rest of the modules are present in .h file)
 */

#define GROUPINDEX_MONOTONICALLY_INCREASING
#define CACHE_TIME 5

/********************* local structure/union definitions ********************/
struct group *gp;
struct timeval gsttDCTimeVal={0};

struct Group 
{
 int gid;
 char gname[100]; 
}groupinfo;

/********************* prototypes for local functions ***********************/
int userGroupTable_GetNext(void);
void userGroupTable_Init();
int
header_userGroupTable(struct variable *vp,
                oid     *name,
                size_t  *length,
                int     exact,
                size_t  *var_len,
                WriteMethod **write_method);


/************************* Globals within this module ***********************/
int guindex=0;
int gmaxgroup=0;

oid userGroupTable_variables_oid[] = { 1,3,6,1,4,1,3204,1,3,34,4};

/************************* externs  ***********************/

/* 
 * variable4 userGroupTable_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 userGroupTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

};
/*    (L = length of the oidsuffix) */


/** Initializes the userGroupTable module */
void
init_userGroupTable(void)
{

    DEBUGMSGTL(("userGroupTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("userGroupTable", userGroupTable_variables, variable4,
               userGroupTable_variables_oid);

    /* place any other initialization junk you need here */
}

/*****************************************************************************
 * name             :   userGroupGetData
 * description      :   This function gives the number of Group 
 * input parameters :   None
 * output parameters:  
 * return type      :
 * global variables :   gmaxgroup
 * calls            :   None
 *****************************************************************************/

void userGroupData(void)
{ 
  gmaxgroup=0;
  /* Get current time - For Data caching */
DEBUGMSGTL(("userGroupTable","Get Group Called\n"));
 
 gettimeofday(&gsttDCTimeVal, NULL);
  setgrent();
  while(1)
  {
    gp=getgrent();
    if(gp==NULL)
    break;
    gmaxgroup++;
  }
  endgrent();
}

int
write_userGroupID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to userGroupTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to userGroupTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
