/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "SharedMemory.h"
#include <linux/shm.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>


#define SHM_MONOTONICALLY_INCREASING
#define SHM_FILE "/proc/sysvipc/shm"
#define KBYTE 1024
#define CACHE_TIMEOUT 5
#define MICROSEC 1000000


/*
 * SharedMemory_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid SharedMemory_variables_oid[] = { 1,3,6,1,4,1,3204,1,3,27 };

/*
 * variable4 SharedMemory_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable4 SharedMemory_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define SHAREDMEMAVGUSEDKB		1
{SHAREDMEMAVGUSEDKB,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 8 }},
#define SHAREDMEMAVGIDSUSED		2
{SHAREDMEMAVGIDSUSED,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 12 }},
#define SHAREDMEMMINUSEDKB		3
{SHAREDMEMMINUSEDKB,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 6 }},
#define SHAREDMEMMAXSEGPERPROC		4
{SHAREDMEMMAXSEGPERPROC,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 4 }},
#define SHAREDMEMNUMOFIDSUSED		5
{SHAREDMEMNUMOFIDSUSED,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 5 }},
#define SHAREDMEMMAXIDSUSED		6
{SHAREDMEMMAXIDSUSED,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 11 }},
#define SHAREDMEMMINSIZE		7
{SHAREDMEMMINSIZE,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 2 }},
#define SHAREDMEMMAXSIZE		8
{SHAREDMEMMAXSIZE,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 1 }},
#define SHAREDMEMTOTALUSEDKB		9
{SHAREDMEMTOTALUSEDKB,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 9 }},
#define SHAREDMEMMAXUSEDKB		10
{SHAREDMEMMAXUSEDKB,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 7 }},
#define SHAREDMEMTOTALNUMIDS		11
{SHAREDMEMTOTALNUMIDS,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 3 }},
#define SHAREDMEMMINIDSUSED		12
{SHAREDMEMMINIDSUSED,  ASN_INTEGER,  RONLY ,  var_SharedMemory, 1,  { 10 }},

#define SHAREDMEMINDEX		13
{SHAREDMEMINDEX,  ASN_UNSIGNED,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 1 }},
#define SHAREDMEMID		14
{SHAREDMEMID,  ASN_OCTET_STR,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 2 }},
#define SHAREDMEMKEY		15
{SHAREDMEMKEY,  ASN_INTEGER,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 3 }},
#define SHAREDMEMMODE		16
{SHAREDMEMMODE,  ASN_INTEGER,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 4 }},
#define SHAREDMEMOWNER		17
{SHAREDMEMOWNER,  ASN_OCTET_STR,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 5 }},
#define SHAREDMEMGROUP		18
{SHAREDMEMGROUP,  ASN_OCTET_STR,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 6 }},
#define SHAREDMEMCREATOR		19
{SHAREDMEMCREATOR,  ASN_OCTET_STR,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 7 }},
#define SHAREDMEMCREATORGROUP		20
{SHAREDMEMCREATORGROUP,  ASN_OCTET_STR,  RONLY,   var_sharedMemTable, 3,  { 13, 1, 8 }},
};
/*    (L = length of the oidsuffix) */


struct gstShm{
	unsigned int  uiKey;
	unsigned long ulShmId;
	unsigned int  uiPerms;
	unsigned long ulSize;
	unsigned long ulCpId;
	unsigned long ulLpId;
	unsigned int  uiNAttach;
	unsigned int  uiUID;
	unsigned int  uiGID;
	unsigned int  uiCUID;
	unsigned int  uiCGID;
	time_t ulATime;
	time_t ulDTime;
	time_t ulCTime;
	struct gstShm  *pstShmNext;	
};

/* Function Prototype */
void sharedMemTable_Init();
int sharedMemTable_GetNextShm();
void shmTable_GetShm();

/* Global variable Declaration */
static struct gstShm *gpstShmFirst = NULL;
static struct gstShm *gpstShmStat = NULL;
static struct timeval gstDCTimeVal={0};

static int giShmIdx = 0;
static int giShmCnt = 0;

static unsigned long gulTotalShm = 0;
static unsigned long gulMinShmUsed = 0;
static unsigned long gulMaxShmUsed = 0;
static unsigned long gulAvgShmUsed = 0;

static int giMinIdsUsed = 0;
static int giMaxIdsUsed = 0;
static int giAvgIdsUsed = 0;
static int giShMIdsSaved = 0;

/** Initializes the SharedMemory module */
void
init_SharedMemory(void)
{

    DEBUGMSGTL(("SharedMemory", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("SharedMemory", SharedMemory_variables, variable4,
               SharedMemory_variables_oid);

    /* place any other initialization junk you need here */
}

int
header_sharedMemTable(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
//    static unsigned char string[SPRINT_MAX_LEN];
//    static oid objid[MAX_OID_LEN];
//    static struct counter64 c64;

  #define NAME_LENGTH    13
    oid             newname[MAX_OID_LEN];
    int             iShmIdx=0;
    int             iLowIndex = -1;
    int             iResult=0;

    DEBUGMSGTL(("nuri/SharedMemory", "header_SharedMemory: "));
    DEBUGMSGOID(("nuri/SharedMemory", name, *length));
    DEBUGMSG(("nuri/SharedMemory", " %d\n", exact));

    memcpy((char *) newname, (char *) vp->name, vp->namelen * sizeof(oid));
    /*
     * Find "next" Shm Entry
     */

    sharedMemTable_Init();
    for (;;) {
        iShmIdx = sharedMemTable_GetNextShm();
        if (iShmIdx == -1)
            break;
        newname[NAME_LENGTH] = iShmIdx;
        iResult = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (iResult == 0)) {
            iLowIndex = iShmIdx;
            break;
        }
        if ((!exact && (iResult < 0)) &&
            (iLowIndex == -1 || iShmIdx < iLowIndex)) {
            iLowIndex = iShmIdx;
#ifdef SHM_MONOTONICALLY_INCREASING
            break;
#endif
        }
    }

    if (iLowIndex == -1) {
        DEBUGMSGTL(("nuri/SharedMemory", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,

          (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return iLowIndex;

}


/*
 * var_SharedMemory():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_SharedMemory(struct variable *vp,
                oid     *name,
                size_t  *length,
                int     exact,
                size_t  *var_len,
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    struct timeval stDCTimeStamp = {0};
    static struct shminfo stShmInfo;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
        return NULL;

    gettimeofday(&stDCTimeStamp, NULL);

    stDCTimeStamp.tv_sec = stDCTimeStamp.tv_sec - gstDCTimeVal.tv_sec;
    stDCTimeStamp.tv_usec = stDCTimeStamp.tv_usec - gstDCTimeVal.tv_usec;
    ulong_ret = stDCTimeStamp.tv_sec + (stDCTimeStamp.tv_usec / MICROSEC); 
    if(ulong_ret > CACHE_TIMEOUT){
        shmTable_GetShm();  
        if ((shmctl (0, IPC_INFO, (struct shmid_ds *) &stShmInfo)) < 0 ){
		return NULL;
        }
    }
    *var_len = sizeof(ulong_ret);

  /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case SHAREDMEMAVGUSEDKB:
        return (u_char*) &gulAvgShmUsed;
    case SHAREDMEMAVGIDSUSED:
        return (u_char*) &giAvgIdsUsed;
    case SHAREDMEMMINUSEDKB:
        return (u_char*) &gulMinShmUsed;
    case SHAREDMEMMAXSEGPERPROC:
        return (u_char*) &(stShmInfo.shmseg);
    case SHAREDMEMNUMOFIDSUSED:
        *var_len = sizeof(giShmCnt);	
        return (u_char*) &giShmCnt;
    case SHAREDMEMMAXIDSUSED:
        *var_len = sizeof(giMaxIdsUsed);
        return (u_char*) &giMaxIdsUsed;
    case SHAREDMEMMINSIZE:
        return (u_char*) &(stShmInfo.shmmin);
    case SHAREDMEMMAXSIZE:
        return (u_char*) &(stShmInfo.shmmax);
    case SHAREDMEMTOTALUSEDKB:
        return (u_char*) &gulTotalShm;
    case SHAREDMEMMAXUSEDKB:
        return (u_char*) &gulMaxShmUsed;
    case SHAREDMEMTOTALNUMIDS:
        return (u_char*) &(stShmInfo.shmmni);
    case SHAREDMEMMINIDSUSED:
        *var_len = sizeof(giMinIdsUsed);
        return (u_char*) &giMinIdsUsed;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_sharedMemTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_sharedMemTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static struct gstShm pstShmStat;
   // static struct ipc_perm *pstIpc = &stShm_ds.shm_perm;
    static struct passwd *psPasswd = NULL;
    static struct group *psGroup = NULL;
    static int iShmIdx;
    /*
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
   if (( iShmIdx = header_sharedMemTable(vp,name,length,exact,var_len,write_method)) == MATCH_FAILED )
   {
   		free(gpstShmFirst);
                gpstShmFirst = NULL;
   		return NULL;
   
   }
   if(gpstShmStat){
       memcpy(&pstShmStat, gpstShmStat, sizeof(struct gstShm));
       free(gpstShmFirst);
       gpstShmFirst = NULL;
   }
   else{
       return NULL;
   }
    
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    
    case SHAREDMEMINDEX:
	ulong_ret = iShmIdx;
        return (u_char*) &ulong_ret;
    case SHAREDMEMID:
        sprintf(string,"%lu", pstShmStat.ulShmId); 
        *var_len = strlen(string);
        return (u_char*) string;
    case SHAREDMEMKEY:
        ulong_ret = pstShmStat.uiKey;
        return (u_char*) &ulong_ret;
    case SHAREDMEMMODE:
        ulong_ret = pstShmStat.uiPerms;
        return (u_char*) &ulong_ret;
    case SHAREDMEMOWNER:
	psPasswd = getpwuid(pstShmStat.uiUID);
	if(psPasswd != NULL)
            strcpy(string, psPasswd->pw_name); 
	else
	    strcpy(string, "");
	*var_len = strlen(string);	
	return (u_char*) string;
    case SHAREDMEMGROUP:
	psGroup = getgrgid(pstShmStat.uiGID);
	if(psGroup != NULL)
	    strcpy(string, psGroup->gr_name); 
	else
	    strcpy(string, "");
	*var_len = strlen(string);	
	return (u_char*) string;
    case SHAREDMEMCREATOR:
        psPasswd = getpwuid(pstShmStat.uiCUID);
	if(psPasswd != NULL)
	    strcpy(string, psPasswd->pw_name); 
	else
	    strcpy(string, "");
	*var_len = strlen(string);	
	return (u_char*) string;
    case SHAREDMEMCREATORGROUP:
	psGroup = getgrgid(pstShmStat.uiCGID);
	if(psGroup != NULL)
	    sprintf(string, psGroup->gr_name); 
	else
	    strcpy(string, "");
	*var_len = strlen(string);	
	return (u_char*) string;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/*****************************************************************************
 * name             :   sharedMemTable_Init
 * description      :   
 * input parameters :   None
 * output parameters:   None
 * return type      :   void
 * global variables :   giShmIdx
 * calls            :   shmTable_GetShm
 *****************************************************************************/
void sharedMemTable_Init(){
	giShmIdx = 1;
	shmTable_GetShm();
}


/*****************************************************************************
 * name             :   sharedMemTable_GetNextShm
 * description      :   
 * input parameters :   None
 * output parameters:   None
 * return type      :   int
 * global variables :   gpstShmStat
 * calls            :   void
 *****************************************************************************/
int sharedMemTable_GetNextShm(){
    if(giShmIdx <= giShmCnt){
	gpstShmStat = &gpstShmFirst[giShmIdx - 1];
        return (giShmIdx++);
    }  
    else{
	gpstShmStat = NULL;
        return -1;
    }
}

/*****************************************************************************
 * name             :   shmTable_GetShm
 * description      :   
 * input parameters :   None
 * output parameters:   None
 * return type      :   void
 * global variables :   giShmCnt, gpstShmFirst
 * calls            :   void
 *****************************************************************************/
void shmTable_GetShm(){
    FILE	*fpShm = NULL;    
    int         iFirst = 0;
    int         iSize = 0;
    char        buff[128];
    struct gstShm *stShmCurrent = NULL;
    struct shmid_ds stShm_ds;
    int iIndex;

    gettimeofday(&gstDCTimeVal, NULL);
    giShmCnt = 0; 
    if(fpShm != NULL)
        fclose(fpShm); 
    if ((fpShm = fopen(SHM_FILE, "r" )) != NULL){
        memset(buff, '\0', 128);
	while (fgets(buff, sizeof(buff), fpShm) != NULL){
            if (iFirst == 0){
		iFirst = 1;
		continue;
	    }			
	    iSize = (giShmCnt + 1) * sizeof (struct gstShm);
	    stShmCurrent = (struct gstShm *) realloc (stShmCurrent, iSize);
	    sscanf(buff, " %d %lu %d %lu %lu %lu %ld %d %d %d %d %lu %lu %lu ",
				&(stShmCurrent[giShmCnt].uiKey), 
				&(stShmCurrent[giShmCnt].ulShmId), 
				&(stShmCurrent[giShmCnt].uiPerms), 
				&(stShmCurrent[giShmCnt].ulSize), 
				&(stShmCurrent[giShmCnt].ulCpId), 
				&(stShmCurrent[giShmCnt].ulLpId), 
				&(stShmCurrent[giShmCnt].uiNAttach), 
				&(stShmCurrent[giShmCnt].uiUID), 
				&(stShmCurrent[giShmCnt].uiGID), 
				&(stShmCurrent[giShmCnt].uiCUID), 
				&(stShmCurrent[giShmCnt].uiCGID), 
				&(stShmCurrent[giShmCnt].ulATime), 
				&(stShmCurrent[giShmCnt].ulDTime), 
				&(stShmCurrent[giShmCnt].ulCTime));
	
	    giShmCnt++;	
            memset(buff, '\0', 128);
	}
	gpstShmFirst = stShmCurrent;
        if(fpShm)
    	     fclose(fpShm);
	
	for(iIndex = 0; iIndex < giShmCnt; iIndex++){
            shmctl(gpstShmFirst[iIndex].ulShmId, IPC_STAT, &stShm_ds);

        /* Total shared memory used */
            gulTotalShm += stShm_ds.shm_segsz;  

            if(iIndex == 0){
            /* Assume first shared memory segment is min and max used */
                gulMinShmUsed = stShm_ds.shm_segsz;
                gulMaxShmUsed = stShm_ds.shm_segsz;
            } 
            else{
 
            /* Minimum shared memory used */
                if(stShm_ds.shm_segsz < gulMinShmUsed){
                    gulMinShmUsed = stShm_ds.shm_segsz;
                }

            /* Maximum shared memory used */
                if(stShm_ds.shm_segsz > gulMaxShmUsed){
                    gulMaxShmUsed = stShm_ds.shm_segsz;
                }
            }    
        
        /* Find out min, max and avg. shared mem. Ids used */

            if (giMinIdsUsed == 0 && giMaxIdsUsed == 0 && giAvgIdsUsed == 0){
                giMinIdsUsed  = giShmCnt;
                giMaxIdsUsed  = giShmCnt;
                giAvgIdsUsed  = giShmCnt;
                giShMIdsSaved = giShmCnt;
            }
            else{
                if (giShmCnt < giMinIdsUsed)
                    giMinIdsUsed = giShmCnt;
                else if (giShmCnt > giMaxIdsUsed)
                    giMaxIdsUsed = giShmCnt;

                giAvgIdsUsed = (giShmCnt + giShMIdsSaved)/2;
                giShMIdsSaved = giShmCnt;
            }
        } 
        if(giShmCnt)
             gulAvgShmUsed = gulTotalShm / giShmCnt;
	else
	     gulAvgShmUsed = 0;
    
        gulTotalShm /= KBYTE; /* Total shared memory used in KB */
        gulAvgShmUsed /= KBYTE; /* Average shared memory used in KB */
        gulMinShmUsed /= KBYTE; /* Minimum shared memory used in KB */
        gulMaxShmUsed /= KBYTE; /* Maximum shared memory used in KB */
    }
    else{
		snmp_log(LOG_ERR,"/proc/sysvipc/shm open error\n");
    }
}

