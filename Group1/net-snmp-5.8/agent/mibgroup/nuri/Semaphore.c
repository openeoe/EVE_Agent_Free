/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "Semaphore.h"
#include <linux/sem.h>


#define SEM_MONOTONICALLY_INCREASING
#define SEM_FILE "/proc/sysvipc/sem"
#define CACHE_TIMEOUT 5
#define MICROSEC 1000000

/* 
 * Semaphore_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid Semaphore_variables_oid[] = { 1,3,6,1,4,1,3204,1,3,28 };

/* 
 * variable4 Semaphore_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 Semaphore_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define SEMAPHORETOTALUNDOSTRUCTS		1
{SEMAPHORETOTALUNDOSTRUCTS,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 4 }},
#define SEMAPHORENUMIDSUSED		2
{SEMAPHORENUMIDSUSED,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 11 }},
#define SEMAPHOREMAXNUMOPERATIONS		3
{SEMAPHOREMAXNUMOPERATIONS,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 6 }},
#define SEMAPHOREMINIDSUSED		4
{SEMAPHOREMINIDSUSED,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 12 }},
#define SEMAPHORERESOURCEMAPSIZE		5
{SEMAPHORERESOURCEMAPSIZE,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 1 }},
#define SEMAPHOREMAXNUMUNDOENTRIES		6
{SEMAPHOREMAXNUMUNDOENTRIES,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 7 }},
#define SEMAPHOREMAXVALUE		7
{SEMAPHOREMAXVALUE,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 9 }},
#define SEMAPHORETOTAL		8
{SEMAPHORETOTAL,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 3 }},
#define SEMAPHOREAVGIDSUSED		9
{SEMAPHOREAVGIDSUSED,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 14 }},
#define SEMAPHOREMAXIDSUSED		10
{SEMAPHOREMAXIDSUSED,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 13 }},
#define SEMAPHOREMAXNUMSEMSPERID		11
{SEMAPHOREMAXNUMSEMSPERID,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 5 }},
#define SEMAPHORESIZEUNDOSTRUCTS		12
{SEMAPHORESIZEUNDOSTRUCTS,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 8 }},
#define SEMAPHOREADJUSTEDMAXVALUE		13
{SEMAPHOREADJUSTEDMAXVALUE,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 10 }},
#define SEMAPHORETOTALNUMIDS		14
{SEMAPHORETOTALNUMIDS,  ASN_INTEGER,  RONLY ,  var_Semaphore, 1,  { 2 }},

};
/*    (L = length of the oidsuffix) */


struct gstSem{

	unsigned int  uiKey;
	unsigned long ulSemId;
#if 0
	unsigned int  uiPerms;
	unsigned long ulSize;
	unsigned long ulCpId;
	unsigned long ulLpId;
	unsigned int  uiNAttach;
	unsigned int  uiUID;
	unsigned int  uiGID;
	unsigned int  uiCUID;
	unsigned int  uiCGID;
	unsigned long ulATime;
	unsigned long ulDTime;
	unsigned long ulCTime;
#endif
};

/* Function Prototype */
void Semaphore_GetSem();

/* Global variable section */
static struct gstSem *gpstSemFirst = NULL;
static struct gstSem *gpstSemStat = NULL;
static struct timeval gstDCTimeVal={0};
static int giSemIdx = 0;
static int giSemCnt = 0;

static int giSemIdsSaved = 0;
static int giMinIdsUsed = 0;
static int giMaxIdsUsed = 0;
static int giAvgIdsUsed = 0;




/** Initializes the Semaphore module */
void
init_Semaphore(void)
{

    DEBUGMSGTL(("Semaphore", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("Semaphore", Semaphore_variables, variable4,
               Semaphore_variables_oid);
    /* place any other initialization junk you need here */
}

/*
 * var_Semaphore():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_Semaphore(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    static int iSemIdx;
  //  static struct semid_ds stSem_ds;
    static struct seminfo stSemInfo;
    static union semun stSemUn;
    struct timeval stDCTimeStamp = {0};

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
        return NULL;
    
    gettimeofday(&stDCTimeStamp, NULL);

    stDCTimeStamp.tv_sec = stDCTimeStamp.tv_sec - gstDCTimeVal.tv_sec;
    stDCTimeStamp.tv_usec = stDCTimeStamp.tv_usec - gstDCTimeVal.tv_usec;
    ulong_ret = stDCTimeStamp.tv_sec + (stDCTimeStamp.tv_usec / MICROSEC); 
    if(ulong_ret > CACHE_TIMEOUT){
       Semaphore_GetSem();
       stSemUn.array = (ushort *) &stSemInfo;
       if(semctl(0, 0, IPC_INFO, stSemUn) < 0)
	    return NULL; 
    }
    *var_len = sizeof(u_long);

  /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case SEMAPHORETOTALUNDOSTRUCTS:
        ulong_ret = stSemInfo.semmnu;
        return (u_char*) &ulong_ret;
    case SEMAPHORENUMIDSUSED:
       *var_len = sizeof(giSemCnt);
        return (u_char*) &giSemCnt;
    case SEMAPHOREMAXNUMOPERATIONS:
       ulong_ret = stSemInfo.semopm;
       return (u_char*) &ulong_ret;
    case SEMAPHOREMINIDSUSED:
       *var_len = sizeof(giMinIdsUsed);
       return (u_char*) &giMinIdsUsed;
    case SEMAPHORERESOURCEMAPSIZE:
        ulong_ret = stSemInfo.semmap;
        return (u_char*) &ulong_ret;
    case SEMAPHOREMAXNUMUNDOENTRIES:
        ulong_ret = stSemInfo.semume;
        return (u_char*) &ulong_ret;
    case SEMAPHOREMAXVALUE:
       	ulong_ret = stSemInfo.semvmx;
        return (u_char*) &ulong_ret;
    case SEMAPHORETOTAL:
        ulong_ret = stSemInfo.semmns;
        return (u_char*) &ulong_ret;
    case SEMAPHOREAVGIDSUSED:
        *var_len = sizeof(giAvgIdsUsed);
        return (u_char*) &giAvgIdsUsed;
    case SEMAPHOREMAXIDSUSED:
       *var_len = sizeof(giMaxIdsUsed);
        return (u_char*) &giMaxIdsUsed;
    case SEMAPHOREMAXNUMSEMSPERID:
       ulong_ret = stSemInfo.semmsl;
       return (u_char*) &ulong_ret;
    case SEMAPHORESIZEUNDOSTRUCTS:
       ulong_ret = stSemInfo.semusz;
       return (u_char*) &ulong_ret;
#if 0
    case SEMAPHOREADJUSTEDMAXVALUE:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
#endif
    case SEMAPHORETOTALNUMIDS:
        ulong_ret = stSemInfo.semmni;
        return (u_char*) &ulong_ret;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/*****************************************************************************
 * name             :   Semaphore_GetSem
 * description      :   
 * input parameters :   None
 * output parameters:   None
 * return type      :   void
 * global variables :   giSemCnt, gpstSemFirst
 * calls            :   void
 *****************************************************************************/
void Semaphore_GetSem(){
    FILE	*fpSem;    
    int         iFirst = 0;
    char        buff[128];
    struct gstSem *stSemCurrent = NULL;
    int iIndex;
    
    gettimeofday(&gstDCTimeVal, NULL); 
    giSemCnt = 0; 
  
    if ((fpSem = fopen(SEM_FILE, "r" )) != NULL) {
	memset(buff, '\0', 128);
	while (fgets(buff, sizeof(buff), fpSem) != NULL) {
	    if (iFirst == 0){
		iFirst = 1;
		continue;
	    }			
	    stSemCurrent = (struct gstSem *) malloc (sizeof(struct gstSem));

	/*	sscanf(buff, " %d %lu %d %lu %lu %lu %ld %d %d %d %d %lu %lu %lu ",
				&(stSemCurrent->uiKey), 
				&(stSemCurrent->ulSemId), 
				&(stSemCurrent->uiPerms), 
				&(stSemCurrent->ulSize), 
				&(stSemCurrent->ulCpId), 
				&(stSemCurrent->ulLpId), 
				&(stSemCurrent->uiNAttach), 
				&(stSemCurrent->uiUID), 
				&(stSemCurrent->uiGID), 
				&(stSemCurrent->uiCUID), 
				&(stSemCurrent->uiCGID), 
				&(stSemCurrent->ulATime), 
				&(stSemCurrent->ulDTime), 
				&(stSemCurrent->ulCTime));
        */

	   sscanf(buff, " %d %lu ",
				&(stSemCurrent->uiKey), 
				&(stSemCurrent->ulSemId));
	   giSemCnt++;	
           memset(buff, '\0', 128);
	}

//	gpstSemFirst = stSemCurrent;
        if(stSemCurrent){
            free(stSemCurrent);
            stSemCurrent = NULL;
        } 
        if(fpSem)
    	    fclose(fpSem);

	for (iIndex=0; iIndex < giSemCnt; iIndex++){

        /* Find out min, max and avg. semaphore Ids used */
            if (giMinIdsUsed == 0 && giMaxIdsUsed == 0 && giAvgIdsUsed == 0){
                giMinIdsUsed = giSemCnt;
                giMaxIdsUsed = giSemCnt;
                giAvgIdsUsed = giSemCnt;
                giSemIdsSaved = giSemCnt;
            }
            else{
                if (giSemCnt < giMinIdsUsed)
                    giMinIdsUsed = giSemCnt;
                else if (giSemCnt > giMaxIdsUsed)
                    giMaxIdsUsed = giSemCnt;
                giAvgIdsUsed = (giSemCnt + giSemIdsSaved)/2;
                giSemIdsSaved = giSemCnt;
            }

        }
    }
    else{
	snmp_log(LOG_ERR, "/proc/sysvipc/sem open error\n");
    }

}





