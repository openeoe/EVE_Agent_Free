/*****************************************************************************
 *
 * [userAccessControlTable.c]
 *
 *      Copyright (c) 2002 Wipro Technologies
 *      All rights Reserved
 *
 * author:
 *      Name Karthikeyan Subramani
 *
 * description :
 *      [ TO get the user details]
 *
 * TODO:
 *      [ Things to be improved ]
 *
 * CM Details:
 *
 * $Author: karthis $
 * $Log: userAccessControlTable.c,v $
 * Revision 1.3  2004/01/21 07:24:48  karthis
 * fixed crash copied the UAC UGC from hp src
 *
 * Revision 1.4  2004/01/19 06:05:52  vijaysp
 * Added endpwent() in two places to avoid agent crash
 *
 * Revision 1.3  2004/01/06 05:42:09  testteam
 * gmaxuser =0
 *
 * Revision 1.2  2004/01/05 14:57:46  karthis
 * update coding standard
 *
 * Revision 1.4  2004/01/05 14:04:07  karthis
 * update coding standard
 *
 * $State: Exp $  
 * $Id: userAccessControlTable.c,v 1.3 2004/01/21 07:24:48 karthis Exp $
 * $Name: NASCenterAgent_29Jan2004_Patch3_SrcRls $
 ****************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/********************************* includes *********************************/
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "userAccessControlTable.h"
#include <pwd.h>
/* 
 * userAccessControlTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/****************************** local macros ********************************
 *
 * (Macros shareable with rest of the modules are present in .h file)
 */

#define USERINDEX_MONOTONICALLY_INCREASING
#define UCACHE_TIME 5 

/********************* local structure/union definitions ********************/
struct user
{ 
  char username[100];
  char password[100]; 
  char uid[100];
  int gid;
  char desc[100];
}userinfo;
struct passwd *pw;
struct timeval gusttDCTimeVal = { 0 };


/********************* prototypes for local functions ***********************/
void useraccessTable_Init();
int useraccessTable_GetNext();
int
header_useraccessTable(struct variable *vp,
                oid     *name,
                size_t  *length,
                int     exact,
                size_t  *var_len,
                WriteMethod **write_method);
void GetUserData(void);

/************************* Globals within this module ***********************/
int gflag=0;
int guserindex=0; 
int gmaxuser=0;


oid userAccessControlTable_variables_oid[] = { 1,3,6,1,4,1,3204,1,3,34,4};

/* 
 * variable4 userAccessControlTable_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable4 userAccessControlTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define USERACCESSCONTROLINDEX		1
{USERACCESSCONTROLINDEX,  ASN_UNSIGNED,  RONLY,   var_userAccessControlTable, 3,  { 1, 1, 1 }},
#define USERACCESSCONTROLID		2
{USERACCESSCONTROLID,  ASN_OCTET_STR,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 2 }},
#define USERACCESSCONTROLPASSWORD		3
{USERACCESSCONTROLPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 3 }},
#define USERACCESSCONTROLNAME		4
{USERACCESSCONTROLNAME,  ASN_OCTET_STR,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 4 }},
#define USERACCESSCONTROLDESCRIPTION		5
{USERACCESSCONTROLDESCRIPTION,  ASN_OCTET_STR,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 5 }},
#define USERACCESSCONTROLGROUPID		6
{USERACCESSCONTROLGROUPID,  ASN_INTEGER,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 6 }},
#define USERACCESSCONTROLCREATEDDATE		7
{USERACCESSCONTROLCREATEDDATE,  ASN_OCTET_STR,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 7 }},
#define USERACCESSCONTROLUPDATEDDATE		8
{USERACCESSCONTROLUPDATEDDATE,  ASN_OCTET_STR,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 8 }},
#define USERACCESSCONTROLSTATUS		9
{USERACCESSCONTROLSTATUS,  ASN_INTEGER,  RWRITE,  var_userAccessControlTable, 3,  { 1, 1, 9 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the userAccessControlTable module */
void
init_userAccessControlTable(void)
{

    DEBUGMSGTL(("userAccessControlTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("userAccessControlTable", userAccessControlTable_variables, variable4,
               userAccessControlTable_variables_oid);
    /* place any other initialization junk you need here */
}

/*****************************************************************************
 *
 * name             :   GetUserData
 * description      :   It will intialize the maxusers
 * input parameters :   [void]  - No input Parameters
 * output parameters:   [void] -  No output Parameters
 * return type      :   [void] - No return type
 * global variables :   [gflag=0, gmaxuser] 
 * calls            :   [header_useraccess,init_userAcessControlTable]
 */

void GetUserData(void)
{ 
    DEBUGMSGTL(("userAccessControlTable", "GetUser Called\n"));
    gmaxuser=0;
    gettimeofday(&gusttDCTimeVal, NULL);
    setpwent();
    while(1)
    {  pw=getpwent();
       if (pw==(struct passwd *) NULL)
           break;
       gflag=0; 
       gmaxuser++;
    }
    endpwent();
}

/*****************************************************************************
 *
 * name             :   header_useraccessTable
 * description      :   It will generate the index
 * input parameters :   [struct variable *vp,
 *                       oid * name,
 *                        size_t * length,
 *                        int exact, size_t * var_len, WriteMethod ** write_method]   
 * output parameters:   [void] 
 * return type      :   [int] - index  
 * global variables :   
 * calls            :   [var_useAccessControl]
 */


/*
 * header_useraccessTable():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and NuriEnterprise directories.
 */
int
header_useraccessTable(struct variable *vp,
                oid     *name,
                size_t  *length,
                int     exact,
                size_t  *var_len,
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret; static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    #define NAME_LENGTH     14
    oid             newname[MAX_OID_LEN];

    int             uIdx, ILowIndex = -1;
    int             IResult;


    DEBUGMSGOID(("userAccessControlTable", name, *length));
    DEBUGMSG(("userAccessControlTable", " %d\n", exact));

    memcpy((char *) newname, (char *) vp->name, (int) vp->namelen * sizeof(oid))
;

     /* find "next" interface */

    useraccessTable_Init ();

    for (;;) {

	uIdx = useraccessTable_GetNext ();
        if (uIdx == -1)
            break;
        newname[NAME_LENGTH] = uIdx;
        IResult = snmp_oid_compare(name, *length, newname, vp->namelen + 1);
        if (exact && (IResult == 0)) {
            ILowIndex = uIdx;
            break;
        }
        if ((!exact && (IResult < 0)) &&
            (ILowIndex == -1 || uIdx < ILowIndex)) {
            ILowIndex = uIdx;
#ifdef USERINDEX_MONOTONICALLY_INCREASING
            break;
#endif
        }
    }

    endpwent();

    if (ILowIndex == -1) {
        DEBUGMSGTL(("userAccessControlTable", "... index out of range\n"));
        return (MATCH_FAILED);
    }

    memcpy((char *) name, (char *) newname,

   (vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return ILowIndex;
}

/*****************************************************************************
 * name             :   useraccessTable_Init
 * description      :   Initializes the useraccess table index
 * input parameters :   None
 * output parameters:  
 * return type      :
 * global variables :   
 * calls            :   None
 *****************************************************************************/

void useraccessTable_Init()
{
    setpwent ();
    guserindex=1;
}

/*****************************************************************************
 * name             :   useraccessTable_GetNextInterface
 * input parameters :   None
 * output parameters:   
 * return type      :   void
 * global variables :   
 * calls            :   None
 *****************************************************************************/
int useraccessTable_GetNext()
{ 
        int i=0;

        DEBUGMSGTL(("userAccessControlTable", "Inside useraccessTable_GetNext "
                    "guserindex=%d, gmaxuser=%d\n", guserindex, gmaxuser));

	if (guserindex<=gmaxuser)
	{
	          pw=getpwent();
                  if (pw == (struct passwd *) NULL)
                  {
                     return -1; 
                  }
	          strcpy(userinfo.username,pw->pw_name);
		  strcpy(userinfo.password,pw->pw_passwd);
                  sprintf(userinfo.uid,"%d",pw->pw_uid);
		  userinfo.gid=pw->pw_gid;
                  if(pw->pw_gecos)
                  strcpy(userinfo.desc,pw->pw_gecos); 
		  return guserindex++;
	}
	else
        {
            return -1;
        }
}

/*
 * var_userAccessControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_userAccessControlTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static int index;
    static u_long ulong_retu;
    static struct timeval stDCTimeStamp = {0};
     
/* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */

    gettimeofday(&stDCTimeStamp, NULL);

    stDCTimeStamp.tv_sec = stDCTimeStamp.tv_sec - gusttDCTimeVal.tv_sec;
    stDCTimeStamp.tv_usec = stDCTimeStamp.tv_usec - gusttDCTimeVal.tv_usec;
    ulong_retu = stDCTimeStamp.tv_sec + (stDCTimeStamp.tv_usec/1000000);

    if(ulong_retu > UCACHE_TIME)
    {
       /* CACHE_TIME elapsed bet'n two successive requests */
       GetUserData();
    }

   index=header_useraccessTable(vp,name,length,exact,var_len,write_method);

   if(index== MATCH_FAILED)
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case USERACCESSCONTROLINDEX:
        *var_len=sizeof(index);
	return (u_char*) &index;
    case USERACCESSCONTROLID:
      //  *write_method = write_userAccessControlID;
	*var_len=strlen(userinfo.uid);
        return (u_char*) userinfo.uid;
   case USERACCESSCONTROLPASSWORD:
       // *write_method = write_userAccessControlPassword;
        *var_len=strlen(userinfo.password);
        return (u_char*) userinfo.password;
   case USERACCESSCONTROLNAME:
        //*write_method = write_userAccessControlName;
          *var_len=strlen(userinfo.username);
          return (u_char*)userinfo.username;
   case USERACCESSCONTROLDESCRIPTION:
       // *write_method = write_userAccessControlDescription;
        *var_len=strlen(userinfo.desc);
        return (u_char*) userinfo.desc;
   case USERACCESSCONTROLGROUPID:
      // *write_method = write_userAccessControlGroupId;
        *var_len=sizeof(userinfo.gid);
        return (u_char*) &userinfo.gid;
/*    USERACCESSCONTROLCREATEDDATE:
        *write_method = write_userAccessControlCreatedDate;
        VAR = VALUE;	
        return (u_char*) &VAR;
    USERACCESSCONTROLUPDATEDDATE:
        *write_method = write_userAccessControlUpdatedDate;
        VAR = VALUE;	
        return (u_char*) &VAR;
    USERACCESSCONTROLSTATUS:
        *write_method = write_userAccessControlStatus;
        VAR = VALUE;	
        return (u_char*) &VAR;*/
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_userAccessControlID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to userAccessControlTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userAccessControlPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to userAccessControlTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userAccessControlName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to userAccessControlTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userAccessControlDescription(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to userAccessControlTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userAccessControlGroupId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to userAccessControlTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userAccessControlCreatedDate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to userAccessControlTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userAccessControlUpdatedDate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to userAccessControlTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userAccessControlStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to userAccessControlTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to userAccessControlTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
