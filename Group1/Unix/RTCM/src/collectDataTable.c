/*
 * Note: this file originally auto-generated by mib2c using
 *       : mib2c.array-user.conf,v 5.15.2.1 2003/02/27 05:59:41 rstory Exp $
 *
 * $Id: collectDataTable.c,v 1.18 2003/11/27 03:03:22 vijaysp Exp $
 *
 *
 * For help understanding NET-SNMP in general, please check the 
 *     documentation and FAQ at:
 *
 *     http://www.net-snmp.org/
 *
 *
 * For help understanding this code, the agent and how it processes
 *     requests, please check the following references.
 *
 *     http://www.net-snmp.org/tutorial/
 *
 *
 * You can also join the #net-snmp channel on irc.openprojects.net
 *     and ask for help there.
 *
 *
 * And if all else fails, send a detailed message to the developers
 *     describing the problem you are having to:
 *
 *    net-snmp-coders@lists.sourceforge.net
 *
 *
 * Yes, there is lots of code here that you might not use. But it is much
 * easier to remove code than to add it!
 */

/* <Start: WIP_NURI_ALL > */

/********************************* includes *********************************/

#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>

#ifdef WIN32
#include <winsock2.h>
#else
#include <netdb.h>
#endif /* WIN32 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/snmp_assert.h>

#include "collectDataTable.h"

/****************************** local macros ********************************
 *
 * (Macros shareable with rest of the modules are present in .h file)
 */

#define RTC_FILEPATH_LEN 255

/********************* prototypes for local functions ***********************/

unsigned long RTC_Get_Current_Time();

void
RTC_Load_Container_From_File ();

void
RTC_Get_Time_Frequency (int iToday, collectDataTable_context *pstCtx,
                  unsigned long *ulSTime, unsigned long *ulETime, int *iFreq);

int
RTC_Fetch_Var_Val (oid * name, size_t namelen, u_long *pulNewValue);

void
RTC_Collect_Store_Variables (unsigned int reg, void *list);

void
RTC_callback (unsigned int reg, void *clientarg);

void Load_Container_From_RTC_File ();

int Form_Linked_List (RTC_List *list, int *length);

int Sort_Linked_List (RTC_List *start);

int RTC_Calc_Num_Nodes_Interval (int *intvl);

int RTC_Within_Period (collectDataTable_context *ctx);

int
RTC_Add_Intervals_To_List (collectDataTable_context *ctx, RTC_List *list,
                           int *interval, int *length);

int RTC_Retrieve_Log_Variable (unsigned long index);

int
RTC_Check_LogFile_Name ();

int RTC_Get_ASCII_Time(char *time_str);

/************************* Globals within this module ***********************/

static     netsnmp_handler_registration *my_handler = NULL;
static     netsnmp_table_array_callbacks cb;

oid collectDataTable_oid[] = { collectDataTable_TABLE_OID };
size_t collectDataTable_oid_len = OID_LENGTH(collectDataTable_oid);

FILE *fpl=NULL;
RTC_List *pstHeadList = NULL;

unsigned int guiRTCReg1 = 0;
unsigned int guiRTCReg2 = 0;
unsigned int guiRTCReg3 = 0;

int iLogFlag = 0;
int giContextChanged = 0;

char szSavedLogFile [RTC_FILEPATH_LEN] = { 0 };

/************************* externs  ***********************/

extern char gcInfoLogFileSystemData[];

/* <End: WIP_NURI_ALL > */

#ifdef collectDataTable_IDX2
/************************************************************
 * keep binary tree to find context by name
 */
static int collectDataTable_cmp( const void *lhs, const void *rhs );

/************************************************************
 * compare two context pointers here. Return -1 if lhs < rhs,
 * 0 if lhs == rhs, and 1 if lhs > rhs.
 */
static int
collectDataTable_cmp( const void *lhs, const void *rhs )
{
    collectDataTable_context *context_l =
        (collectDataTable_context *)lhs;
    collectDataTable_context *context_r =
        (collectDataTable_context *)rhs;

    /*
     * check primary key, then secondary. Add your own code if
     * there are more than 2 indexes
     */
    int rc;

    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR,
             "collectDataTable_compare not implemented! Container order undefined\n" );
    return 0;
#endif
    
    /*
     * EXAMPLE:
     *   
     * rc = strcmp( context_l->xxName, context_r->xxName);
     *
     * if(rc)
     *   return rc;
     *
     * TODO: fix secondary keys (or delete if there are none)
     *
     * if(context_l->yy < context_r->yy) 
     *   return -1;
     *
     * return (context_l->yy == context_r->yy) ? 0 : 1;
     */
}

/************************************************************
 * search tree
 */
/** TODO: set additional indexes as parameters */
collectDataTable_context *
collectDataTable_get( const char *name, int len )
{
    collectDataTable_context tmp;

    /** we should have a secondary index */
    netsnmp_assert(cb.container->next != NULL);
    
    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "collectDataTable_get not implemented!\n" );
    return NULL;
#endif

    /*
     * EXAMPLE:
     *
     * if(len > sizeof(tmp.xxName))
     *   return NULL;
     *
     * strncpy( tmp.xxName, name, sizeof(tmp.xxName) );
     * tmp.xxName_len = len;
     *
     * return CONTAINER_FIND(cb.container->next, &tmp);
     */
}
#endif


/************************************************************
 * Initializes the collectDataTable module
 */
void
init_collectDataTable(void)
{
    initialize_table_collectDataTable();

    /*
     * TODO: perform any startup stuff here
     */

    /* <Start: WIP_NURI_ALL > */

    RTC_Load_Container_From_File ();
    RTC_callback (1, (void *) NULL);

    /* <End: WIP_NURI_ALL > */
}

/************************************************************
 * the *_row_copy routine
 */
static int collectDataTable_row_copy(collectDataTable_context * dst,
                         collectDataTable_context * src)
{
    if(!dst||!src)
        return 1;
        
    /*
     * copy index, if provided
     */
    if(dst->index.oids)
        free(dst->index.oids);
    if(snmp_clone_mem( (void*)&dst->index.oids, src->index.oids,
                           src->index.len * sizeof(oid) )) {
        dst->index.oids = NULL;
        return 1;
    }
    dst->index.len = src->index.len;
    

    /*
     * copy components into the context structure
     */
    dst->collectDataIndex = src->collectDataIndex;

    dst->collectDataType = src->collectDataType;

    memcpy ( dst->collectDataVariable, src->collectDataVariable, src->collectDataVariable_len );
    dst->collectDataVariable_len = src->collectDataVariable_len;

    memcpy( dst->collectDataStartDate, src->collectDataStartDate, src->collectDataStartDate_len );
    dst->collectDataStartDate_len = src->collectDataStartDate_len;

    memcpy( dst->collectDataEndDate, src->collectDataEndDate, src->collectDataEndDate_len );
    dst->collectDataEndDate_len = src->collectDataEndDate_len;

    dst->collectDataMonStartTime = src->collectDataMonStartTime;

    dst->collectDataMonEndTime = src->collectDataMonEndTime;

    dst->collectDataMonFrequent = src->collectDataMonFrequent;

    dst->collectDataTueStartTime = src->collectDataTueStartTime;

    dst->collectDataTueEndTime = src->collectDataTueEndTime;

    dst->collectDataTueFrequent = src->collectDataTueFrequent;

    dst->collectDataWedStartTime = src->collectDataWedStartTime;

    dst->collectDataWedEndTime = src->collectDataWedEndTime;

    dst->collectDataWedFrequent = src->collectDataWedFrequent;

    dst->collectDataThuStartTime = src->collectDataThuStartTime;

    dst->collectDataThuEndTime = src->collectDataThuEndTime;

    dst->collectDataThuFrequent = src->collectDataThuFrequent;

    dst->collectDataFriStartTime = src->collectDataFriStartTime;

    dst->collectDataFriEndTime = src->collectDataFriEndTime;

    dst->collectDataFriFrequent = src->collectDataFriFrequent;

    dst->collectDataSatStartTime = src->collectDataSatStartTime;

    dst->collectDataSatEndTime = src->collectDataSatEndTime;

    dst->collectDataSatFrequent = src->collectDataSatFrequent;

    dst->collectDataSunStartTime = src->collectDataSunStartTime;

    dst->collectDataSunEndTime = src->collectDataSunEndTime;

    dst->collectDataSunFrequent = src->collectDataSunFrequent;

    dst->collectDataStatus = src->collectDataStatus;

    return 0;
}

#ifdef collectDataTable_SET_HANDLING

/*
 * the *_extract_index routine
 */
int
collectDataTable_extract_index( collectDataTable_context * ctx, netsnmp_index * hdr )
{
    /*
     * temporary local storage for extracting oid index
     */
    netsnmp_variable_list var_collectDataIndex;
    int err;

    /*
     * copy index, if provided
     */
    if(hdr) {
        netsnmp_assert(ctx->index.oids == NULL);
        if(snmp_clone_mem( (void*)&ctx->index.oids, hdr->oids,
                           hdr->len * sizeof(oid) )) {
            return -1;
        }
        ctx->index.len = hdr->len;
    }

    /**
     * Create variable to hold each component of the index
     */
       memset( &var_collectDataIndex, 0x00, sizeof(var_collectDataIndex) );
       var_collectDataIndex.type = ASN_UNSIGNED;
       /** TODO: link this index to the next, or NULL for the last one */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "collectDataTable_extract_index index list not implemented!\n" );
    return 0;
#else 
       /* var_collectDataIndex.next_variable = &var_XX; */
#endif


    /*
     * parse the oid into the individual components
     */
    err = parse_oid_indexes( hdr->oids, hdr->len, &var_collectDataIndex );
    if (err == SNMP_ERR_NOERROR) {
       /*
        * copy components into the context structure
        */
                ctx->collectDataIndex = *var_collectDataIndex.val.integer;
   
   
           /*
            * TODO: check index for valid values. For EXAMPLE:
            *
              * if ( *var_collectDataIndex.val.integer != XXX ) {
          *    err = -1;
          * }
          */
    }

    /*
     * parsing may have allocated memory. free it.
     */
    snmp_reset_var_buffers( &var_collectDataIndex );

    return err;
}

/************************************************************
 * the *_can_activate routine is called
 * when a row is changed to determine if all the values
 * set are consistent with the row's rules for a row status
 * of ACTIVE.
 *
 * return 1 if the row could be ACTIVE
 * return 0 if the row is not ready for the ACTIVE state
 */
int collectDataTable_can_activate(collectDataTable_context *undo_ctx,
                      collectDataTable_context *row_ctx,
                      netsnmp_request_group * rg)
{
    /*
     * TODO: check for activation requirements here
     */
    return 1;
}

/************************************************************
 * the *_can_deactivate routine is called when a row that is
 * currently ACTIVE is set to a state other than ACTIVE. If
 * there are conditions in which a row should not be allowed
 * to transition out of the ACTIVE state (such as the row being
 * referred to by another row or table), check for them here.
 *
 * return 1 if the row can be set to a non-ACTIVE state
 * return 0 if the row must remain in the ACTIVE state
 */
int collectDataTable_can_deactivate(collectDataTable_context *undo_ctx,
                        collectDataTable_context *row_ctx,
                        netsnmp_request_group * rg)
{
    /*
     * TODO: check for deactivation requirements here
     */
    return 1;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int collectDataTable_can_delete(collectDataTable_context *undo_ctx,
                    collectDataTable_context *row_ctx,
                    netsnmp_request_group * rg)
{
    /*
     * probably shouldn't delete a row that we can't
     * deactivate.
     */
    if(collectDataTable_can_deactivate(undo_ctx,row_ctx,rg) != 1)
        return 0;
    
    /*
     * TODO: check for other deletion requirements here
     */
    return 1;
}

#ifdef collectDataTable_ROW_CREATION
/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated collectDataTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
collectDataTable_context *
collectDataTable_create_row( netsnmp_index* hdr)
{
    collectDataTable_context * ctx =
        SNMP_MALLOC_TYPEDEF(collectDataTable_context);
    if(!ctx)
        return NULL;
        
    /*
     * TODO: check indexes, if necessary.
     */
    if(collectDataTable_extract_index( ctx, hdr )) {
        free(ctx->index.oids);
        free(ctx);
        return NULL;
    }

    /* netsnmp_mutex_init(ctx->lock);
       netsnmp_mutex_lock(ctx->lock); */

    /*
     * TODO: initialize any default values here. This is also
     * first place you really should allocate any memory for
     * yourself to use.  If you allocated memory earlier,
     * make sure you free it for earlier error cases!
     */
    /**
     ctx->collectDataIndex = 0;
     ctx->collectDataType = 0;
     ctx->collectDataVariable = 0;
     ctx->collectDataStartDate = 0;
     ctx->collectDataEndDate = 0;
     ctx->collectDataMonStartTime = 0;
     ctx->collectDataMonEndTime = 0;
     ctx->collectDataMonFrequent = 0;
     ctx->collectDataTueStartTime = 0;
     ctx->collectDataTueEndTime = 0;
     ctx->collectDataTueFrequent = 0;
     ctx->collectDataWedStartTime = 0;
     ctx->collectDataWedEndTime = 0;
     ctx->collectDataWedFrequent = 0;
     ctx->collectDataThuStartTime = 0;
     ctx->collectDataThuEndTime = 0;
     ctx->collectDataThuFrequent = 0;
     ctx->collectDataFriStartTime = 0;
     ctx->collectDataFriEndTime = 0;
     ctx->collectDataFriFrequent = 0;
     ctx->collectDataSatStartTime = 0;
     ctx->collectDataSatEndTime = 0;
     ctx->collectDataSatFrequent = 0;
     ctx->collectDataSunStartTime = 0;
     ctx->collectDataSunEndTime = 0;
     ctx->collectDataSunFrequent = 0;
     ctx->collectDataStatus = 0;
    */

    /* Assume system resource (1) as default for collectDataType */

     ctx->collectDataType = 1;

     ctx->collectDataStartDate_len = strlen (ctx->collectDataStartDate);
     ctx->collectDataEndDate_len   = strlen (ctx->collectDataStartDate);

     ctx->collectDataMonFrequent = RTC_DEFAULT_INTERVAL;
     ctx->collectDataTueFrequent = RTC_DEFAULT_INTERVAL;
     ctx->collectDataWedFrequent = RTC_DEFAULT_INTERVAL;
     ctx->collectDataThuFrequent = RTC_DEFAULT_INTERVAL;
     ctx->collectDataFriFrequent = RTC_DEFAULT_INTERVAL;
     ctx->collectDataSatFrequent = RTC_DEFAULT_INTERVAL;
     ctx->collectDataSunFrequent = RTC_DEFAULT_INTERVAL;

    return ctx;
}
#endif

/************************************************************
 * the *_duplicate row routine
 */
collectDataTable_context *
collectDataTable_duplicate_row( collectDataTable_context * row_ctx)
{
    collectDataTable_context * dup;

    if(!row_ctx)
        return NULL;

    dup = SNMP_MALLOC_TYPEDEF(collectDataTable_context);
    if(!dup)
        return NULL;
        
    if(collectDataTable_row_copy(dup,row_ctx)) {
        free(dup);
        dup = NULL;
    }

    return dup;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index * collectDataTable_delete_row( collectDataTable_context * ctx )
{
  /* netsnmp_mutex_destroy(ctx->lock); */

    if(ctx->index.oids)
        free(ctx->index.oids);

    /*
     * TODO: release any memory you allocated here...
     */

    /*
     * release header
     */
    free( ctx );

    return NULL;
}


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void collectDataTable_set_reserve1( netsnmp_request_group *rg )
{
    collectDataTable_context *row_ctx =
            (collectDataTable_context *)rg->existing_row;
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;
    int rc;


    /*
     * TODO: loop through columns, check syntax and lengths. For
     * columns which have no dependencies, you could also move
     * the value/range checking here to attempt to catch error
     * cases as early as possible.
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch(current->tri->colnum) {

        case COLUMN_COLLECTDATAINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
            rc = netsnmp_check_vb_type_and_size(var, ASN_UNSIGNED,
                                                sizeof(row_ctx->collectDataIndex));
        break;

        case COLUMN_COLLECTDATATYPE:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                                sizeof(row_ctx->collectDataType));
    if ((long) *var->val.integer < COLLECTDATATYPE_MIN ||
        (long) *var->val.integer > COLLECTDATATYPE_MAX)
      {
         rc = SNMP_ERR_WRONGVALUE;
      }
            break;

        case COLUMN_COLLECTDATAVARIABLE:
            /** OBJECTID = ASN_OBJECT_ID */
            rc = netsnmp_check_vb_type_and_size(var, ASN_OBJECT_ID,
                                                var->val_len);
        break;

        case COLUMN_COLLECTDATASTARTDATE:
            /** DateAndTime = ASN_OCTET_STR */
            rc = netsnmp_check_vb_type_and_size(var, ASN_OCTET_STR,
                                                var->val_len);
        break;

        case COLUMN_COLLECTDATAENDDATE:
            /** DateAndTime = ASN_OCTET_STR */
            rc = netsnmp_check_vb_type_and_size(var, ASN_OCTET_STR,
                                                var->val_len);
        break;

        case COLUMN_COLLECTDATAMONSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                    sizeof(row_ctx->collectDataMonStartTime));
        break;

        case COLUMN_COLLECTDATAMONENDTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                      sizeof(row_ctx->collectDataMonEndTime));
        break;

        case COLUMN_COLLECTDATAMONFREQUENT:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                     sizeof(row_ctx->collectDataMonFrequent));
        break;

        case COLUMN_COLLECTDATATUESTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                    sizeof(row_ctx->collectDataTueStartTime));
        break;

        case COLUMN_COLLECTDATATUEENDTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                      sizeof(row_ctx->collectDataTueEndTime));
        break;

        case COLUMN_COLLECTDATATUEFREQUENT:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                     sizeof(row_ctx->collectDataTueFrequent));
        break;

        case COLUMN_COLLECTDATAWEDSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataWedStartTime));
        break;

        case COLUMN_COLLECTDATAWEDENDTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataWedEndTime));
        break;

        case COLUMN_COLLECTDATAWEDFREQUENT:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                                sizeof(row_ctx->collectDataWedFrequent));
        break;

        case COLUMN_COLLECTDATATHUSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataThuStartTime));
        break;

        case COLUMN_COLLECTDATATHUENDTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataThuEndTime));
        break;

        case COLUMN_COLLECTDATATHUFREQUENT:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                                sizeof(row_ctx->collectDataThuFrequent));
        break;

        case COLUMN_COLLECTDATAFRISTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataFriStartTime));
        break;

        case COLUMN_COLLECTDATAFRIENDTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataFriEndTime));
        break;

        case COLUMN_COLLECTDATAFRIFREQUENT:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                                sizeof(row_ctx->collectDataFriFrequent));
        break;

        case COLUMN_COLLECTDATASATSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataSatStartTime));
        break;

        case COLUMN_COLLECTDATASATENDTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataSatEndTime));
        break;

        case COLUMN_COLLECTDATASATFREQUENT:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                                sizeof(row_ctx->collectDataSatFrequent));
        break;

        case COLUMN_COLLECTDATASUNSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataSunStartTime));
        break;

        case COLUMN_COLLECTDATASUNENDTIME:
            /** TICKS = ASN_TIMETICKS */
            rc = netsnmp_check_vb_type_and_size(var, ASN_TIMETICKS,
                                                sizeof(row_ctx->collectDataSunEndTime));
        break;

        case COLUMN_COLLECTDATASUNFREQUENT:
            /** INTEGER = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                                sizeof(row_ctx->collectDataSunFrequent));
        break;

        case COLUMN_COLLECTDATASTATUS:
            /** RowStatus = ASN_INTEGER */
            rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                                                sizeof(row_ctx->collectDataStatus));
        break;

        default: /** We shouldn't get here */
            rc = SNMP_ERR_GENERR;
            snmp_log(LOG_ERR, "unknown column in "
                     "collectDataTable_set_reserve1\n");
        }

        if (rc)
           netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc );
        rg->status = SNMP_MAX( rg->status, current->ri->status );
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

void collectDataTable_set_reserve2( netsnmp_request_group *rg )
{
    collectDataTable_context *undo_ctx = (collectDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;
    netsnmp_variable_list *var;
    int rc;

    rg->rg_void = rg->list->ri;

    /*
     * TODO: loop through columns, check for valid
     * values and any range constraints.
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch(current->tri->colnum) {

        case COLUMN_COLLECTDATAINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATATYPE:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAVARIABLE:
            /** OBJECTID = ASN_OBJECT_ID */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_oid( var ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASTARTDATE:
            /** DateAndTime = ASN_OCTET_STR */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAENDDATE:
            /** DateAndTime = ASN_OCTET_STR */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAMONSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAMONENDTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAMONFREQUENT:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATATUESTARTTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATATUEENDTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATATUEFREQUENT:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAWEDSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAWEDENDTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAWEDFREQUENT:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATATHUSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATATHUENDTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATATHUFREQUENT:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAFRISTARTTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAFRIENDTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATAFRIFREQUENT:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASATSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASATENDTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASATFREQUENT:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASUNSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASUNENDTIME:
            /** TICKS = ASN_TIMETICKS */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASUNFREQUENT:
            /** INTEGER = ASN_INTEGER */
                    /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
        break;

        case COLUMN_COLLECTDATASTATUS:
            /** RowStatus = ASN_INTEGER */
                rc = netsnmp_check_vb_rowstatus(current->ri->requestvb,
                                                undo_ctx ?
                                                undo_ctx->collectDataStatus:0);
                rg->rg_void = current->ri;
        break;

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }

        if (rc)
           netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc);
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void collectDataTable_set_action( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
    collectDataTable_context *row_ctx = (collectDataTable_context *)rg->existing_row;
    collectDataTable_context *undo_ctx = (collectDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    int            row_err = 0;

    /*
     * TODO: loop through columns, copy varbind values
     * to context structure for the row.
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        case COLUMN_COLLECTDATAINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->collectDataIndex = *var->val.integer;
        break;

        case COLUMN_COLLECTDATATYPE:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataType = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAVARIABLE:
            /** OBJECTID = ASN_OBJECT_ID */
            memcpy(row_ctx->collectDataVariable,var->val.objid,var->val_len);
            row_ctx->collectDataVariable_len = var->val_len;
        break;

        case COLUMN_COLLECTDATASTARTDATE:
            /** DateAndTime = ASN_OCTET_STR */
            memcpy(row_ctx->collectDataStartDate,var->val.string,var->val_len);
            row_ctx->collectDataStartDate_len = var->val_len;
        break;

        case COLUMN_COLLECTDATAENDDATE:
            /** DateAndTime = ASN_OCTET_STR */
            memcpy(row_ctx->collectDataEndDate,var->val.string,var->val_len);
            row_ctx->collectDataEndDate_len = var->val_len;
        break;

        case COLUMN_COLLECTDATAMONSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataMonStartTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAMONENDTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataMonEndTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAMONFREQUENT:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataMonFrequent = *var->val.integer;
        break;

        case COLUMN_COLLECTDATATUESTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataTueStartTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATATUEENDTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataTueEndTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATATUEFREQUENT:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataTueFrequent = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAWEDSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataWedStartTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAWEDENDTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataWedEndTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAWEDFREQUENT:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataWedFrequent = *var->val.integer;
        break;

        case COLUMN_COLLECTDATATHUSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataThuStartTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATATHUENDTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataThuEndTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATATHUFREQUENT:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataThuFrequent = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAFRISTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataFriStartTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAFRIENDTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataFriEndTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATAFRIFREQUENT:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataFriFrequent = *var->val.integer;
        break;

        case COLUMN_COLLECTDATASATSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataSatStartTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATASATENDTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataSatEndTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATASATFREQUENT:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataSatFrequent = *var->val.integer;
        break;

        case COLUMN_COLLECTDATASUNSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataSunStartTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATASUNENDTIME:
            /** TICKS = ASN_TIMETICKS */
            row_ctx->collectDataSunEndTime = *var->val.integer;
        break;

        case COLUMN_COLLECTDATASUNFREQUENT:
            /** INTEGER = ASN_INTEGER */
            row_ctx->collectDataSunFrequent = *var->val.integer;
        break;

        case COLUMN_COLLECTDATASTATUS:
            /** RowStatus = ASN_INTEGER */
            row_ctx->collectDataStatus = *var->val.integer;
        break;

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
#ifndef collectDataTable_CAN_MODIFY_ACTIVE_ROW
    if( undo_ctx && RS_IS_ACTIVE(undo_ctx->collectDataStatus) &&
        row_ctx && RS_IS_ACTIVE(row_ctx->collectDataStatus) ) {
            row_err = 1;
    }
#endif

    /*
     * check activation/deactivation
     */
    row_err = netsnmp_table_array_check_row_status(&cb, rg,
                                  row_ctx ? &row_ctx->collectDataStatus : NULL,
                                  undo_ctx ? &undo_ctx->collectDataStatus : NULL);
    if(row_err) {
        netsnmp_set_mode_request_error(MODE_SET_BEGIN,
                                       (netsnmp_request_info*)rg->rg_void,
                                       row_err);
        return;
    }

    /*
     * TODO: if you have dependencies on other tables, this would be
     * a good place to check those, too.
     */
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void collectDataTable_set_commit( netsnmp_request_group *rg )
{
    FILE *fp;
    netsnmp_variable_list *var;
    collectDataTable_context *mycontext = NULL;
    netsnmp_request_group_item *current;

    fp = fopen (RTC_CONTAINER_FILE,"wb");

    if (!fp)
    {
        DEBUGMSGTL(("nuri/rtc",
                    "Couldn't open RTC_CONTAINER_FILE error no: %d\n", errno));
        return;
    }

    mycontext = CONTAINER_FIRST(cb.container);
    if (mycontext)
    {
        /* Assign mycontext index->oids to idx */
        mycontext->idx = (unsigned long) *mycontext->index.oids;

        if (fwrite (mycontext,sizeof (collectDataTable_context), 1, fp) != 1)
        {
            DEBUGMSGTL (("nuri/rtc", "1 fwrite failed errno=%d\n", errno));
            return;
        }
    }

    while( mycontext ) {
        mycontext = CONTAINER_NEXT(cb.container,mycontext);
        if(mycontext)
        {
            /* Assign mycontext index->oids to idx */
            mycontext->idx = (unsigned long) *mycontext->index.oids;

            if (fwrite (mycontext, sizeof (collectDataTable_context),1,fp) != 1)
            {
                DEBUGMSGTL (("nuri/rtc",
                             "2 fwrite mycontext failed errno=%d\n", errno));
                return;
             }
         }
    }
    if (fp)
        fclose(fp);

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        case COLUMN_COLLECTDATAINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
        break;

        case COLUMN_COLLECTDATATYPE:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAVARIABLE:
            /** OBJECTID = ASN_OBJECT_ID */
        break;

        case COLUMN_COLLECTDATASTARTDATE:
            /** DateAndTime = ASN_OCTET_STR */
        break;

        case COLUMN_COLLECTDATAENDDATE:
            /** DateAndTime = ASN_OCTET_STR */
        break;

        case COLUMN_COLLECTDATAMONSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAMONENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAMONFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATATUESTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATUEENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATUEFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAWEDSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAWEDENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAWEDFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATATHUSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATHUENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATHUFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAFRISTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAFRIENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAFRIFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASATSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASATENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASATFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASUNSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASUNENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASUNFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASTATUS:
            /** RowStatus = ASN_INTEGER */
        break;

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */

    giContextChanged = 1;
}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void collectDataTable_set_free( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        case COLUMN_COLLECTDATAINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
        break;

        case COLUMN_COLLECTDATATYPE:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAVARIABLE:
            /** OBJECTID = ASN_OBJECT_ID */
        break;

        case COLUMN_COLLECTDATASTARTDATE:
            /** DateAndTime = ASN_OCTET_STR */
        break;

        case COLUMN_COLLECTDATAENDDATE:
            /** DateAndTime = ASN_OCTET_STR */
        break;

        case COLUMN_COLLECTDATAMONSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAMONENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAMONFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATATUESTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATUEENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATUEFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAWEDSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAWEDENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAWEDFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATATHUSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATHUENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATHUFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAFRISTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAFRIENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAFRIFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASATSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASATENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASATFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASUNSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASUNENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASUNFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASTATUS:
            /** RowStatus = ASN_INTEGER */
        break;

        default: /** We shouldn't get here */
            /** should have been logged in reserve1 */
        break;
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void collectDataTable_set_undo( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        case COLUMN_COLLECTDATAINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
        break;

        case COLUMN_COLLECTDATATYPE:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAVARIABLE:
            /** OBJECTID = ASN_OBJECT_ID */
        break;

        case COLUMN_COLLECTDATASTARTDATE:
            /** DateAndTime = ASN_OCTET_STR */
        break;

        case COLUMN_COLLECTDATAENDDATE:
            /** DateAndTime = ASN_OCTET_STR */
        break;

        case COLUMN_COLLECTDATAMONSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAMONENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAMONFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATATUESTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATUEENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATUEFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAWEDSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAWEDENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAWEDFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATATHUSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATHUENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATATHUFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATAFRISTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAFRIENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATAFRIFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASATSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASATENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASATFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASUNSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASUNENDTIME:
            /** TICKS = ASN_TIMETICKS */
        break;

        case COLUMN_COLLECTDATASUNFREQUENT:
            /** INTEGER = ASN_INTEGER */
        break;

        case COLUMN_COLLECTDATASTATUS:
            /** RowStatus = ASN_INTEGER */
        break;

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

#endif /** collectDataTable_SET_HANDLING */


/************************************************************
 *
 * Initialize the collectDataTable table by defining its contents and how it's structured
 */
void
initialize_table_collectDataTable(void)
{
    netsnmp_table_registration_info *table_info;

    if(my_handler) {
        snmp_log(LOG_ERR, "initialize_table_collectDataTable_handler called again\n");
        return;
    }

    memset(&cb, 0x00, sizeof(cb));

    /** create the table structure itself */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    /* if your table is read only, it's easiest to change the
       HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("collectDataTable",
                                             netsnmp_table_array_helper_handler,
                                             collectDataTable_oid,
                                             collectDataTable_oid_len,
                                             HANDLER_CAN_RWRITE);
            
    if (!my_handler || !table_info) {
        snmp_log(LOG_ERR, "malloc failed in "
                 "initialize_table_collectDataTable_handler\n");
        return; /** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    /*
     * TODO: add any external indexes here.
     */

    /*
     * internal indexes
     */
        /** index: collectDataIndex */
        netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);

    table_info->min_column = collectDataTable_COL_MIN;
    table_info->max_column = collectDataTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
    cb.get_value = collectDataTable_get_value;
    cb.container = netsnmp_container_find("collectDataTable_primary:"
                                          "collectDataTable:"
                                          "table_container");
#ifdef collectDataTable_IDX2
    netsnmp_container_add_index(cb.container,
                                netsnmp_container_find("collectDataTable_secondary:"
                                                       "collectDataTable:"
                                                       "table_container"));
    cb.container->next->compare = collectDataTable_cmp;
#endif
#ifdef collectDataTable_SET_HANDLING
    cb.can_set = 1;
#ifdef collectDataTable_ROW_CREATION
    cb.create_row = (UserRowMethod*)collectDataTable_create_row;
#endif
    cb.duplicate_row = (UserRowMethod*)collectDataTable_duplicate_row;
    cb.delete_row = (UserRowMethod*)collectDataTable_delete_row;
    cb.row_copy = (Netsnmp_User_Row_Operation *)collectDataTable_row_copy;

    cb.can_activate = (Netsnmp_User_Row_Action *)collectDataTable_can_activate;
    cb.can_deactivate = (Netsnmp_User_Row_Action *)collectDataTable_can_deactivate;
    cb.can_delete = (Netsnmp_User_Row_Action *)collectDataTable_can_delete;

    cb.set_reserve1 = collectDataTable_set_reserve1;
    cb.set_reserve2 = collectDataTable_set_reserve2;
    cb.set_action = collectDataTable_set_action;
    cb.set_commit = collectDataTable_set_commit;
    cb.set_free = collectDataTable_set_free;
    cb.set_undo = collectDataTable_set_undo;
#endif
    DEBUGMSGTL(("nuri/rtc",
                "Registering table collectDataTable "
                "as a table array\n"));
    netsnmp_table_container_register(my_handler, table_info, &cb,
                                     cb.container, 1);
}

/************************************************************
 * collectDataTable_get_value
 */
int collectDataTable_get_value(
            netsnmp_request_info *request,
            netsnmp_index *item,
            netsnmp_table_request_info *table_info )
{
    netsnmp_variable_list *var = request->requestvb;
    collectDataTable_context *context = (collectDataTable_context *)item;

    switch(table_info->colnum) {

        case COLUMN_COLLECTDATAINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
            snmp_set_var_typed_value(var, ASN_UNSIGNED,
                         (char*)&context->collectDataIndex,
                         sizeof(context->collectDataIndex) );
        break;
    
        case COLUMN_COLLECTDATATYPE:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataType,
                         sizeof(context->collectDataType) );
        break;
    
        case COLUMN_COLLECTDATAVARIABLE:
            /** OBJECTID = ASN_OBJECT_ID */
            snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                         (char*)&context->collectDataVariable,
                         context->collectDataVariable_len );
        break;
    
        case COLUMN_COLLECTDATASTARTDATE:
            /** DateAndTime = ASN_OCTET_STR */
            snmp_set_var_typed_value(var, ASN_OCTET_STR,
                         (char*)&context->collectDataStartDate,
                         context->collectDataStartDate_len );
        break;
    
        case COLUMN_COLLECTDATAENDDATE:
            /** DateAndTime = ASN_OCTET_STR */
            snmp_set_var_typed_value(var, ASN_OCTET_STR,
                         (char*)&context->collectDataEndDate,
                         context->collectDataEndDate_len );
        break;
    
        case COLUMN_COLLECTDATAMONSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataMonStartTime,
                         sizeof(context->collectDataMonStartTime) );
        break;
    
        case COLUMN_COLLECTDATAMONENDTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataMonEndTime,
                         sizeof(context->collectDataMonEndTime) );
        break;
    
        case COLUMN_COLLECTDATAMONFREQUENT:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataMonFrequent,
                         sizeof(context->collectDataMonFrequent) );
        break;
    
        case COLUMN_COLLECTDATATUESTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataTueStartTime,
                         sizeof(context->collectDataTueStartTime) );
        break;
    
        case COLUMN_COLLECTDATATUEENDTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataTueEndTime,
                         sizeof(context->collectDataTueEndTime) );
        break;
    
        case COLUMN_COLLECTDATATUEFREQUENT:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataTueFrequent,
                         sizeof(context->collectDataTueFrequent) );
        break;
    
        case COLUMN_COLLECTDATAWEDSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataWedStartTime,
                         sizeof(context->collectDataWedStartTime) );
        break;
    
        case COLUMN_COLLECTDATAWEDENDTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataWedEndTime,
                         sizeof(context->collectDataWedEndTime) );
        break;
    
        case COLUMN_COLLECTDATAWEDFREQUENT:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataWedFrequent,
                         sizeof(context->collectDataWedFrequent) );
        break;
    
        case COLUMN_COLLECTDATATHUSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataThuStartTime,
                         sizeof(context->collectDataThuStartTime) );
        break;
    
        case COLUMN_COLLECTDATATHUENDTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataThuEndTime,
                         sizeof(context->collectDataThuEndTime) );
        break;
    
        case COLUMN_COLLECTDATATHUFREQUENT:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataThuFrequent,
                         sizeof(context->collectDataThuFrequent) );
        break;
    
        case COLUMN_COLLECTDATAFRISTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataFriStartTime,
                         sizeof(context->collectDataFriStartTime) );
        break;
    
        case COLUMN_COLLECTDATAFRIENDTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataFriEndTime,
                         sizeof(context->collectDataFriEndTime) );
        break;
    
        case COLUMN_COLLECTDATAFRIFREQUENT:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataFriFrequent,
                         sizeof(context->collectDataFriFrequent) );
        break;
    
        case COLUMN_COLLECTDATASATSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataSatStartTime,
                         sizeof(context->collectDataSatStartTime) );
        break;
    
        case COLUMN_COLLECTDATASATENDTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataSatEndTime,
                         sizeof(context->collectDataSatEndTime) );
        break;
    
        case COLUMN_COLLECTDATASATFREQUENT:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataSatFrequent,
                         sizeof(context->collectDataSatFrequent) );
        break;
    
        case COLUMN_COLLECTDATASUNSTARTTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataSunStartTime,
                         sizeof(context->collectDataSunStartTime) );
        break;
    
        case COLUMN_COLLECTDATASUNENDTIME:
            /** TICKS = ASN_TIMETICKS */
            snmp_set_var_typed_value(var, ASN_TIMETICKS,
                         (char*)&context->collectDataSunEndTime,
                         sizeof(context->collectDataSunEndTime) );
        break;
    
        case COLUMN_COLLECTDATASUNFREQUENT:
            /** INTEGER = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataSunFrequent,
                         sizeof(context->collectDataSunFrequent) );
        break;
    
        case COLUMN_COLLECTDATASTATUS:
            /** RowStatus = ASN_INTEGER */
            snmp_set_var_typed_value(var, ASN_INTEGER,
                         (char*)&context->collectDataStatus,
                         sizeof(context->collectDataStatus) );
        break;
    
    default: /** We shouldn't get here */
        snmp_log(LOG_ERR, "unknown column in "
                 "collectDataTable_get_value\n");
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

/************************************************************
 * collectDataTable_get_by_idx
 */
const collectDataTable_context *
collectDataTable_get_by_idx(netsnmp_index * hdr)
{
    return (const collectDataTable_context *)
        CONTAINER_FIND(cb.container, hdr );
}

/* <Start: WIP_NURI_ALL > */

/*****************************************************************************
 * name             :   RTC_callback
 * description      :   This is a main function for Real Time Collection module
 * input parameters :
 * output parameters:
 * return type      :   void
 * global variables :
 * calls            :   init_collectDataTable, collectDataTable_set_commit
 *****************************************************************************/

void
RTC_callback (unsigned int reg, void *clientarg)
{
    int iCnt=0;
    int iLength = 0;
    RTC_List *stList = NULL;
    RTC_List *stHead = NULL;
    RTC_List *stNewHead = NULL;

    DEBUGMSGTL(("nuri/rtc", "gcInfoLogFileSystemData=%s$\n",
                gcInfoLogFileSystemData));

    DEBUGMSGTL(("nuri/rtc", "STARTING RTC_callback.....\n"));

    /* Unregister pending alarms registerd by RTC, if any */

    if (guiRTCReg1 != 0)
    {
        DEBUGMSGTL(("nuri/rtc", "Unregistering guiRTCReg1.....\n"));
        snmp_alarm_unregister(guiRTCReg1);
        guiRTCReg1 = 0;
    }
    if (guiRTCReg2 != 0)
    {
        DEBUGMSGTL(("nuri/rtc", "Unregistering guiRTCReg2.....\n"));
        snmp_alarm_unregister(guiRTCReg2);
        guiRTCReg2 = 0;
    }
    if (guiRTCReg3 != 0)
    {
        DEBUGMSGTL(("nuri/rtc", "Unregistering guiRTCReg3.....\n"));
        snmp_alarm_unregister(guiRTCReg3);
        guiRTCReg3 = 0;
    }

    /* Deallocate linked list of intervals before creating a new one */
    if (pstHeadList)
    {
        iCnt=0;
        while (pstHeadList->next != NULL)
        {
            stNewHead = pstHeadList->next;
            free (pstHeadList);
            pstHeadList = stNewHead;
            iCnt++;
        }
        free (pstHeadList);
        iCnt++;
        DEBUGMSGTL(("nuri/rtc",
                    "After freeing <%d> nodes from linked list\n", iCnt));
    }

    /* Allocate a new linked list */
    stList = (RTC_List *) calloc (1, sizeof (RTC_List));
    stHead = stList;

    /* Form Linked List of intervals and return the length of linked list */
    Form_Linked_List (stList, &iLength);

    DEBUGMSGTL(("nuri/rtc", "Length of new linked list: <%d>\n", iLength));

    /* If Linked List length is zero, wait for RTC_IDLE_TIME (1 minute) 
       and call RTC_callback() to try to form the linked list once again */
    if (iLength == 0)
    {
      DEBUGMSGTL(("nuri/rtc",
                  "No matching row present in collectDataTable!!\n"));
      guiRTCReg1 = snmp_alarm_register (RTC_IDLE_TIME, (int) NULL, RTC_callback,
                                                                        NULL);
      return;
    }

    DEBUGMSGTL(("nuri/rtc", "initdelay=%ld index=%lu\n", stList->interval,
                stList->index));
 
    stList = stHead;

   /* Create a dummy node with interval=MAX_VALUE, so that the starting address
      of linked list will not change after sorting */

    stNewHead = (RTC_List *) calloc (1, sizeof (RTC_List));
    stNewHead->interval = 0;
    stNewHead->index    = 0;
    stNewHead->next     = stList;
    stList              = stNewHead;

    /* Sort the Linked List using bubble sort algorithm */
    Sort_Linked_List (stList);

    /* Free the created dummy node for sorting */

    stNewHead = stList->next;
    free (stList);
    stList = stNewHead;

    pstHeadList = stList;

    DEBUGMSGTL(("nuri/rtc",
      "initially waiting for <%ld> seconds. stList=<%lu> ", stList->interval, stList));

    for (iCnt=0; stList->next != NULL; iCnt++)
    {
        DEBUGMSGTL(("nuri/rtc", "stList[%d]: interval=<%ld> index=%lu next=%lu\n", iCnt, stList->interval, stList->index, stList->next));
        stList = stList->next;
    }

        DEBUGMSGTL(("nuri/rtc", "@@@@ Last node: stList[%d]: interval=<%ld> index=%lu next=%lu\n", iCnt, stList->interval, stList->index, stList->next));

    stList = pstHeadList;

    /* Wait for linked list first node 'interval' seconds to collect 
       and store the variables */
    guiRTCReg2 = snmp_alarm_register (stList->interval, (int) NULL,
                                RTC_Collect_Store_Variables, (void *) stList);
    DEBUGMSGTL (("nuri/rtc", " guiRTCReg2=%d\n", guiRTCReg2));
    return;
}

/*****************************************************************************
 * name             :   RTC_Load_Container_From_File
 * description      :   Loads the collectDataTable from file to memory context
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   init_collectDataTable
 *****************************************************************************/

void
RTC_Load_Container_From_File ()
{
    FILE *fp=NULL;
    int iCnt=0;
    collectDataTable_context stReadCtx;
    collectDataTable_context *pstContext = NULL;

    /* Open the container file and load all the collectDataTable rows from
       this file during start up. */

    fp = fopen (RTC_CONTAINER_FILE, "rb");

    if (fp==NULL)
    {
      DEBUGMSGTL(("nuri/rtc",
                  "RTC_CONTAINER_FILE file open failed errno=%d\n", errno));
    }
    else
    {
	/* Loading the collectDataTable rows from file to sub-agent memory */
        while (fread (&stReadCtx, sizeof (collectDataTable_context),1,fp) == 1) 
        {
            pstContext = SNMP_MALLOC_TYPEDEF (collectDataTable_context);
            memcpy (pstContext, &stReadCtx, sizeof (collectDataTable_context));

            netsnmp_assert(pstContext->index.oids == NULL);
            if(snmp_clone_mem( (void*)&pstContext->index.oids, &stReadCtx.idx,
                             stReadCtx.index.len * sizeof(oid) )) {
            if (fp)
                fclose (fp);
            return;
            }

            pstContext->index.len = stReadCtx.index.len;

            iCnt = CONTAINER_INSERT (cb.container, pstContext);
            if (iCnt)
            {
                DEBUGMSGTL(("nuri/rtc", "ERROR IN CONTAINER_INSERT FUNCION\n"));
            }
       }

        DEBUGMSGTL(("nuri/rtc",
                    "CONTAINER SIZE=%u\n", CONTAINER_SIZE (cb.container)));
        /* Close the file */
        if (fp)
            fclose(fp);
    }

    return;
}

/*****************************************************************************
 * name             :   RTC_Find_Current_Day
 * description      :   To find present day in numeric format
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_Add_Intervals_To_List
 *****************************************************************************/

int
RTC_Find_Current_Day()
{
    struct tm stTm = { 0 };
    struct timeval  stTv = { 0 };

    /* get the present time in seconds */
    gettimeofday(&stTv, (struct timezone *) 0);

    /* convert seconds into tm structure and return the week day */
    memcpy(&stTm, localtime((time_t *) & stTv.tv_sec), sizeof(stTm));

    return stTm.tm_wday;
}

/*****************************************************************************
 * name             :   RTC_Get_Time_Frequency
 * description      :   To store <day>StartTime, <day>EndTime, <day>Frequent
 *                      based on the day.
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_Add_Intervals_To_List
 *****************************************************************************/

void
RTC_Get_Time_Frequency (int iToday, collectDataTable_context *pstCtx,
                    unsigned long *ulSTime, unsigned long *ulETime, int *iFreq)
{
    if (pstCtx == NULL || ulSTime == NULL || ulETime == NULL || iFreq == NULL)
    {
        DEBUGMSGTL(("nuri/rtc", "Invalid Argument!!"));
        return;
    }

    /* Fill up start time, end time and frequency based on iToday */
    switch (iToday)
    {
        case 0:
	    /* collectDataSunStartTime and collectDataSunEndTime are
	       in centi seconds. Convert it to seconds */

            *ulSTime = CONVERT_TO_SEC (pstCtx->collectDataSunStartTime);
            *ulETime = CONVERT_TO_SEC (pstCtx->collectDataSunEndTime);
            *iFreq  = pstCtx->collectDataSunFrequent;
            break;
        case 1:
            *ulSTime = CONVERT_TO_SEC (pstCtx->collectDataMonStartTime);
            *ulETime = CONVERT_TO_SEC (pstCtx->collectDataMonEndTime);
            *iFreq  = pstCtx->collectDataMonFrequent;
            break;
        case 2:
            *ulSTime = CONVERT_TO_SEC (pstCtx->collectDataTueStartTime);
            *ulETime = CONVERT_TO_SEC (pstCtx->collectDataTueEndTime);
            *iFreq  = pstCtx->collectDataTueFrequent;
            break;
        case 3:
            *ulSTime = CONVERT_TO_SEC (pstCtx->collectDataWedStartTime);
            *ulETime = CONVERT_TO_SEC (pstCtx->collectDataWedEndTime);
            *iFreq  = pstCtx->collectDataWedFrequent;
            break;
        case 4:
            *ulSTime = CONVERT_TO_SEC (pstCtx->collectDataThuStartTime);
            *ulETime = CONVERT_TO_SEC (pstCtx->collectDataThuEndTime);
            *iFreq  = pstCtx->collectDataThuFrequent;
            break;
        case 5:
            *ulSTime = CONVERT_TO_SEC (pstCtx->collectDataFriStartTime);
            *ulETime = CONVERT_TO_SEC (pstCtx->collectDataFriEndTime);
            *iFreq  = pstCtx->collectDataFriFrequent;
            break;
        case 6:
            *ulSTime = CONVERT_TO_SEC (pstCtx->collectDataSatStartTime);
            *ulETime = CONVERT_TO_SEC (pstCtx->collectDataSatEndTime);
            *iFreq  = pstCtx->collectDataSatFrequent;
            break;
        default:
            DEBUGMSGTL(("nuri/rtc", "Invalid Day=%d\n", iToday));
            break;
    }
    return;
}

/*****************************************************************************
 * name             :   Form_Linked_List
 * description      :   To form linked list containing interval and tableIndex.
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_callback
 *****************************************************************************/

int
Form_Linked_List (RTC_List *pstList, int *iLength)
{
    int iToday = 0;
    int iFreq  = 0;
    int iListLen = 0;
    int iInterval = 0;

    unsigned long ulCTime = 0;
    unsigned long ulSTime = 0;
    unsigned long ulETime = 0;

    collectDataTable_context *pstCtx = NULL;

    /* Get present day in numeric format Eg: sun=0, mon=1 etc. */
    iToday = RTC_Find_Current_Day();

    /* Calculate the interval based on the RTC_MAX_LIST_NODES */
    RTC_Calc_Num_Nodes_Interval (&iInterval);

    DEBUGMSGTL(("nuri/rtc", "#####iInterval=%d#####\n", iInterval));

    /* Read the first row of collectDataTable and assign it to a pointer */
    pstCtx = CONTAINER_NEXT (cb.container, NULL);

    while (pstCtx)
    {
	/* Is present time within collectDatastartDate and EndDate? */
        if (RTC_Within_Period (pstCtx) == 0)
        {
	    /* Get the start time, end time and frequency based on iToday */
            RTC_Get_Time_Frequency (iToday, pstCtx, &ulSTime, &ulETime, &iFreq);

	    /* Get current time in seconds from midnight 00:00 */
            ulCTime = RTC_Get_Current_Time ();

            /* Is current time within start time and end time? */
            if (ulCTime > ulSTime && ulCTime < ulETime)
            {
                int iCnt = 0;
		/* Add the intervals for the row in the linked list */
                RTC_Add_Intervals_To_List (pstCtx, pstList, &iInterval,
                                           &iListLen);

                /* Move to the end of the linked list */
                while (pstList->next != NULL)
                {
                    
        DEBUGMSGTL(("nuri/rtc", "****pstList[%d]: interval=<%ld> index=%lu next=%lu\n", iCnt, pstList->interval, pstList->index, pstList->next));
                    iCnt++;
                    pstList = pstList->next;
                }
        DEBUGMSGTL(("nuri/rtc", "****Printing last node pstList[%d]: interval=<%ld> index=%lu next=%lu\n", iCnt, pstList->interval, pstList->index, pstList->next));
                DEBUGMSGTL(("nuri/rtc", "###########LIST OVER#######\n"));
           }
        }
        pstCtx = CONTAINER_NEXT (cb.container, pstCtx);
    }
    *iLength = iListLen;
    return 0;
}

/*****************************************************************************
 * name             :   RTC_Convert_Date_To_Long
 * description      :   Converts DateAndTime format to unsigned long format
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_Within_Period
 *****************************************************************************/

int
RTC_Convert_Date_To_Long (collectDataTable_context *pstCtx,
                          unsigned long *pulDate, int iColumn)
{
    struct tm stTm = { 0 };
    char szStr[80] = { 0 };

    int iYear=0;

    /* iColumn = 4, if calculation is for collectDataStartDate
       iColumn = 5, if calculation is for collectDataEndDate */

    if (iColumn == 4)
        strcpy (szStr, pstCtx->collectDataStartDate);
    else if (iColumn == 5)
        strcpy (szStr, pstCtx->collectDataEndDate);
    else
        return 1;

    /* Convert DateAndTime format into unsigned long format */

    iYear = szStr[0];
    iYear = (iYear << 8) | (szStr[1] & 0xff);
    stTm.tm_year = iYear - 1900;

    stTm.tm_mon  = (int) (szStr[2] & 0xff) - 1;
    stTm.tm_mday = (int) (szStr[3] & 0xff);
    stTm.tm_hour = (int) (szStr[4] & 0xff);
    stTm.tm_min =  (int) (szStr[5] & 0xff);
    stTm.tm_sec =  (int) (szStr[6] & 0xff);

    DEBUGMSGTL(("nuri/rtc", " ***** iYear=%d *****\n", iYear));
    DEBUGMSGTL(("nuri/rtc", "**********month=%d day=%d "
                "hour=%d min=%d sec=%d*****\n", stTm.tm_mon+1, stTm.tm_mday,
                stTm.tm_hour, stTm.tm_min, stTm.tm_sec));
    
#ifdef DUMMY
    if (daylight)
        stTm.tm_isdst = 1;

    stTm.tm_sec -= timezone;
#endif /* DUMMY */

    /* Assuming that mktime will take care of timezone issue */

    *pulDate = mktime(&stTm);

    DEBUGMSGTL(("nuri/rtc", "long format date=%lu\n", pulDate));
    return 0;
}

/*****************************************************************************
 * name             :   RTC_Calc_Num_Nodes_Interval
 * description      :   Calculates duration for which linked list has to be 
 *                      formed based on RTC_MAX_LIST_NODES.
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   Form_Linked_List
 *****************************************************************************/

int
RTC_Calc_Num_Nodes_Interval (int *intvl)
{
    int iCnt = 0;
    int iToday = 0;
    int iFreq  = 0;
    int iInterval = 0;
    int iInitDelay  = 0;

    unsigned long ulCTime = 0;
    unsigned long ulSTime = 0;
    unsigned long ulETime = 0;
    unsigned long ulASTime  = 0;

    collectDataTable_context *pstCtx = NULL;

    /* Get today in numeric format */
    iToday = RTC_Find_Current_Day();

    /* Read the first row of collectDataTable */
    pstCtx = CONTAINER_NEXT (cb.container, NULL);

    /* Start calculating the interval from INIT_INTERVAL */
    iInterval = INIT_INTERVAL;

    while (pstCtx)
    {
	/* Is present time within collectDatastartDate and EndDate? */
        if (RTC_Within_Period (pstCtx) == 0)
        {
	    /* Get the start time, end time and frequency based on iToday */
            RTC_Get_Time_Frequency (iToday, pstCtx, &ulSTime, &ulETime, &iFreq);

	    /* Get current time in seconds from midnight 00:00 */
            ulCTime = RTC_Get_Current_Time ();

    DEBUGMSGTL(("nuri/rtc", "####RTC_Get_Current_Time returns ulCTime=%lu\n", ulCTime));

            /* Calculate initial delay which will be the difference between
	       scheduled execution time and present time. */
            iInitDelay = iFreq - ((ulCTime - ulSTime)%iFreq);

            if (iInitDelay == iFreq)
            {
                /* Minimum initDelay can be 1 second */
                iInitDelay = 1;
            }

            DEBUGMSGTL (("nuri/rtc", "#iInitDelay=%d\n", iInitDelay));

            
            /* Is current time within start time and end time? */
            if (ulCTime > ulSTime && ulCTime < ulETime)
            {
                DEBUGMSGTL (("nuri/rtc", "if loop: ulCTime=%lu ulSTime=%lu "
                    "ulETime=%lu iCnt=%d\n", ulCTime, ulSTime, ulETime, iCnt));
                ulASTime = iInitDelay + ulCTime;

                if (ulASTime > ulETime)
                {
                    /* Actual time should not exceed End Time */
                    pstCtx = CONTAINER_NEXT (cb.container, pstCtx);

                    continue;
                }
                iCnt += 1;

		/* Calculate the possible number of linked list nodes for
		   current row for the interval specified */
                if (ulETime > iInterval+ulASTime)
                {
                    iCnt = iCnt + iInterval/iFreq;
                }
                else
                {
                    iCnt = iCnt + (int) ((ulETime - ulASTime)/iFreq);
                }

                DEBUGMSGTL (("nuri/rtc", "#### iCnt=%d\n", iCnt));

                /* If total number of linked list nodes exceed the limit */
                if (iCnt > RTC_MAX_LIST_NODES)
                {
                    if (iInterval != 1)
                    {
                        iCnt = 0;
                        iInterval = iInterval/2;
                        DEBUGMSGTL(("nuri/rtc",
                        "Count Exceeds Limit.  New iInterval=%d\n", iInterval));
                        pstCtx = CONTAINER_NEXT (cb.container, NULL);
                        continue;
                    }
                    else
                    {
			/* interval can't be less than 1 second. Now the
			   limitation on RTC_MAX_LIST_NODES is ignored */
                        DEBUGMSGTL(("nuri/rtc",
                                    "RTC_MAX_LIST_NODES exceeded\n"));
                    }
                }
            }
        }
        pstCtx = CONTAINER_NEXT (cb.container, pstCtx);
    }

    /* Assign the calculated interval */
    *intvl = iInterval;
    return 0;
}

/*****************************************************************************
 * name             :   RTC_Add_Intervals_To_List
 * description      :   Form Complete Linked by adding intervals for all rows
 *                      for the calculated interval based on RTC_MAX_LIST_NODES
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   Form_Linked_List
 *****************************************************************************/

int
RTC_Add_Intervals_To_List (collectDataTable_context *pstCtx, RTC_List *pstList,
                           int *piInterval, int *piLength)
{
    int ii = 0;
    int iCnt = 0;
    int iToday = 0;
    int iFreq  = 0;
    int iInitDelay  = 0;
    int iDelay = 0;

    unsigned long ulCTime = 0;
    unsigned long ulSTime = 0;
    unsigned long ulETime = 0;
    unsigned long ulASTime  = 0;

    iToday = RTC_Find_Current_Day();

    RTC_Get_Time_Frequency (iToday, pstCtx, &ulSTime, &ulETime, &iFreq);
    ulCTime = RTC_Get_Current_Time ();

    /* If frequency is set to 0, change it to 1 second
       frequency can not be less than 1 second */
    if (iFreq == 0) iFreq = 1;

    /* Find out the initial delay from the scheduled time 
       for collecting variables */
    iInitDelay = iFreq - ((ulCTime - ulSTime)%iFreq);

    if (iInitDelay == iFreq)
    {
        /* Minimum interval is 1 second */
        iInitDelay = 1;
    }

    /* Actual starting time is calculated */
    ulASTime = iInitDelay + ulCTime;

    if (ulETime > *piInterval+ulASTime)
    {
        iCnt = *piInterval/iFreq;
    }
    else
    {
        iCnt = (ulETime - ulASTime)/iFreq;
    }

    pstList->interval = iInitDelay;
    pstList->index    = pstCtx->collectDataIndex;

    *piLength += 1;

    /* First list is already added, so, decrementing iCnt by one */
    if (iCnt > 0) iCnt -= 1;

    iDelay = iFreq + iInitDelay;

    /* Add intervals to linked list for the current row */
    for (ii=0; ii < iCnt; ii++)
    {
        pstList->next = (RTC_List *) calloc (1, sizeof (RTC_List));
        pstList = pstList->next;

        *piLength += 1;
        pstList->interval = iDelay;
        pstList->index    = pstCtx->collectDataIndex;
        iDelay += iFreq;
    }

    /* Last node next should be NULL */
    pstList->next = (RTC_List *) calloc (1, sizeof (RTC_List));
    pstList = pstList->next;

    pstList->interval = 2147483647L;
    pstList->index    = 65537;
    pstList->next = NULL;
     
    return 0;
}

/*****************************************************************************
 * name             :   RTC_Within_Period
 * description      :   Check if present time is within the SDate and EndDate
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   Form_Linked_List, RTC_Calc_Num_Nodes_Interval
 *****************************************************************************/

int
RTC_Within_Period (collectDataTable_context *pstCtx)
{
    int iErr   = 0;
    time_t now = 0;
    long ulSDate = 0;
    long ulEDate = 0;
    struct timeval  stTv;

    /* Convert DateAndTime format to unsigned long format */
    iErr = RTC_Convert_Date_To_Long (pstCtx, &ulSDate, 4);
    if (iErr)
    {
        DEBUGMSGTL(("nuri/rtc", "Invalid Start Date Format %s\n",
                     pstCtx->collectDataStartDate));
        return 1;
    } 

    iErr = RTC_Convert_Date_To_Long (pstCtx, &ulEDate, 5);
    if (iErr)
    {
        DEBUGMSGTL(("nuri/rtc", "Invalid End Date Format %s\n",
                     pstCtx->collectDataEndDate));
        return 1;
    }

    if (ulEDate < ulSDate)
    {
        DEBUGMSGTL(("nuri/rtc", "CollectDataEndDate cannot be less"
                    " than collectDataStartDate\n"));
        return 1;
    }

    gettimeofday(&stTv, (struct timezone *) 0);
    now = stTv.tv_sec;

    if (now >= ulSDate && now <= ulEDate)
    {
        return 0;
    }
    return 1;
}

/*****************************************************************************
 * name             :   RTC_Get_Current_Time
 * description      :   Return seconds from 00:00 hours for current day
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_Calc_Num_Nodes_Interval, RTC_Add_Intervals_To_List
 *****************************************************************************/

unsigned long
RTC_Get_Current_Time ()
{
    unsigned long ulValue=0;
    struct tm stTm;
    struct timeval stTv;

    gettimeofday(&stTv, (struct timezone *) 0);
    memcpy(&stTm, localtime((time_t *) & stTv.tv_sec), sizeof(stTm));
  
    ulValue = stTm.tm_hour * 60 * 60 + stTm.tm_min * 60 + stTm.tm_sec;

    DEBUGMSGTL (("nuri/rtc", "**** Current Time=%lu", ulValue));
    return ulValue;
}

/*****************************************************************************
 * name             :   Sort_Linked_List
 * description      :   Sorts the linked list based on interval as key
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_callback
 *****************************************************************************/

int
Sort_Linked_List (RTC_List *pstStart)
{
    RTC_List *pstP = NULL;
    RTC_List *pstQ = NULL;
    RTC_List *pstR = NULL;
    RTC_List *pstS = NULL;
    RTC_List *pstTemp = NULL;

    /* pstR precedes pstP and pstS points to the node up to which comparisons
       are to be made */ 

    /* temporary add a node and add interval zero */

    while ( pstS != pstStart -> next ) 
    { 
        pstR = pstP = pstStart; 
        pstQ = pstP -> next ;

        while ( pstP != pstS ) 
        {  
            if ( pstP -> interval > pstQ -> interval ) 
            { 
                if ( pstP == pstStart ) 
                { 
                    pstTemp = pstQ -> next ; 
                    pstQ -> next = pstP ; 
                    pstP -> next = pstTemp ;
                    pstStart = pstQ ; 
                    pstR = pstQ ; 
                } 
                else 
                { 
                    pstTemp = pstQ -> next ; 
                    pstQ -> next = pstP ; 
                    pstP -> next = pstTemp ;
                    pstR -> next = pstQ ; 
                    pstR = pstQ ; 
                } 
            } 
            else 
            { 
                pstR = pstP ; 
                pstP = pstP -> next ; 
            } 
            pstQ = pstP -> next ; 
            if ( pstQ == pstS ) 
                pstS = pstP ; 
        } 
    }

    return 0;
}

/*****************************************************************************
 * name             :   RTC_Collect_Store_Variables
 * description      :   Wait till next interval and call function to collect
 *                      and store the variable
 * input parameters :
 * output parameters:
 * return type      :   void
 * global variables :
 * calls            :   RTC_callback, RTC_Collect_Store_Variables
 *****************************************************************************/

void
RTC_Collect_Store_Variables (unsigned int uiReg, void *clientarg)
{
    int seconds = 0;
    RTC_List *pstList = NULL;
    RTC_List *newhead = NULL;
    
    pstList = (RTC_List *) clientarg;
   
    DEBUGMSGTL(("nuri/rtc", "Collecting Variable Value for"
              " interval=%ld index=%lu\n", pstList->interval, pstList->index));

    DEBUGMSGTL (("nuri/rtc", "uiReg=%u guiRTCReg2=%u guiRTCReg3=%u\n",
                                               uiReg, guiRTCReg2, guiRTCReg3));

    /* Initialize the alarm regid values */
    if (uiReg == guiRTCReg2)
        guiRTCReg2 = 0;
    else if (uiReg == guiRTCReg3)
        guiRTCReg3 = 0;

    while (pstList->next)
    {
        if (pstList->interval == pstList->next->interval)
        {
	    /* Retrieve the variable and store it in a file */
            RTC_Retrieve_Log_Variable (pstList->index);

            /* Remove the current linked list node */
            newhead = pstList->next;
            free (pstList);
            pstList = newhead;

            pstHeadList = pstList;
        }
        else
        {
            RTC_Retrieve_Log_Variable (pstList->index);
            break;
        }
    }

    DEBUGMSGTL (("nuri/rtc", "uiReg=%d pstList=<%lu> pstList->interval=%ld "
                 "index=%ld pstList->next=%lu\n", uiReg, pstList,
                 pstList->interval, pstList->index, pstList->next));

    if (pstList->next && pstList->next->next != NULL)
    {
        seconds = pstList->next->interval - pstList->interval;

        /* Remove the current linked list node */
        newhead = pstList->next;
        free (pstList);
        pstList = newhead;

        pstHeadList = pstList;

        DEBUGMSGTL(("nuri/rtc", "Waiting for %d seconds\n", seconds));

        /* Check if any row is modified or not */
        if (giContextChanged == 0)
        {
            /* Wait for 'seconds' seconds to retrieve & store the next variable */
            guiRTCReg3 = snmp_alarm_register (seconds, (int) NULL,
                              RTC_Collect_Store_Variables, (void *) pstList);
        }
        else
        {
            giContextChanged = 0;

            /* Form linked list once again */
            RTC_callback (1, (void *) NULL);
        }
    }
    else
    {
        /* Remove the current linked list node */
        newhead = pstList->next;
        free (pstList);
        pstList = newhead;

        pstHeadList = pstList;

        free (pstHeadList);
        pstHeadList = NULL;

        RTC_callback(1, (void *) NULL);
    }
    return;
}

/*****************************************************************************
 * name             :   RTC_Retrieve_Log_Variable
 * description      :   Retrieves the variable value and store it in a file
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_Collect_Store_Variables
 *****************************************************************************/

int
RTC_Retrieve_Log_Variable (unsigned long ulIndex)
{
    int iErr=0;
    int iCnt=0;
    int iCollVarLen = 0;
    unsigned long ulVal = 0;
    netsnmp_index stIdx = { 0 };
    oid array[] = { ulIndex };

    collectDataTable_context stCtx;
    collectDataTable_context *pstFound;

    char szValStr[80] = { 0 };
    char szTimeStr[80] = { 0 };
    char szVarStr[MAX_OID_LEN] = { 0 };

    stIdx.len = 1;
    stIdx.oids = array;

    stCtx.index = stIdx;

    /* Find out the collectDataTable row using index */
    pstFound = CONTAINER_FIND (cb.container, &stCtx);

    if (pstFound)
    {
        iCollVarLen = pstFound->collectDataVariable_len / sizeof (oid);

        for (iCnt=0; iCnt < iCollVarLen; iCnt++)
        {
           sprintf (szValStr, ".%lu", pstFound->collectDataVariable[iCnt]);
           strcat  (szVarStr, szValStr);
        }
    
	/* Retrieve the value of the variable */
        iErr = RTC_Fetch_Var_Val (pstFound->collectDataVariable, iCollVarLen,
                                  &ulVal);

        if (iErr)
        {
            DEBUGMSGTL(("nuri/rtc",
                "Couldn't fetch variable's value iErr=%d for "
                "collectDataIndex=%lu\n", iErr, pstFound->collectDataIndex));
            return 1;
        }
        memset (szValStr, '\0', sizeof (szValStr));
        sprintf(szValStr,"%ld",ulVal);

        /* Get the current time stamp in ascii format */
        RTC_Get_ASCII_Time(szTimeStr);

        DEBUGMSGTL(("nuri/rtc", "szTimeStr=%s$\n", szTimeStr));
  
	/* Check if the LogFile Name has been changed or not.  If changed,
	   Log the details in the new file */
        RTC_Check_LogFile_Name ();

        if (fpl)
        {
            fprintf (fpl, "%s  %s  %s\n", szTimeStr, szVarStr, szValStr);
            fflush (fpl);
        }
    }
    else
    {
        DEBUGMSGTL(("nuri/rtc", "ulIndex=%lu is not found\n", ulIndex));
        return 1;
    }
    return 0; 
}

/*****************************************************************************
 * name             :   RTC_Fetch_Var_Val
 * description      :   To retrieve the value of the variable
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_Retrieve_Log_Variable
 *****************************************************************************/

int
RTC_Fetch_Var_Val (oid * name, size_t namelen, u_long *pulNewValue)
{
    struct variable *pstVarPtr = NULL;
    netsnmp_subtree *pstSPtr = NULL;
    register u_char *ucAccess = NULL;
    size_t var_len;
    struct variable stCalledVar = { 0 };
    WriteMethod    *write_method = NULL;

    pstSPtr = netsnmp_subtree_find (name,namelen,NULL,"");

    if (pstSPtr!=NULL)
    { 
        pstVarPtr = pstSPtr->reginfo->handler->next->myvoid;
        if (pstVarPtr!=NULL)
        {
            stCalledVar.namelen = namelen-1;
            stCalledVar.type = pstVarPtr->type;
            stCalledVar.magic = pstVarPtr->magic;
            stCalledVar.acl = pstVarPtr->acl;
            stCalledVar.findVar = pstVarPtr->findVar;
            memcpy(stCalledVar.name,name, ((namelen * sizeof(oid))-1));

	    /* Call the method routine to fetch the value */
            ucAccess = pstVarPtr->findVar (&stCalledVar,name, &namelen, 1,
                                                        &var_len,&write_method);
            
        }
        else
        {
            DEBUGMSGTL(("nuri/rtc", "pstVarPtr IS NULL! MAGIC NOT FOUND\n"));
            return 1;
        }
    }

    if (ucAccess != NULL)
    {
        *pulNewValue = *(u_long *) ucAccess;
    }
    else
    {
        DEBUGMSGTL(("nuri/rtc", "VALUE ucAccess IS NULL!\n"));
        return 2;
    }
    return 0;
}

/*****************************************************************************
 * name             :   RTC_Get_ASCII_Time
 * description      :   Returns current time stamp in ascii format
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTC_Retrieve_Log_Variable
 *****************************************************************************/

int
RTC_Get_ASCII_Time (char *pcTimeStr)
{
    char *pcPtr;
    struct tm stTm;
    struct timeval stTv;

    gettimeofday(&stTv, (struct timezone *) 0);
    memcpy(&stTm, localtime((time_t *) & stTv.tv_sec), sizeof(stTm));

    errno = 0;
    if ((pcPtr = asctime (&stTm)) ==  (char *) NULL)
    {
           DEBUGMSGTL(("nuri/rtc", "asctime returns NULL errno=%d\n", errno));
           return 1;
    }

    if (pcPtr[strlen(pcPtr) - 1] == '\n')
        pcPtr[strlen(pcPtr) - 1] = '\0';

    strcpy (pcTimeStr, pcPtr);

    DEBUGMSGTL(("nuri/rtc", "tv_sec=%ld pcTimeStr=%s$ errno=%d\n",
                stTv.tv_sec, pcTimeStr, errno));
    return 0;
}

/*****************************************************************************
 * name             :   RTC_Check_LogFile_Name
 * description      :   Opens new file if gcInfoLogFileSystemData changed
 *                      Opens default file RTC_DEFAULT_LOGFILE if
 *                      gcInfoLogFileSystemData is empty string
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :   gcInfoLogFileSystemData, szSavedLogFile
 * calls            :   RTC_Retrieve_Log_Variable
 *****************************************************************************/

int
RTC_Check_LogFile_Name ()
{
    if (strlen (gcInfoLogFileSystemData) == 0)
    {
        if (iLogFlag == 0 || iLogFlag == 2)
        {
            if (fpl) fclose (fpl);
            if ((fpl = fopen (RTC_DEFAULT_LOGFILE, "w")) == (FILE *) NULL) 
            {
                DEBUGMSGTL(("nuri/rtc",
                      "Unable to open RTC_DEFAULT_LOGFILE errno=%d\n", errno));
                guiRTCReg1 = snmp_alarm_register (RTC_IDLE_TIME, (int) NULL,
                                                           RTC_callback, NULL);
                return 1;
            }
            iLogFlag = 1;
            strcpy (szSavedLogFile, RTC_DEFAULT_LOGFILE);
        }
    }
    else if (strcmp (gcInfoLogFileSystemData, szSavedLogFile))
    {
        iLogFlag = 2;
        if (fpl) fclose (fpl);
        if ((fpl = fopen (gcInfoLogFileSystemData, "w")) == (FILE *) NULL)
        {
            DEBUGMSGTL(("nuri/rtc", "Unable to open <%s> file "
                "errno=%d. Logging in RTC_DEFAULT_LOGFILE\n",
                gcInfoLogFileSystemData, errno));

            strcpy (szSavedLogFile, gcInfoLogFileSystemData);

            if ((fpl = fopen (RTC_DEFAULT_LOGFILE, "w")) == (FILE *) NULL) 
            {
                DEBUGMSGTL(("nuri/rtc",
                     "Unable to open RTC_DEFAULT_LOGFILE errno=%d\n", errno));

                guiRTCReg1 = snmp_alarm_register (RTC_IDLE_TIME, (int) NULL,
                                                           RTC_callback, NULL);
                return 1;
            }
        }
        else
        {
            strcpy (szSavedLogFile, gcInfoLogFileSystemData);
        }
    }
    return 0;
}

/* <End: WIP_NURI_ALL > */

/* End of collectDataTable.c */
