/*
 * Note: this file originally auto-generated by mib2c using
 *    : mib2c.array-user.conf,v 5.15.2.1 2003/02/27 05:59:41 rstory Exp $
 *
 * $Id: trapTable.c,v 1.16 2003/11/11 07:15:30 vijaysp Exp $
 *
 *
 * For help understanding NET-SNMP in general, please check the
 *     documentation and FAQ at:
 *
 *     http://www.net-snmp.org/
 *
 *
 * For help understanding this code, the agent and how it processes
 *     requests, please check the following references.
 *
 *     http://www.net-snmp.org/tutorial/
 *
 *
 * You can also join the #net-snmp channel on irc.openprojects.net
 *     and ask for help there.
 *
 *
 * And if all else fails, send a detailed message to the developers
 *     describing the problem you are having to:
 *
 *    net-snmp-coders@lists.sourceforge.net
 *
 *
 * Yes, there is lots of code here that you might not use. But it is much
 * easier to remove code than to add it!
 */

/* <Start: WIP_NURI_ALL > */

/********************************* includes *********************************/

#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <ctype.h>
#include <errno.h>

#ifdef WIN32
#include <windows.h>
#else
#include <arpa/inet.h>
#include <netdb.h>
#endif /* WIN32 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/snmp_assert.h>

#include "trapTable.h"

/****************************** local macros ********************************
 *
 * (Macros shareable with rest of the modules are present in .h file)
 */

#define MAX_VAL_LEN 255
#define NURI_ENTERPRISE_OID ".1.3.6.1.4.1.3204"

/********************* local structure/union definitions ********************/

typedef struct {
    char variable[MAX_OID_LEN];
    char type;
    char value[MAX_VAL_LEN];
} stVarBindArgs;

/********************* prototypes for local functions ***********************/

void RTM_callback (unsigned int, void *);
void Load_Container_From_File ();
static int RTM_Fetch_Var_Val (oid *, size_t, u_long *);
int Validate_trapVariable (char *, trapTable_context *);
int RTM_Log_Trap_Details (int, stVarBindArgs *, trapTable_context *);
int send_snmptrap (int, stVarBindArgs *, trapTable_context *);
int RTM_Get_ASCII_Time (char *);

#ifdef WIN32
long RTM_Get_Uptime_Win ();
#endif

/************************* Globals within this module ***********************/

static netsnmp_handler_registration *my_handler = NULL;
netsnmp_table_array_callbacks cb;

oid trapTable_oid[] = { trapTable_TABLE_OID };
size_t trapTable_oid_len = OID_LENGTH(trapTable_oid);

oid  objid_enterprise[] = { 1, 3, 6, 1, 4, 1, 3, 1, 1 };
oid  objid_sysdescr[] = { 1, 3, 6, 1, 2, 1, 1, 1, 0 };
oid  objid_sysuptime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
oid  objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

FILE *fpt = NULL;
unsigned int rtm_regid = 0;

/************************* externs  ***********************/

extern netsnmp_table_array_callbacks cb;

/* <End: WIP_NURI_ALL > */

#ifdef trapTable_IDX2
/************************************************************
 * keep binary tree to find context by name
 */
static int trapTable_cmp( const void *lhs, const void *rhs );

/************************************************************
 * compare two context pointers here. Return -1 if lhs < rhs,
 * 0 if lhs == rhs, and 1 if lhs > rhs.
 */
static int
trapTable_cmp( const void *lhs, const void *rhs )
{
    trapTable_context *context_l =
    (trapTable_context *)lhs;
    trapTable_context *context_r =
    (trapTable_context *)rhs;

    /*
     * check primary key, then secondary. Add your own code if
     * there are more than 2 indexes
     */
    int rc;

    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR,
         "trapTable_compare not implemented! Container order undefined\n" );
    return 0;
#endif

    /*
     * EXAMPLE:
     *
     * rc = strcmp( context_l->xxName, context_r->xxName);
     *
     * if(rc)
     *     return rc;
     *
     * TODO: fix secondary keys (or delete if there are none)
     *
     * if(context_l->yy < context_r->yy)
     *     return -1;
     *
     * return (context_l->yy == context_r->yy) ? 0 : 1;
     */
}

/************************************************************
 * search tree
 */
/** TODO: set additional indexes as parameters */
trapTable_context *
trapTable_get( const char *name, int len )
{
    trapTable_context tmp;


    /** we should have a secondary index */
    netsnmp_assert(cb.container->next != NULL);

    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "trapTable_get not implemented!\n" );
    return NULL;
#endif

    /*
     * EXAMPLE:
     *
     * if(len > sizeof(tmp.xxName))
     *     return NULL;
     *
     * strncpy( tmp.xxName, name, sizeof(tmp.xxName) );
     * tmp.xxName_len = len;
     *
     * return CONTAINER_FIND(cb.container->next, &tmp);
     */
}
#endif

char *
RTM_trim (char *str)
{
  int i=0;
  int j=0;

  while (isspace ((int) str[i]))
    i++;
  j = strlen (str);
  while (isspace((int) str[j-1]))
    j--;
  str[j] = '\0';
  str = &str[i];
  return str;
}

int
RTM_trim_quotes (char *str)
{
    char *ptr;

    if (str[0] == '"')
    {
        ptr = str+1;      
        strcpy (str, ptr);
    }

    if (str[strlen (str) - 1] == '"')
        str[strlen (str) - 1] = '\0';

    return 0;
}

int interval = RTM_DEFAULT_INTERVAL;
long fsize = RTM_DEFAULT_MAX_LOGFILE_SIZE;
char fpath[150] = { 0 };

void
RTM_Load_Details_From_Config_File ()
{
    FILE *cfp;
    char *token;
    char line[150]= { 0 };

    strcpy (fpath, RTM_DEFAULT_LOGFILE_PATH);

    cfp = fopen (RTM_CONFIG_FILE, "r");
    if (cfp == NULL)
    {
        DEBUGMSGTL(("nuri/rtm", "Unable to open RTM_CONFIG_FILE errno=%d! "
         "Taking default configuration details\n", errno));
        return;
    }

    while (fgets (line, sizeof (line), cfp) != NULL)
    {
        if (line[0] == '#')
        {
            continue;
        }
        if (strstr (line, "RTM_INTERVAL"))
        {
            if ((token = (char *) strtok (line, "=")) != NULL)
            {
                if ((token = (char *) strtok (NULL, "\n")) != NULL)
                {
                    token = (char *) RTM_trim (token);
                    if (token != NULL && ((interval = atoi (token)) <= 0))
                        interval = RTM_DEFAULT_INTERVAL;
                }
            }
        }
        else if (strstr (line, "RTM_LOGFILE_PATH"))
        {
            if ((token = (char *) strtok (line, "=")) != NULL)
            {
                if ((token = (char *) strtok (NULL, "\n")) != NULL)
                {
                    if ((token = (char *) RTM_trim (token)) != NULL)
                        strcpy (fpath, token);
                }
            }
        }
        else if (strstr (line, "RTM_MAX_LOGFILE_SIZE"))
        {
            if ((token=(char *) strtok (line, "=")) != NULL)
            {
                if ((token = (char *) strtok (NULL, "\n")) != NULL)
                {
                    token = (char *) RTM_trim (token);
                    if (token != NULL && ((fsize = atol (token)) <= 0))
                        fsize = RTM_DEFAULT_MAX_LOGFILE_SIZE;
                }
            }
        }
  
        memset (line, '\0', sizeof (line));
    } /* while */

    DEBUGMSGTL(("nuri/rtm",
                "interval=%d fpath=%s fsize=%ld\n", interval, fpath, fsize));
    return;
}

/************************************************************
 * Initializes the trapTable module
 */
void
init_trapTable(void)
{
    initialize_table_trapTable();

    /* Load the container file ../conf/trapTable.conf */

    Load_Container_From_File ();

    /* Load configuration details from SA.conf file */

    RTM_Load_Details_From_Config_File ();

    RTM_callback (1, (void *) NULL);
}

/************************************************************
 * the *_row_copy routine
 */
static int trapTable_row_copy(trapTable_context * dst,
             trapTable_context * src)
{
    if(!dst||!src)
    return 1;

    /*
     * copy index, if provided
     */
    if(dst->index.oids)
    free(dst->index.oids);
    if(snmp_clone_mem( (void*)&dst->index.oids, src->index.oids,
               src->index.len * sizeof(oid) )) {
    dst->index.oids = NULL;
    return 1;
    }
    dst->index.len = src->index.len;


    /*
     * copy components into the context structure
     */
    dst->trapIndex = src->trapIndex;

    dst->trapPolicyID = src->trapPolicyID;

    dst->trapType = src->trapType;

    /*
    memcpy( src->trapVariable, dst->trapVariable, src->trapVariable_len );
    original code */

    /* modified by Vijay - DUMMY - start */
    memcpy( dst->trapVariable, src->trapVariable, src->trapVariable_len );
    /* modified by Vijay - DUMMY - end */

    dst->trapVariable_len = src->trapVariable_len;

    dst->trapExpression = src->trapExpression;

    dst->trapValue = src->trapValue;

    memcpy( dst->trapDescription, src->trapDescription, src->trapDescription_len );
    dst->trapDescription_len = src->trapDescription_len;

    dst->trapDestinationIP = src->trapDestinationIP;

    dst->trapPort = src->trapPort;

    dst->trapTransport = src->trapTransport;

    memcpy( dst->trapMessage, src->trapMessage, src->trapMessage_len );
    dst->trapMessage_len = src->trapMessage_len;

    dst->trapStatus = src->trapStatus;

    return 0;
}

#ifdef trapTable_SET_HANDLING

/*
 * the *_extract_index routine
 */
int
trapTable_extract_index( trapTable_context * ctx, netsnmp_index * hdr )
{
    /*
     * temporary local storage for extracting oid index
     */
    netsnmp_variable_list var_trapIndex;
    int err;

    /*
     * copy index, if provided
     */
    if(hdr) {
    netsnmp_assert(ctx->index.oids == NULL);
    if(snmp_clone_mem( (void*)&ctx->index.oids, hdr->oids,
               hdr->len * sizeof(oid) )) {
        return -1;
    }
    ctx->index.len = hdr->len;
    }

    /**
     * Create variable to hold each component of the index
     */
       memset( &var_trapIndex, 0x00, sizeof(var_trapIndex) );
       var_trapIndex.type = ASN_UNSIGNED;
       /** TODO: link this index to the next, or NULL for the last one */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "trapTable_extract_index index list not implemented!\n" );
    return 0;
#else
       /* var_trapIndex.next_variable = &var_XX; */ /* DUMMY */
#endif


    /*
     * parse the oid into the individual components
     */
    err = parse_oid_indexes( hdr->oids, hdr->len, &var_trapIndex );
    if (err == SNMP_ERR_NOERROR) {
       /*
    * copy components into the context structure
    */
        ctx->trapIndex = *var_trapIndex.val.integer;


       /*
        * TODO: check index for valid values. For EXAMPLE:
        *
          * if ( *var_trapIndex.val.integer != XXX ) {
      *    err = -1;
      * }
      */
    }

    /*
     * parsing may have allocated memory. free it.
     */
    snmp_reset_var_buffers( &var_trapIndex );

    return err;
}

/************************************************************
 * the *_can_activate routine is called
 * when a row is changed to determine if all the values
 * set are consistent with the row's rules for a row status
 * of ACTIVE.
 *
 * return 1 if the row could be ACTIVE
 * return 0 if the row is not ready for the ACTIVE state
 */
int trapTable_can_activate(trapTable_context *undo_ctx,
              trapTable_context *row_ctx,
              netsnmp_request_group * rg)
{
    /*
     * TODO: check for activation requirements here
     */
    return 1;
}

/************************************************************
 * the *_can_deactivate routine is called when a row that is
 * currently ACTIVE is set to a state other than ACTIVE. If
 * there are conditions in which a row should not be allowed
 * to transition out of the ACTIVE state (such as the row being
 * referred to by another row or table), check for them here.
 *
 * return 1 if the row can be set to a non-ACTIVE state
 * return 0 if the row must remain in the ACTIVE state
 */
int trapTable_can_deactivate(trapTable_context *undo_ctx,
            trapTable_context *row_ctx,
            netsnmp_request_group * rg)
{
    /*
     * TODO: check for deactivation requirements here
     */
    return 1;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int trapTable_can_delete(trapTable_context *undo_ctx,
            trapTable_context *row_ctx,
            netsnmp_request_group * rg)
{
    /*
     * probably shouldn't delete a row that we can't
     * deactivate.
     */
    if(trapTable_can_deactivate(undo_ctx,row_ctx,rg) != 1)
    return 0;

    /*
     * TODO: check for other deletion requirements here
     */
    return 1;
}

#ifdef trapTable_ROW_CREATION
/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated trapTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
trapTable_context *
trapTable_create_row( netsnmp_index* hdr)
{
    trapTable_context * ctx =
    SNMP_MALLOC_TYPEDEF(trapTable_context);
    if(!ctx)
    return NULL;

    /*
     * TODO: check indexes, if necessary.
     */
    if(trapTable_extract_index( ctx, hdr )) {
    free(ctx->index.oids);
    free(ctx);
    return NULL;
    }

    /* netsnmp_mutex_init(ctx->lock);
       netsnmp_mutex_lock(ctx->lock); */

    /*
     * TODO: initialize any default values here. This is also
     * first place you really should allocate any memory for
     * yourself to use.     If you allocated memory earlier,
     * make sure you free it for earlier error cases!
     */
    /**
     ctx->trapIndex = 0;
     ctx->trapPolicyID = 0;
     ctx->trapType = 0;
     ctx->trapVariable = 0;
     ctx->trapExpression = 0;
     ctx->trapValue = 0;
     ctx->trapDescription = 0;
     ctx->trapDestinationIP = 0;
     ctx->trapPort = 0;
     ctx->trapTransport = 0;
     ctx->trapMessage = 0;
     ctx->trapStatus = 0;
    */
   
    /* Assume system resource (1) as default for trapType */

     ctx->trapType = 1;

    return ctx;
}
#endif

/************************************************************
 * the *_duplicate row routine
 */
trapTable_context *
trapTable_duplicate_row( trapTable_context * row_ctx)
{
    trapTable_context * dup;

    if(!row_ctx)
    return NULL;

    dup = SNMP_MALLOC_TYPEDEF(trapTable_context);
    if(!dup)
    return NULL;

    if(trapTable_row_copy(dup,row_ctx)) {
    free(dup);
    dup = NULL;
    }

    return dup;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index * trapTable_delete_row( trapTable_context * ctx )
{
  /* netsnmp_mutex_destroy(ctx->lock); */

    if(ctx->index.oids)
    free(ctx->index.oids);

    /*
     * TODO: release any memory you allocated here...
     */

    /*
     * release header
     */
    free( ctx );

    return NULL;
}


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void trapTable_set_reserve1( netsnmp_request_group *rg )
{
    trapTable_context *row_ctx =
        (trapTable_context *)rg->existing_row;
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;
    int rc;


    /*
     * TODO: loop through columns, check syntax and lengths. For
     * columns which have no dependencies, you could also move
     * the value/range checking here to attempt to catch error
     * cases as early as possible.
     */
    for( current = rg->list; current; current = current->next ) {

    var = current->ri->requestvb;
    rc = SNMP_ERR_NOERROR;

    switch(current->tri->colnum) {

    case COLUMN_TRAPINDEX:
        /** UNSIGNED32 = ASN_UNSIGNED */
        rc = netsnmp_check_vb_type_and_size(var, ASN_UNSIGNED,
                        sizeof(row_ctx->trapIndex));
        if ((long) *var->val.integer < TRAPINDEX_MIN ||
        (long) *var->val.integer > TRAPINDEX_MAX)
        {
        rc = SNMP_ERR_WRONGVALUE;
        }
        break;

    case COLUMN_TRAPPOLICYID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        rc = netsnmp_check_vb_type_and_size(var, ASN_UNSIGNED,
                        sizeof(row_ctx->trapPolicyID));
        break;

    case COLUMN_TRAPTYPE:
        /** INTEGER = ASN_INTEGER */
        rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                        sizeof(row_ctx->trapType));

        if ((long) *var->val.integer < TRAPTYPE_MIN ||
        (long) *var->val.integer > TRAPTYPE_MAX)
        {
        rc = SNMP_ERR_WRONGVALUE;
        }
        break;

    case COLUMN_TRAPVARIABLE:
        /** OBJECTID = ASN_OBJECT_ID */
        rc = netsnmp_check_vb_type_and_size(var, ASN_OBJECT_ID,
                        var->val_len);

        break;

    case COLUMN_TRAPEXPRESSION:
        /** INTEGER = ASN_INTEGER */
        rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                        sizeof(row_ctx->trapExpression));
        if ((long) *var->val.integer < TRAPEXPR_MIN ||
        (long) *var->val.integer > TRAPEXPR_MAX)
        {
        rc = SNMP_ERR_WRONGVALUE;
        }
        break;

    case COLUMN_TRAPVALUE:
        /** INTEGER = ASN_INTEGER */
        rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                        sizeof(row_ctx->trapValue));
        break;

    case COLUMN_TRAPDESCRIPTION:
        /** DisplayString = ASN_OCTET_STR */
        rc = netsnmp_check_vb_type_and_size(var, ASN_OCTET_STR,
                        sizeof(row_ctx->trapDescription));
        break;

    case COLUMN_TRAPDESTINATIONIP:
        /** IPADDR = ASN_IPADDRESS */
        rc = netsnmp_check_vb_type_and_size(var, ASN_IPADDRESS,
                        sizeof(row_ctx->trapDestinationIP));
        break;

    case COLUMN_TRAPPORT:
        /** INTEGER = ASN_INTEGER */
        rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                        sizeof(row_ctx->trapPort));
        break;

    case COLUMN_TRAPTRANSPORT:
        /** INTEGER = ASN_INTEGER */
        rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                        sizeof(row_ctx->trapTransport));
        if ((long) *var->val.integer < TRAPTRANSPORT_MIN ||
        (long) *var->val.integer > TRAPTRANSPORT_MAX)
        {
        rc = SNMP_ERR_WRONGVALUE;
        }
        break;

    case COLUMN_TRAPMESSAGE:
        /** DisplayString = ASN_OCTET_STR */
        /* rc = netsnmp_check_vb_type_and_size(var, ASN_OCTET_STR,
                        sizeof(row_ctx->trapMessage)); */

        rc = netsnmp_check_vb_type_and_size(var, ASN_OCTET_STR, var->val_len);

        break;

    case COLUMN_TRAPSTATUS:
        /** RowStatus = ASN_INTEGER */
        rc = netsnmp_check_vb_type_and_size(var, ASN_INTEGER,
                        sizeof(row_ctx->trapStatus));

        break;

    default: /** We shouldn't get here */
        rc = SNMP_ERR_GENERR;
        snmp_log(LOG_ERR, "unknown column in "
             "trapTable_set_reserve1\n");
    }

    if (rc)
       netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc );
    rg->status = SNMP_MAX( rg->status, current->ri->status );
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

void trapTable_set_reserve2( netsnmp_request_group *rg )
{
    trapTable_context *undo_ctx = (trapTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;
    netsnmp_variable_list *var;
    int rc;

    rg->rg_void = rg->list->ri;

    /*
     * TODO: loop through columns, check for valid
     * values and any range constraints.
     */
    for( current = rg->list; current; current = current->next ) {

    var = current->ri->requestvb;
    rc = SNMP_ERR_NOERROR;

    switch(current->tri->colnum) {

    case COLUMN_TRAPINDEX:
        /** UNSIGNED32 = ASN_UNSIGNED */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( *var->val.integer != XXX ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPPOLICYID:
        /** UNSIGNED32 = ASN_UNSIGNED */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( *var->val.integer != XXX ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPTYPE:
        /** INTEGER = ASN_INTEGER */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( *var->val.integer != XXX ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPVARIABLE:
        /** OBJECTID = ASN_OBJECT_ID */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( XXX_check_oid( var ) ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPEXPRESSION:
        /** INTEGER = ASN_INTEGER */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( *var->val.integer != XXX ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPVALUE:
        /** INTEGER = ASN_INTEGER */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( *var->val.integer != XXX ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPDESCRIPTION:
        /** DisplayString = ASN_OCTET_STR */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( XXX_check_value( var->val.string, XXX ) ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPDESTINATIONIP:
        /** IPADDR = ASN_IPADDRESS */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( XXX_check_ip( *var->val.integer ) ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPPORT:
        /** INTEGER = ASN_INTEGER */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( *var->val.integer != XXX ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPTRANSPORT:
        /** INTEGER = ASN_INTEGER */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( *var->val.integer != XXX ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPMESSAGE:
        /** DisplayString = ASN_OCTET_STR */
            /*
             * TODO: routine to check valid values
             *
             * EXAMPLE:
             *
            * if ( XXX_check_value( var->val.string, XXX ) ) {
        *    rc = SNMP_ERR_INCONSISTENTVALUE;
        *    rc = SNMP_ERR_BADVALUE;
        * }
        */
    break;

    case COLUMN_TRAPSTATUS:
        /** RowStatus = ASN_INTEGER */
        rc = netsnmp_check_vb_rowstatus(current->ri->requestvb,
                        undo_ctx ?
                        undo_ctx->trapStatus:0);
        rg->rg_void = current->ri;

        if (current->tri->index_oid[0] < TRAPINDEX_MIN ||
            current->tri->index_oid[0] > TRAPINDEX_MAX)
        {
            rc = SNMP_ERR_WRONGVALUE;
        }
        break;

    default: /** We shouldn't get here */
        netsnmp_assert(0); /** why wasn't this caught in reserve1? */
    }

    if (rc)
       netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc);
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void trapTable_set_action( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
    trapTable_context *row_ctx = (trapTable_context *)rg->existing_row;
    trapTable_context *undo_ctx = (trapTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    int           row_err = 0;

    /*
     * TODO: loop through columns, copy varbind values
     * to context structure for the row.
     */
    for( current = rg->list; current; current = current->next ) {

    var = current->ri->requestvb;

    switch(current->tri->colnum) {

    case COLUMN_TRAPINDEX:
        /** UNSIGNED32 = ASN_UNSIGNED */
        row_ctx->trapIndex = *var->val.integer;
    break;

    case COLUMN_TRAPPOLICYID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        row_ctx->trapPolicyID = *var->val.integer;
    break;

    case COLUMN_TRAPTYPE:
        /** INTEGER = ASN_INTEGER */
        row_ctx->trapType = *var->val.integer;
    break;

    case COLUMN_TRAPVARIABLE:
        /** OBJECTID = ASN_OBJECT_ID */
        memcpy(row_ctx->trapVariable,var->val.objid,var->val_len);
        row_ctx->trapVariable_len = var->val_len;
    break;

    case COLUMN_TRAPEXPRESSION:
        /** INTEGER = ASN_INTEGER */
        row_ctx->trapExpression = *var->val.integer;
    break;

    case COLUMN_TRAPVALUE:
        /** INTEGER = ASN_INTEGER */
        row_ctx->trapValue = *var->val.integer;
    break;

    case COLUMN_TRAPDESCRIPTION:
        /** DisplayString = ASN_OCTET_STR */
        memcpy(row_ctx->trapDescription,var->val.string,var->val_len);
        row_ctx->trapDescription_len = var->val_len;
    break;

    case COLUMN_TRAPDESTINATIONIP:
        /** IPADDR = ASN_IPADDRESS */
        row_ctx->trapDestinationIP = *var->val.integer;
    break;

    case COLUMN_TRAPPORT:
        /** INTEGER = ASN_INTEGER */
        row_ctx->trapPort = *var->val.integer;
    break;

    case COLUMN_TRAPTRANSPORT:
        /** INTEGER = ASN_INTEGER */
        row_ctx->trapTransport = *var->val.integer;
    break;

    case COLUMN_TRAPMESSAGE:
        /** DisplayString = ASN_OCTET_STR */
        memcpy(row_ctx->trapMessage,var->val.string,var->val_len);
        row_ctx->trapMessage_len = var->val_len;
    break;

    case COLUMN_TRAPSTATUS:
        /** RowStatus = ASN_INTEGER */
        row_ctx->trapStatus = *var->val.integer;
    break;

    default: /** We shouldn't get here */
        netsnmp_assert(0); /** why wasn't this caught in reserve1? */
    }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
#ifndef trapTable_CAN_MODIFY_ACTIVE_ROW
    if( undo_ctx && RS_IS_ACTIVE(undo_ctx->trapStatus) &&
    row_ctx && RS_IS_ACTIVE(row_ctx->trapStatus) ) {
        row_err = 1;
    }
#endif

    /*
     * check activation/deactivation
     */
    row_err = netsnmp_table_array_check_row_status(&cb, rg,
                  row_ctx ? &row_ctx->trapStatus : NULL,
                  undo_ctx ? &undo_ctx->trapStatus : NULL);
    if(row_err) {
    netsnmp_set_mode_request_error(MODE_SET_BEGIN,
                       (netsnmp_request_info*)rg->rg_void,
                       row_err);
    return;
    }

    /*
     * TODO: if you have dependencies on other tables, this would be
     * a good place to check those, too.
     */
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void trapTable_set_commit( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;
    trapTable_context *mycontext = NULL;
    FILE *fp;

    fp = fopen (RTM_CONTAINER_FILE, "wb");
    if (!fp)
    {
    DEBUGMSGTL(("nuri/rtm",
            "Couldn't open RTM_CONTAINER_FILE error no: %d\n", errno));
    return;
    }

    mycontext = CONTAINER_FIRST(cb.container);
    if (mycontext)
    {
        /* Assign mycontext index->oids to idx */
        mycontext->idx = (unsigned long) *mycontext->index.oids;

        if (fwrite(mycontext,sizeof(trapTable_context),1,fp)!=1)
        {
            DEBUGMSGTL(("nuri/rtm", "write error errno: %d\n", errno));
            /* serious problem? */
            return;
        }
    }

    while (mycontext)
    {
        mycontext = CONTAINER_NEXT(cb.container,mycontext);
        if (mycontext)
        {
            /* Assign mycontext index->oids to idx */
            mycontext->idx = (unsigned long) *mycontext->index.oids;

            if (fwrite (mycontext,sizeof (trapTable_context),1,fp)!=1)
            {
                DEBUGMSGTL(("nuri/rtm", "write error errno: %d\n", errno));
               /* serious problem? */
               return;
            }
        }
    }

    fclose (fp);

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

    var = current->ri->requestvb;

    switch(current->tri->colnum) {

    case COLUMN_TRAPINDEX:
        /** UNSIGNED32 = ASN_UNSIGNED */
    break;

    case COLUMN_TRAPPOLICYID:
        /** UNSIGNED32 = ASN_UNSIGNED */
    break;

    case COLUMN_TRAPTYPE:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPVARIABLE:
        /** OBJECTID = ASN_OBJECT_ID */
    break;

    case COLUMN_TRAPEXPRESSION:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPVALUE:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPDESCRIPTION:
        /** DisplayString = ASN_OCTET_STR */
    break;

    case COLUMN_TRAPDESTINATIONIP:
        /** IPADDR = ASN_IPADDRESS */
    break;

    case COLUMN_TRAPPORT:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPTRANSPORT:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPMESSAGE:
        /** DisplayString = ASN_OCTET_STR */
    break;

    case COLUMN_TRAPSTATUS:
        /** RowStatus = ASN_INTEGER */
    break;

    default: /** We shouldn't get here */
        netsnmp_assert(0); /** why wasn't this caught in reserve1? */
    }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void trapTable_set_free( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

    var = current->ri->requestvb;

    switch(current->tri->colnum) {

    case COLUMN_TRAPINDEX:
        /** UNSIGNED32 = ASN_UNSIGNED */
    break;

    case COLUMN_TRAPPOLICYID:
        /** UNSIGNED32 = ASN_UNSIGNED */
    break;

    case COLUMN_TRAPTYPE:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPVARIABLE:
        /** OBJECTID = ASN_OBJECT_ID */
    break;

    case COLUMN_TRAPEXPRESSION:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPVALUE:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPDESCRIPTION:
        /** DisplayString = ASN_OCTET_STR */
    break;

    case COLUMN_TRAPDESTINATIONIP:
        /** IPADDR = ASN_IPADDRESS */
    break;

    case COLUMN_TRAPPORT:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPTRANSPORT:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPMESSAGE:
        /** DisplayString = ASN_OCTET_STR */
    break;

    case COLUMN_TRAPSTATUS:
        /** RowStatus = ASN_INTEGER */
    break;

    default: /** We shouldn't get here */
         break;
        /** should have been logged in reserve1 */
    }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void trapTable_set_undo( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

    var = current->ri->requestvb;

    switch(current->tri->colnum) {

    case COLUMN_TRAPINDEX:
        /** UNSIGNED32 = ASN_UNSIGNED */
    break;

    case COLUMN_TRAPPOLICYID:
        /** UNSIGNED32 = ASN_UNSIGNED */
    break;

    case COLUMN_TRAPTYPE:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPVARIABLE:
        /** OBJECTID = ASN_OBJECT_ID */
    break;

    case COLUMN_TRAPEXPRESSION:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPVALUE:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPDESCRIPTION:
        /** DisplayString = ASN_OCTET_STR */
    break;

    case COLUMN_TRAPDESTINATIONIP:
        /** IPADDR = ASN_IPADDRESS */
    break;

    case COLUMN_TRAPPORT:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPTRANSPORT:
        /** INTEGER = ASN_INTEGER */
    break;

    case COLUMN_TRAPMESSAGE:
        /** DisplayString = ASN_OCTET_STR */
    break;

    case COLUMN_TRAPSTATUS:
        /** RowStatus = ASN_INTEGER */
    break;

    default: /** We shouldn't get here */
        netsnmp_assert(0); /** why wasn't this caught in reserve1? */
    }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

#endif /** trapTable_SET_HANDLING */


/************************************************************
 *
 * Initialize the trapTable table by defining its contents and how it's structured
 */
void
initialize_table_trapTable(void)
{
    netsnmp_table_registration_info *table_info;

    if(my_handler) {
    snmp_log(LOG_ERR, "initialize_table_trapTable_handler called again\n");
    return;
    }

    memset(&cb, 0x00, sizeof(cb));

    /** create the table structure itself */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    /* if your table is read only, it's easiest to change the
       HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("trapTable",
                         netsnmp_table_array_helper_handler,
                         trapTable_oid,
                         trapTable_oid_len,
                         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info) {
    snmp_log(LOG_ERR, "malloc failed in "
         "initialize_table_trapTable_handler\n");
    return; /** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    /*
     * TODO: add any external indexes here.
     */

    /*
     * internal indexes
     */
    /** index: trapIndex */
    netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);

    table_info->min_column = trapTable_COL_MIN;
    table_info->max_column = trapTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
    cb.get_value = trapTable_get_value;
    cb.container = netsnmp_container_find("trapTable_primary:"
                      "trapTable:"
                      "table_container");
#ifdef trapTable_IDX2

    netsnmp_container_add_index(cb.container,
                netsnmp_container_find("trapTable_secondary:"
                               "trapTable:"
                               "table_container"));
    cb.container->next->compare = trapTable_cmp;
#endif
#ifdef trapTable_SET_HANDLING
    cb.can_set = 1;
#ifdef trapTable_ROW_CREATION
    cb.create_row = (UserRowMethod*)trapTable_create_row;
#endif
    cb.duplicate_row = (UserRowMethod*)trapTable_duplicate_row;
    cb.delete_row = (UserRowMethod*)trapTable_delete_row;
    cb.row_copy = (Netsnmp_User_Row_Operation *)trapTable_row_copy;

    cb.can_activate = (Netsnmp_User_Row_Action *)trapTable_can_activate;
    cb.can_deactivate = (Netsnmp_User_Row_Action *)trapTable_can_deactivate;
    cb.can_delete = (Netsnmp_User_Row_Action *)trapTable_can_delete;

    cb.set_reserve1 = trapTable_set_reserve1;
    cb.set_reserve2 = trapTable_set_reserve2;
    cb.set_action = trapTable_set_action;
    cb.set_commit = trapTable_set_commit;
    cb.set_free = trapTable_set_free;
    cb.set_undo = trapTable_set_undo;
#endif

    DEBUGMSGTL(("nuri/rtm", "Registering table trapTable "
                "as a table array\n"));

    netsnmp_table_container_register(my_handler, table_info, &cb,
                     cb.container, 1);

}

/************************************************************
 * trapTable_get_value
 */
int trapTable_get_value(
        netsnmp_request_info *request,
        netsnmp_index *item,
        netsnmp_table_request_info *table_info )
{
    netsnmp_variable_list *var = request->requestvb;
    trapTable_context *context = (trapTable_context *)item;
    const trapTable_context *mycontext = NULL; /* DUMMY */

    mycontext = trapTable_get_by_idx (NULL);

    switch(table_info->colnum) {

    case COLUMN_TRAPINDEX:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
             (char*)&context->trapIndex,
             sizeof(context->trapIndex) );
    break;

    case COLUMN_TRAPPOLICYID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
             (char*)&context->trapPolicyID,
             sizeof(context->trapPolicyID) );
    break;

    case COLUMN_TRAPTYPE:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
             (char*)&context->trapType,
             sizeof(context->trapType) );
    break;

    case COLUMN_TRAPVARIABLE:
        /** OBJECTID = ASN_OBJECT_ID */
        snmp_set_var_typed_value(var, ASN_OBJECT_ID,
             (char*)&context->trapVariable,
             context->trapVariable_len );
    break;

    case COLUMN_TRAPEXPRESSION:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
             (char*)&context->trapExpression,
             sizeof(context->trapExpression) );
    break;

    case COLUMN_TRAPVALUE:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
             (char*)&context->trapValue,
             sizeof(context->trapValue) );
    break;

    case COLUMN_TRAPDESCRIPTION:
        /** DisplayString = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
             (char*)&context->trapDescription,
             context->trapDescription_len );
    break;

    case COLUMN_TRAPDESTINATIONIP:
        /** IPADDR = ASN_IPADDRESS */
        snmp_set_var_typed_value(var, ASN_IPADDRESS,
             (char*)&context->trapDestinationIP,
             sizeof(context->trapDestinationIP) );
    break;

    case COLUMN_TRAPPORT:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
             (char*)&context->trapPort,
             sizeof(context->trapPort) );
    break;

    case COLUMN_TRAPTRANSPORT:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
             (char*)&context->trapTransport,
             sizeof(context->trapTransport) );
    break;

    case COLUMN_TRAPMESSAGE:
        /** DisplayString = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
             (char*)&context->trapMessage,
             context->trapMessage_len );
    break;

    case COLUMN_TRAPSTATUS:
        /** RowStatus = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
             (char*)&context->trapStatus,
             sizeof(context->trapStatus) );
    break;

    default: /** We shouldn't get here */
    snmp_log(LOG_ERR, "unknown column in "
         "trapTable_get_value\n");
    return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

/************************************************************
 * trapTable_get_by_idx
 */
const trapTable_context *
trapTable_get_by_idx(netsnmp_index * hdr)
{
    return (const trapTable_context *)
    CONTAINER_FIND(cb.container, hdr );
}

/* <Start: WIP_NURI_ALL > */

/*****************************************************************************
 * name             :   RTM_callback
 * description      :   callback function called every RTM_INTERVAL seconds
 *                      configured in configuration file. Default interval is
 *                      1 second.
 * input parameters :   unsigned int uiReg - snmp_alarm_register callback regid
 *                      void *clientarg - void pointer - unused
 * output parameters:
 * return type      :   void
 * global variables :   rtm_regid, fpath
 * calls            :   init_trapTable
 *****************************************************************************/

void
RTM_callback (unsigned int uiReg, void *clientarg)
{
    unsigned long ulVal;
    int iCnt=0;
    int iErr=0;
    char szStrOid[MAX_OID_LEN] = { 0 };
    char szTmpStr[MAX_OID_LEN] = { 0 };
    int  iTrapVarLen = 0;
    int  iSendTrap   = 0;
    stVarBindArgs aArgs[3];
    trapTable_context *pstCtx = NULL;

    /* Unregister pending alarm registerd by RTM, if any */

    if (rtm_regid != 0)
    {
        DEBUGMSGTL(("nuri/rtm", "Unregistering rtm_regid.....\n"));
        snmp_alarm_unregister(rtm_regid);
        rtm_regid = 0;
    }

    /* Get the first row of trapTable */
    pstCtx = CONTAINER_NEXT (cb.container, NULL);

    if (!fpt)
    {
        /* remove, if surrounded by quotes. fpath is the logfile path */
        RTM_trim_quotes (fpath);

        if ((fpt = fopen (fpath, "w")) == (FILE *) NULL)
        {
            DEBUGMSGTL(("nuri/rtm",
                        "Couldn't open %s file errno=%d\n", fpath, errno));
            return;
        }
    }

    while (pstCtx)
    {
        iTrapVarLen = pstCtx->trapVariable_len / sizeof (oid);

        memset (szStrOid, '\0', sizeof (szStrOid));

        for (iCnt=0; iCnt < iTrapVarLen; iCnt++)
        {
            sprintf (szTmpStr, ".%lu", pstCtx->trapVariable[iCnt]);
            strcat (szStrOid, szTmpStr);
        }

        memset (szTmpStr, '\0', sizeof (szTmpStr));

        /* Retrieve the value the trapVariable through snmpget request */

        iErr = RTM_Fetch_Var_Val (pstCtx->trapVariable,iTrapVarLen,&ulVal);
        if (iErr)
        {
            DEBUGMSGTL(("nuri/rtm",
                  "Couldn't fetch variable's value iErr=%d for trapIndex=%lu\n",
                  iErr, pstCtx->trapIndex));
            pstCtx = CONTAINER_NEXT (cb.container, pstCtx);
            continue;
        }
        sprintf(szTmpStr,"%ld",ulVal);

        DEBUGMSGTL(("nuri/rtm",
		    "RTM_Fetch_Var_Val return value=%s\n", szTmpStr));

        /* Validate trapVariable with trapExpression and Threshold value and
	   returns a boolean value (TRUE or FALSE) for sending a trap */

        iSendTrap = Validate_trapVariable (szTmpStr, pstCtx);

        if (iSendTrap == TRUE)
        {
            DEBUGMSGTL(("nuri/rtm",
                        "SendTrap is TRUE. Calling send_snmptrap\n"));

            /* Fill up Argument details to send in a trap message */
            strcpy (aArgs[0].variable, ".1.3.6.1.4.1.3204.1.3.35.2.1.2.23");
            aArgs[0].type = 'i';
            sprintf (aArgs[0].value, "%ld", pstCtx->trapPort);

            sprintf (aArgs[1].variable, ".1.3.6.1.4.1.3204.1.3.35.4.1.2.%lu",
							    pstCtx->trapIndex);
            aArgs[1].type = 'u';
            sprintf (aArgs[1].value, "%lu", pstCtx->trapPolicyID);

            sprintf (aArgs[2].variable, ".1.3.6.1.4.1.3204.1.3.35.4.1.11.%lu",
							    pstCtx->trapIndex);
            aArgs[2].type = 's';


            pstCtx->trapMessage [pstCtx->trapMessage_len] = '\0';
            memset (aArgs[2].value, '\0', sizeof (aArgs[2].value));
            memcpy (aArgs[2].value, pstCtx->trapMessage,
                                                     pstCtx->trapMessage_len);

            /* If return value is TRUE, send trap request with policyId and
               log this activity in detail in a log file */

            send_snmptrap (3, aArgs, pstCtx);

            RTM_Log_Trap_Details (3, aArgs, pstCtx);
        }

        pstCtx = CONTAINER_NEXT (cb.container, pstCtx);
    }

    rtm_regid = snmp_alarm_register (interval, (int) NULL, RTM_callback, NULL);

}

/*****************************************************************************
 * name             :   Load_Container_From_File
 * description      :   loading trapTable rows from CONTAINER file
 *                      into memory during startup
 * input parameters :
 * output parameters:
 * return type      :   void
 * global variables :
 * calls            :   init_trapTable
 *****************************************************************************/

void
Load_Container_From_File ()
{
    FILE *fp=NULL;
    int cnt=0;
    int trapVarLen = 0;
    char str_oid[MAX_OID_LEN] = { 0 };
    char tmp_str[MAX_OID_LEN] = { 0 };
    struct in_addr address;
    trapTable_context readctx;
    trapTable_context *mycontext = NULL;

    fp = fopen (RTM_CONTAINER_FILE, "rb");
    if (fp == (FILE *) NULL)
    {
      DEBUGMSGTL(("nuri/rtm",
                  "RTM_CONTAINER_FILE file open failed errno=%d\n", errno));
    }
    else
    {
    while (fread (&readctx, sizeof (trapTable_context), 1, fp) == 1)
    {
      trapVarLen = readctx.trapVariable_len / sizeof (oid); /*use OID_LENGTH? */
      memset (str_oid, 0, sizeof (str_oid));
      for (cnt=0; cnt < trapVarLen; cnt++)
      {
    sprintf (tmp_str, ".%lu", readctx.trapVariable[cnt]);
    strcat (str_oid, tmp_str);
      }
      address.s_addr = readctx.trapDestinationIP;
      memset (tmp_str, 0, sizeof (tmp_str));
      strcpy (tmp_str, (char *) inet_ntoa (address));

      DEBUGMSGTL(("nuri/rtm", "Reading from FILE: Index=%u policyId=%u "
                  "trapVariable=%s trapExpression=%ld trapValue=%ld "
                  "trapDestinationIP=%s trapPort=%ld\n", readctx.trapIndex,
                  readctx.trapPolicyID, str_oid, readctx.trapExpression,
                  readctx.trapValue, tmp_str, readctx.trapPort));

      mycontext = SNMP_MALLOC_TYPEDEF (trapTable_context);
      memcpy (mycontext, &readctx, sizeof (trapTable_context));

      netsnmp_assert(mycontext->index.oids == NULL);
      if(snmp_clone_mem( (void*)&mycontext->index.oids, &readctx.idx,
                readctx.index.len * sizeof(oid) )) {
        return;
      }

      mycontext->index.len = readctx.index.len;

      cnt = CONTAINER_INSERT (cb.container, mycontext);
      if (cnt)
      {
          DEBUGMSGTL(("nuri/rtm", "ERROR IN CONTAINER_INSERT FUNCION\n"));
      }
    }

    DEBUGMSGTL(("nuri/rtm",
                "CONTAINER SIZE=%u\n", CONTAINER_SIZE (cb.container)));
    fclose (fp);
    } /* else */

    
    return;
}

/*****************************************************************************
 * name             :   snmp_input
 * description      :   This is a callback function for sending trap
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   send_snmptrap
 *****************************************************************************/

static int
snmp_input (int operation, netsnmp_session * session,
            int reqid, netsnmp_pdu *pdu, void *magic)
{
    /* No additional processing is required, just returning */
    return 1;
}

/*****************************************************************************
 * name             :   parse_address
 * description      :   to convert hostname or ip-address to in_addr_t format
 * input parameters :
 * output parameters:
 * return type      :   in_addr_t
 * global variables :
 * calls            :   send_snmptrap
 *****************************************************************************/

in_addr_t
parse_address(char *address)
{
    in_addr_t        addr;
    struct sockaddr_in saddr;
    struct hostent *hp;

    if ((addr = inet_addr(address)) != -1)
    return addr;
    hp = gethostbyname(address);
    if (hp == NULL) {
        fprintf(stderr, "unknown host: %s\n", address);
        exit(1);
    }
    else
    {
        memcpy(&saddr.sin_addr, hp->h_addr, hp->h_length);
        return saddr.sin_addr.s_addr;
    }
}

/*****************************************************************************
 * name             :   Validate_trapVariable
 * description      :   To execute the condition for monitoring variables
 * input parameters :   char *trapVar - The value of the trapVariable
 *                      trapTable_context *pstCtx - pointer to row of trapTable
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTM_callback
 *****************************************************************************/

int
Validate_trapVariable (char *trapVar, trapTable_context *pstCtx)
{
    long trapVarVal = 0;

    /* Convert string value to long integer format */
    trapVarVal = atol (trapVar);

    switch (pstCtx->trapExpression)
    {
        case 0:
            if (trapVarVal < pstCtx->trapValue)
              return TRUE;
            break;
        case 1:
            if (trapVarVal > pstCtx->trapValue)
              return TRUE;
            break;
        case 2:
            if (trapVarVal <= pstCtx->trapValue)
              return TRUE;
            break;
        case 3:
            if (trapVarVal >= pstCtx->trapValue)
              return TRUE;
            break;
        case 4:
            if (trapVarVal != pstCtx->trapValue)
              return TRUE;
            break;
        case 5:
            if (trapVarVal == pstCtx->trapValue)
              return TRUE;
            break;
        default:
            /* print error msg. */
            DEBUGMSGTL(("nuri/rtm", "Unknown Trap Expression!!"));
            break;
    }

    return FALSE;
}

/*****************************************************************************
 * name             :   send_snmptrap
 * description      :   To send snmp trap message to Rule Based Monitoring
 * input parameters :
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTM_callback
 *****************************************************************************/

int
send_snmptrap (int length, stVarBindArgs *args, trapTable_context *ctx)
{
    netsnmp_session *ss = NULL;
    netsnmp_session session = { 0 };
    netsnmp_pdu       *pdu = NULL;
    oid            name[MAX_OID_LEN] = { 0 };
    size_t        name_length = 0;
    int            status = 0;
    char           *trap = NULL;
    int            exitval = 0;
    int            cnt = 0;
    struct in_addr  laddr = { 0 };

    /*
     * initialize session to default values
     */
    snmp_sess_init (&session);


    /* Initialize session values - DUMMY */
    session.version = SNMP_VERSION_2c;
    session.timeout = 1 * 1000000L;
    session.retries = 3;
    session.community = (unsigned char *) "public";
    session.community_len = strlen (session.community);

    if (ctx->trapDestinationIP == 0)
    {
        DEBUGMSGTL(("nuri/rtm",
         "trapTable destinationIP is zero for trapIndex=%lu", ctx->trapIndex));
    }

    laddr.s_addr = ctx->trapDestinationIP;
    session.peername = (char *) inet_ntoa (laddr);

    DEBUGMSGTL(("nuri/rtm", "trapIP=%lu peername=%s trapPort=%ld\n",
                ctx->trapDestinationIP, session.peername, ctx->trapPort));

    SOCK_STARTUP;

    session.callback = snmp_input;
    session.callback_magic = NULL;

    if (ctx->trapPort == 0)
    {
        DEBUGMSGTL(("nuri/rtm",
            "trapTable port is zero for trapIndex=%lu", ctx->trapIndex));
    }

    netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT,
               (int) ctx->trapPort);

    if (session.version == SNMP_VERSION_3) {
    /*
     * for traps, we use ourselves as the authoritative engine
     * which is really stupid since command line apps don't have a
     * notion of a persistent engine.  Hence, our boots and time
     * values are probably always really wacked with respect to what
     * a manager would like to see.
     *
     * The following should be enough to:
     *
     * 1) prevent the library from doing discovery for engineid & time.
     * 2) use our engineid instead of the remote engineid for
     * authoritative & privacy related operations.
     * 3) The remote engine must be configured with users for our engineID.
     *
     * -- Wes
     */

    /*
     * setup the engineID based on IP addr.     Need a different
     * algorthim here.  This will cause problems with agents on the
     * same machine sending traps.
     */
    setup_engineID(NULL, NULL);

    /*
     * pick our own engineID
     */
    if (session.securityEngineIDLen == 0 ||
        session.securityEngineID == NULL) {
        session.securityEngineID =
        snmpv3_generate_engineID(&session.securityEngineIDLen);
    }
    if (session.contextEngineIDLen == 0 ||
        session.contextEngineID == NULL) {
        session.contextEngineID =
        snmpv3_generate_engineID(&session.contextEngineIDLen);
    }

    /*
     * set boots and time, which will cause problems if this
     * machine ever reboots and a remote trap receiver has cached our
     * boots and time...  I'll cause a not-in-time-window report to
     * be sent back to this machine.
     */
    if (session.engineBoots == 0)
        session.engineBoots = 1;
    if (session.engineTime == 0)    /* not really correct, */
        session.engineTime = get_uptime();    /* but it'll work. Sort of. */
    }

    ss = snmp_open(&session);
    if (ss == NULL) {
    /*
     * diagnose snmp_open errors with the input netsnmp_session pointer
     */
    snmp_sess_perror("snmptrap", &session);

    SOCK_CLEANUP;
    exit(1);
    }

    if (session.version == SNMP_VERSION_1) {
        DEBUGMSGTL(("nuri/rtm",
                    "SNMP_VERSION_1 trap is not supported by this appln.\n"));
        return 1;
    } else {
    long        sysuptime;
    char        csysuptime[20];

    pdu = snmp_pdu_create(SNMP_MSG_TRAP2);

#ifdef WIN32
    sysuptime = RTM_Get_Uptime_Win ();
    printf ("***********sysuptime=%ld$\n", sysuptime);
#else
    sysuptime = get_uptime();
#endif
    sprintf(csysuptime, "%ld", sysuptime);
    trap = csysuptime;

    snmp_add_var(pdu, objid_sysuptime,
             sizeof(objid_sysuptime) / sizeof(oid), 't', trap);

    if (snmp_add_var
        (pdu, objid_snmptrap, sizeof(objid_snmptrap) / sizeof(oid),
         'o', NURI_ENTERPRISE_OID) != 0) {
        snmp_perror("objid_snmptrap");
        printf ("***** objid_snmptrap problem...exiting....\n");
        SOCK_CLEANUP;
        exit(1);
       }
    }

    name_length = MAX_OID_LEN;

    for (cnt = 0; cnt < length; cnt++)
    {

        if (!snmp_parse_oid(args[cnt].variable, name, &name_length)) {
            DEBUGMSGTL(("nuri/rtm", "* trap argument oid problem....\n"));
            SOCK_CLEANUP;
            exit(1);
        }

        if (snmp_add_var
            (pdu, name, name_length, args[cnt].type, args[cnt].value) != 0) {
           DEBUGMSGTL(("nuri/rtm", "cnt=%d name=%s namelen=%d "
            "SNMPTRAP arg. type and value problem\n", cnt, name, name_length));
        SOCK_CLEANUP;
        exit(1);
        }
    }

    status = snmp_send (ss, pdu) == 0;
    if (status) {
        snmp_sess_perror("snmptrap", ss);
        snmp_free_pdu(pdu);
        exitval = 1;
    }

    snmp_close(ss);
    SOCK_CLEANUP;
    return exitval;
}

/*****************************************************************************
 * name             :   RTM_Fetch_Var_Val
 * description      :   To retrieve the value of the variable.
 * input parameters :   oid *name - The OID of the variable in oid array
 * output parameters:   u_long *pulNewValue - Retrieved value
 * return type      :   int
 * global variables :
 * calls            :   RTM_callback
 *****************************************************************************/

static int
RTM_Fetch_Var_Val (oid * name, size_t namelen, u_long *pulNewValue)
{
    struct variable *pstVarPtr = NULL;
    netsnmp_subtree *pstSPtr = NULL;
    register u_char *ucAccess = NULL;
    size_t var_len;
    struct variable stCalledVar = { 0 };
    WriteMethod    *write_method = NULL;

    /* Find the subtree corresponding to the variable */
    pstSPtr = netsnmp_subtree_find (name,namelen,NULL,"");

    if (pstSPtr!=NULL)
    { 
        pstVarPtr = pstSPtr->reginfo->handler->next->myvoid;
        if (pstVarPtr!=NULL)
        {
            stCalledVar.namelen = namelen-1;
            stCalledVar.type = pstVarPtr->type;
            stCalledVar.magic = pstVarPtr->magic;
            stCalledVar.acl = pstVarPtr->acl;
            stCalledVar.findVar = pstVarPtr->findVar;
            memcpy(stCalledVar.name,name, ((namelen * sizeof(oid))-1));

	    /* Call the method routine to fetch the value */
            ucAccess = pstVarPtr->findVar (&stCalledVar,name, &namelen, 1,
                                                        &var_len,&write_method);
            
        }
        else
        {
            DEBUGMSGTL(("nuri/rtm", "pstVarPtr IS NULL! MAGIC NOT FOUND\n"));
            return 1;
        }
    }

    if (ucAccess != NULL)
    {
        *pulNewValue = *(u_long *) ucAccess;
    }
    else
    {
        DEBUGMSGTL(("nuri/rtm", "VALUE ucAccess IS NULL!\n"));
        return 2;
    }
    return 0;
}

/*****************************************************************************
 * name             :   RTM_Log_Trap_Details
 * description      :   Log the trap details in a file
 * input parameters :   int length - Number of items to log
 *                      stVarBindArgs *args - Details of the item to log
 *                      trapTable_context *ctx - pointer to row of trapTable
 * output parameters:
 * return type      :   int
 * global variables :
 * calls            :   RTM_callback
 *****************************************************************************/

int
RTM_Log_Trap_Details (int length, stVarBindArgs *args, trapTable_context *ctx)
{
    int cnt = 0;
    int fdt = 0;
    struct stat status;
    struct in_addr  laddr = { 0 };
    char tmp_str[80] = { 0 };
  
    RTM_Get_ASCII_Time (tmp_str);
    
    fprintf (fpt, "%s INDEX=%lu ARGS:\n", tmp_str, ctx->trapIndex);

    for (cnt = 0; cnt < length; cnt++)
    {
        fprintf (fpt, "args[%d].variable=%s type=%c value=%s\n", cnt,
                       args[cnt].variable, args[cnt].type, args[cnt].value);
    }

    laddr.s_addr = ctx->trapDestinationIP;
   
    fprintf (fpt, "Destination IP=%s  Port=%ld\n",
                                 (char *) inet_ntoa (laddr), ctx->trapPort);
    fflush (fpt);

    /* Check if the file size exceeds the limit */
    fdt = fileno (fpt);
    if (fstat (fdt, &status) == 0)
    {
        if (status.st_size >= fsize)
        {
            fclose (fpt);
            sprintf (tmp_str, "%s.1", fpath);
            rename (fpath, tmp_str);

            fpt = fopen (fpath, "w");
            if (fpt == (FILE *) NULL)
            {
                DEBUGMSGTL(("nuri/rtm",
                   "Couldn't open %s file errno=%d\n", fpath, errno));
                return 1;
            }
        }
    }
    else
    {
        DEBUGMSGTL(("nuri/rtm",
                    "Couldn't find stat of %s file errno=%d\n", fpath, errno));
        return 1;
    }

    return 0;
}

/*****************************************************************************
 * name             :   RTM_Get_ASCII_Time
 * description      :   Returns current time stamp in ASCII format
 * input parameters :
 * output parameters:   char *time_str - resultant time stamp is stored here
 * return type      :   int
 * global variables :
 * calls            :   RTM_Log_Trap_Details
 *****************************************************************************/

int
RTM_Get_ASCII_Time (char *pcTimeStr)
{
    char *pcPtr;
    struct tm stTm;
    struct timeval stTv;

    gettimeofday(&stTv, (struct timezone *) 0);
    memcpy(&stTm, localtime((time_t *) & stTv.tv_sec), sizeof(stTm));

    errno = 0;
    if ((pcPtr = asctime (&stTm)) ==  (char *) NULL)
    {
           DEBUGMSGTL(("nuri/rtm", "asctime returns NULL errno=%d\n", errno));
           return 1;
    }

    if (pcPtr[strlen(pcPtr) - 1] == '\n')
        pcPtr[strlen(pcPtr) - 1] = '\0';

    strcpy (pcTimeStr, pcPtr);
    return 0;
}

#ifdef WIN32
long
RTM_Get_Uptime_Win()
{
    long uptim = 0;
    
          uptim=GetTickCount();
		  uptim=(long)(uptim/10);
          return uptim;
}
#endif /* WIN32 */

/* <End: WIP_NURI_ALL > */

/* End of trapTable.c */
