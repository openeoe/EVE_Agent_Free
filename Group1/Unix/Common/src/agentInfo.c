/*$Id: agentInfo.c,v 1.9 2003/11/21 09:17:10 rajesh Exp $*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
/* <Start: WIP_NURI_ALL > */
// For File Transfer Module
#include <pthread.h>
#include <string.h> /* memset() */
#include <sys/stat.h>
#include <fcntl.h>
#define MAX_MSG 8000 
/*<Start: WIP_NURI_WIN >*/
#ifndef WIN32
#include <sys/time.h> /* select() */ 
#include <netdb.h>
#else
#include <io.h> 
#endif
/* <End: WIP_NURI_WIN > */
/* <End: WIP_NURI_ALL > */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "agentInfo.h"

/* <Start: WIP_NURI_ALL > */
// Persistent file location
#ifndef WIN32
#define AGENT_INFO_FILE "/usr/local/conf/agentInfo.conf"
#else
#define AGENT_INFO_FILE "agentInfo.conf"
#endif

#define IPADD_LEN 4
#define DATEANDTIME_LEN 11
#define EMPTY_STR "x"
#define STR_LEN 255
#define FILE_TRANSFER_INTERVAL 120 // in seconds
#define FILE_TRANSFER_PORT 2000 // default port
/* Log file names for various modules */
char gcInfoLogFileNetApp[STR_LEN] = EMPTY_STR;
char gcInfoLogFileJob[STR_LEN] = EMPTY_STR;
char gcInfoLogFileFB[STR_LEN] = EMPTY_STR;
char gcInfoLogFileProc[STR_LEN] = EMPTY_STR;
char gcInfoLogFileMonRow[STR_LEN] = EMPTY_STR;
char gcInfoLogFileTrans[STR_LEN] = EMPTY_STR;
char gcInfoLogFileAppMetr[STR_LEN] = EMPTY_STR;
char gcInfoLogFileSystemData[STR_LEN] = EMPTY_STR;
char gcInfoLogFileDist[STR_LEN] = EMPTY_STR;
char gcInfoLogFileRBM[STR_LEN] = EMPTY_STR;
char gcInfoLogFileCmd[STR_LEN] = EMPTY_STR;
char gcInfoLogFileMonCol[STR_LEN] = EMPTY_STR;
char gcInfoLogFile[STR_LEN] = EMPTY_STR;
char gcInfoLogFileUserCtl[STR_LEN] = EMPTY_STR;
/* NASCenter Sub Agent Information*/
char gcAgentInfoFileTransferIP[IPADD_LEN];
char gcAgentInfoIP[IPADD_LEN];
char gcAgentInfoAlertMgrIp[IPADD_LEN];
char gcAgentInfoLoc[STR_LEN] = EMPTY_STR;
char gcAgentInfoOS[STR_LEN] = EMPTY_STR;
char gcAgentInfoOSDescr[STR_LEN] = EMPTY_STR;
char gcAgentInfoInstallDate[DATEANDTIME_LEN]={ 0,0,0,0,0,0,0,0,0,0,0};
char gcAgentInfoName[STR_LEN]= EMPTY_STR;
char gcAgentInfoLicence[STR_LEN]= EMPTY_STR;
long glAgentInfoSysTime = 0;
long glAgentInfoSerialNo= 0;
long glAgentInfoAlertMgrPort = 0;
long glAgentInfoFileTrInterval = FILE_TRANSFER_INTERVAL;
long glAgentInfoFileTrPort = FILE_TRANSFER_PORT;

//Alarm Registration ID
int clientRegID;
// The File transfer callback function for the snmp_alarm
void fileTransferCallBack(unsigned int clreg, void *arg);

// The function to save configuration in a file
void writeToFile();
// The function to read configuration file
void readFromFile();

/* <End: WIP_NURI_ALL > */


/** Initializes the agentInfo module */
void
init_agentInfo(void)
{
    static oid agentInfoLogFileNetAppliance_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,23, 0 };
    static oid agentInfoFileTransferIP_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,13, 0 };
    static oid agentInfoLocation_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,9, 0 };
    static oid agentInfoLogFileJobProcess_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,20, 0 };
    static oid agentInfoOS_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,7, 0 };
    static oid agentInfoOSDescription_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,8, 0 };
    static oid agentInfoLogFileBackup_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,19, 0 };
    static oid agentInfoAlertManagerIP_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,4, 0 };
    static oid agentInfoLogFileProcess_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,18, 0 };
    static oid agentInfoLogFileMonRow_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,17, 0 };
    static oid agentInfoInstallDate_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,6, 0 };
    static oid agentInfoLogFileTransaction_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,22, 0 };
    static oid agentInfoName_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,2, 0 };
    static oid agentInfoLogFileAppMetering_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,21, 0 };
    static oid agentInfoLogFileSystemData_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,15, 0 };
    static oid agentInfoLicence_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,11, 0 };
    static oid agentInfoLogFileDistribution_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,26, 0 };
    static oid agentInfoLogFileRBM_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,25, 0 };
    static oid agentInfoLogFileMonCol_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,16, 0 };
    static oid agentInfoLogFileTransfer_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,28, 0 };
    static oid agentInfoLogFileCommand_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,27, 0 };
    static oid agentInfoSystemTime_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,10, 0 };
    static oid agentInfoIP_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,1, 0 };
    static oid agentInfoLogFileUserControl_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,24, 0 };
    static oid agentInfoFileTransferInterval_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,12, 0 };
    static oid agentInfoFileTransferPort_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,14, 0 };
    static oid agentInfoAlertManagerPort_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,5, 0 };
    static oid agentInfoSerialNo_oid[] = { 1,3,6,1,4,1,3204,1,3,36,1,3, 0 };

  DEBUGMSGTL(("agentInfo", "Initializing\n"));
 
  netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoSerialNo",
                               do_agentInfoSerialNo,
                               agentInfoSerialNo_oid,
                               OID_LENGTH(agentInfoSerialNo_oid),
                               HANDLER_CAN_RWRITE));

  netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoAlertManagerPort",
                               do_agentInfoAlertManagerPort,
                               agentInfoAlertManagerPort_oid,
                               OID_LENGTH(agentInfoAlertManagerPort_oid),
                               HANDLER_CAN_RWRITE));

  netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoFileTransferPort",
                               do_agentInfoFileTransferPort,
                               agentInfoFileTransferPort_oid,
                               OID_LENGTH(agentInfoFileTransferPort_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoFileTransferInterval",
                               do_agentInfoFileTransferInterval,
                               agentInfoFileTransferInterval_oid,
                               OID_LENGTH(agentInfoFileTransferInterval_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileNetAppliance",
                               do_agentInfoLogFileNetAppliance,
                               agentInfoLogFileNetAppliance_oid,
                               OID_LENGTH(agentInfoLogFileNetAppliance_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoFileTransferIP",
                               do_agentInfoFileTransferIP,
                               agentInfoFileTransferIP_oid,
                               OID_LENGTH(agentInfoFileTransferIP_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLocation",
                               do_agentInfoLocation,
                               agentInfoLocation_oid,
                               OID_LENGTH(agentInfoLocation_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileJobProcess",
                               do_agentInfoLogFileJobProcess,
                               agentInfoLogFileJobProcess_oid,
                               OID_LENGTH(agentInfoLogFileJobProcess_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("agentInfoOS",
                                         get_agentInfoOS,
                                         agentInfoOS_oid,
                                         OID_LENGTH(agentInfoOS_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("agentInfoOSDescription",
                                         get_agentInfoOSDescription,
                                         agentInfoOSDescription_oid,
                                         OID_LENGTH(agentInfoOSDescription_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileBackup",
                               do_agentInfoLogFileBackup,
                               agentInfoLogFileBackup_oid,
                               OID_LENGTH(agentInfoLogFileBackup_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoAlertManagerIP",
                               do_agentInfoAlertManagerIP,
                               agentInfoAlertManagerIP_oid,
                               OID_LENGTH(agentInfoAlertManagerIP_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileProcess",
                               do_agentInfoLogFileProcess,
                               agentInfoLogFileProcess_oid,
                               OID_LENGTH(agentInfoLogFileProcess_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileMonRow",
                               do_agentInfoLogFileMonRow,
                               agentInfoLogFileMonRow_oid,
                               OID_LENGTH(agentInfoLogFileMonRow_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoInstallDate",
                               do_agentInfoInstallDate,
                               agentInfoInstallDate_oid,
                               OID_LENGTH(agentInfoInstallDate_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileTransaction",
                               do_agentInfoLogFileTransaction,
                               agentInfoLogFileTransaction_oid,
                               OID_LENGTH(agentInfoLogFileTransaction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoName",
                               do_agentInfoName,
                               agentInfoName_oid,
                               OID_LENGTH(agentInfoName_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileAppMetering",
                               do_agentInfoLogFileAppMetering,
                               agentInfoLogFileAppMetering_oid,
                               OID_LENGTH(agentInfoLogFileAppMetering_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileSystemData",
                               do_agentInfoLogFileSystemData,
                               agentInfoLogFileSystemData_oid,
                               OID_LENGTH(agentInfoLogFileSystemData_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLicence",
                               do_agentInfoLicence,
                               agentInfoLicence_oid,
                               OID_LENGTH(agentInfoLicence_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileDistribution",
                               do_agentInfoLogFileDistribution,
                               agentInfoLogFileDistribution_oid,
                               OID_LENGTH(agentInfoLogFileDistribution_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileRBM",
                               do_agentInfoLogFileRBM,
                               agentInfoLogFileRBM_oid,
                               OID_LENGTH(agentInfoLogFileRBM_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileMonCol",
                               do_agentInfoLogFileMonCol,
                               agentInfoLogFileMonCol_oid,
                               OID_LENGTH(agentInfoLogFileMonCol_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileTransfer",
                               do_agentInfoLogFileTransfer,
                               agentInfoLogFileTransfer_oid,
                               OID_LENGTH(agentInfoLogFileTransfer_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileCommand",
                               do_agentInfoLogFileCommand,
                               agentInfoLogFileCommand_oid,
                               OID_LENGTH(agentInfoLogFileCommand_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("agentInfoSystemTime",
                                         get_agentInfoSystemTime,
                                         agentInfoSystemTime_oid,
                                         OID_LENGTH(agentInfoSystemTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("agentInfoIP",
                                         get_agentInfoIP,
                                         agentInfoIP_oid,
                                         OID_LENGTH(agentInfoIP_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("agentInfoLogFileUserControl",
                               do_agentInfoLogFileUserControl,
                               agentInfoLogFileUserControl_oid,
                               OID_LENGTH(agentInfoLogFileUserControl_oid),
                               HANDLER_CAN_RWRITE));

/* <Start: WIP_NURI_ALL > */
	clientRegID = snmp_alarm_register(glAgentInfoFileTrInterval,
					SA_REPEAT,fileTransferCallBack
						,NULL);
/* <End: WIP_NURI_ALL > */
	readFromFile();
}


int
do_agentInfoLogFileNetAppliance(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) gcInfoLogFileNetApp,strlen(gcInfoLogFileNetApp));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileNetApp,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileNetApp[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoFileTransferIP(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
							(u_char *) gcAgentInfoFileTransferIP, IPADD_LEN);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
							requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcAgentInfoFileTransferIP, 
					requests->requestvb->val.string, 
					requests->requestvb->val_len);
		    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_agentInfoLocation(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcAgentInfoLoc, strlen(gcAgentInfoLoc));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcAgentInfoLoc,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcAgentInfoLoc[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_agentInfoLogFileJobProcess(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileJob, 
							strlen(gcInfoLogFileJob));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileJob,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileJob[requests->requestvb->val_len] ='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
  
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_agentInfoOS(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) gcAgentInfoOS, strlen(gcAgentInfoOS));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_agentInfoOSDescription(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) gcAgentInfoOSDescr, strlen(gcAgentInfoOSDescr));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileBackup(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileFB, 
							strlen(gcInfoLogFileFB));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileFB,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileFB[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoAlertManagerIP(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, 
							(u_char *) gcAgentInfoAlertMgrIp, IPADD_LEN);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_IPADDRESS ||
							requests->requestvb->val_len!=IPADD_LEN) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcAgentInfoAlertMgrIp,requests->requestvb->val.string,
									requests->requestvb->val_len);
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileProcess(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileProc, 
							strlen(gcInfoLogFileProc));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileProc,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileProc[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_agentInfoLogFileMonRow(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileMonRow, 
							strlen(gcInfoLogFileMonRow));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileMonRow,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileMonRow[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoInstallDate(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcAgentInfoInstallDate, 
							DATEANDTIME_LEN);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcAgentInfoInstallDate,requests->requestvb->val.string,
									requests->requestvb->val_len);
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileTransaction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileTrans, 
							strlen(gcInfoLogFileTrans));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileTrans,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileTrans[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
 
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcAgentInfoName, 
							strlen(gcAgentInfoName));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcAgentInfoName,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcAgentInfoName[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileAppMetering(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileAppMetr, 
							strlen(gcInfoLogFileAppMetr));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileAppMetr,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileAppMetr[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileSystemData(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileSystemData, 
							strlen(gcInfoLogFileSystemData));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileSystemData,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileSystemData[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLicence(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcAgentInfoLicence, 
							strlen(gcAgentInfoLicence));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcAgentInfoLicence,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcAgentInfoLicence[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileDistribution(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileDist, 
							strlen(gcInfoLogFileDist));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileDist,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileDist[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_agentInfoLogFileRBM(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileRBM, 
							strlen(gcInfoLogFileRBM));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileRBM,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileRBM[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileMonCol(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileMonCol, 
							strlen(gcInfoLogFileMonCol));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileMonCol,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileMonCol[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileTransfer(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFile, 
							strlen(gcInfoLogFile));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFile,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFile[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileCommand(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileCmd, 
							strlen(gcInfoLogFileCmd));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileCmd,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileCmd[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_agentInfoSystemTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS, 
							(u_char *) &glAgentInfoSysTime, 
							sizeof(glAgentInfoSysTime));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_agentInfoIP(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) gcAgentInfoIP, IPADD_LEN);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_agentInfoLogFileUserControl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
							(u_char *) gcInfoLogFileUserCtl, 
							strlen(gcInfoLogFileUserCtl));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_OCTET_STR) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		memcpy(gcInfoLogFileUserCtl,requests->requestvb->val.string,
									requests->requestvb->val_len);
				gcInfoLogFileUserCtl[requests->requestvb->val_len]='\0';
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
  
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_agentInfoSerialNo(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
							(u_char *) &glAgentInfoSerialNo, 
							sizeof(glAgentInfoSerialNo));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		glAgentInfoSerialNo = *(requests->requestvb->val.integer);
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_agentInfoAlertManagerPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
							(u_char *) &glAgentInfoAlertMgrPort, 
							sizeof(glAgentInfoAlertMgrPort));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		glAgentInfoAlertMgrPort = *(requests->requestvb->val.integer);
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_agentInfoFileTransferInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
							(u_char *) &glAgentInfoFileTrInterval, 
							sizeof(glAgentInfoFileTrInterval));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		glAgentInfoFileTrInterval = *(requests->requestvb->val.integer);
				snmp_alarm_unregister(clientRegID);
				clientRegID = snmp_alarm_register(glAgentInfoFileTrInterval,
					SA_REPEAT,fileTransferCallBack
						,NULL);
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_agentInfoFileTransferPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

		/* <Start: WIP_NURI_ALL > */
        case MODE_GET:

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
							(u_char *) &glAgentInfoFileTrPort, 
							sizeof(glAgentInfoFileTrPort));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (requests->requestvb->type!= ASN_INTEGER) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            } else {
	    		glAgentInfoFileTrPort = *(requests->requestvb->val.integer);
	    	}
		writeToFile(); /* <End: WIP_NURI_ALL > */
            break;

        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* <Start: WIP_NURI_ALL > */


/* This function will convert the IP address stored in asnFormat to 
 * dotted format IP. Buff should contain sufficient memory for storing the 
 * dotted decimal format IP */
void getIPFromASNFormat(char *asnFormat, char *buff){
	sprintf(buff,"%d.%d.%d.%d",(0xff& asnFormat[0]),(0xff & asnFormat[1]),
								(0xff&asnFormat[2]),
								(0xff&asnFormat[3]));
}

int transferFile() {
    int sd, rc, i;
    struct sockaddr_in cliAddr, remoteServAddr;
    struct hostent *h;
    int fp;
	char managerIP[16];
    char *buff=NULL ;
    char * ptr;
#ifdef WIN32
    WSADATA wsaData;
#endif
    int f_size = 0;
    struct stat status;
    long read_bytes = 0;
    int  sendbuff = 15000;
    struct timeval timeval;

#ifdef WIN32
    if ( WSAStartup(0x202,&wsaData) != 0)
    {
        WSACleanup();
        return -1;
    }
#endif
    
	if(stat(gcInfoLogFileSystemData, &status)<0){
		return -1;
	}

    /* get server IP address (no check if input is IP address or DNS name */
	getIPFromASNFormat(gcAgentInfoFileTransferIP,managerIP);
    
	

    /* Set the remote server address and port */
    remoteServAddr.sin_family = AF_INET;
	remoteServAddr.sin_addr.s_addr = inet_addr(managerIP);
    remoteServAddr.sin_port = htons(glAgentInfoFileTrPort);

    /* socket creation */
    sd = socket(AF_INET,SOCK_DGRAM,0);
    if(sd<0) 
    {
        return -1;
    }

     setsockopt(sd, SOL_SOCKET,SO_RCVBUF, &sendbuff, sizeof(sendbuff)) ;

  
    /* bind any port */
    cliAddr.sin_family = AF_INET;
    cliAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    rc = bind(sd, (struct sockaddr *) &cliAddr, sizeof(cliAddr));
    if(rc<0) 
    {
        return -1;
    }

    fp = open(gcInfoLogFileSystemData, O_RDONLY | O_CREAT);
    if (fp  == -1)
    {
        return -1;
    }
    buff = (char *)malloc(sizeof(char)*MAX_MSG);

    /* Find the file size and send it to server */
    f_size = status.st_size;
    sendto(sd, (char *)&f_size, sizeof(unsigned long), 0, (struct sockaddr *) &remoteServAddr, sizeof(remoteServAddr));

    while ((read_bytes = read(fp , buff , MAX_MSG)) > 0)
    {
        /* send data */
        rc = sendto(sd, buff, read_bytes, 0, (struct sockaddr *) &remoteServAddr, sizeof(remoteServAddr));
	/* Delay so that server will receive the data */
	timeval.tv_sec = 0;
        timeval.tv_usec = 2000;
	select(0,NULL,NULL,NULL,&timeval);
    }
    timeval.tv_sec = 0;
    timeval.tv_usec = 10000;
    select(0,NULL,NULL,NULL,&timeval);
    memset(buff ,'\0' , MAX_MSG * sizeof(char));
	close(fp);
	close(sd);
    free(buff);

}

void *thFunction(void *arg){
	transferFile();
	pthread_detach(pthread_self());
}

// The alarm Callback Function for transfering the file
void fileTransferCallBack(unsigned int clreg, void *arg){
	pthread_t  thID;
	pthread_create(&thID,NULL,thFunction,NULL);
}

void writeToFile() {
	FILE *fp;
	int i;
	char tempBuff[10];
	fp=fopen(AGENT_INFO_FILE,"w");
	if(fp!=NULL){
		// The Log Files
		fprintf(fp,"%s\n",gcInfoLogFileNetApp);
		fprintf(fp,"%s\n",gcInfoLogFileJob);
		fprintf(fp,"%s\n",gcInfoLogFileFB);
		fprintf(fp,"%s\n",gcInfoLogFileMonRow);
		fprintf(fp,"%s\n",gcInfoLogFileTrans);
		fprintf(fp,"%s\n",gcInfoLogFileAppMetr);
		fprintf(fp,"%s\n",gcInfoLogFileSystemData);
		fprintf(fp,"%s\n",gcInfoLogFileDist);
		fprintf(fp,"%s\n",gcInfoLogFileRBM);
		fprintf(fp,"%s\n",gcInfoLogFileCmd);
		fprintf(fp,"%s\n",gcInfoLogFile);
		fprintf(fp,"%s\n",gcInfoLogFileUserCtl);
		fprintf(fp,"%s\n",gcInfoLogFileMonCol);
		fprintf(fp,"%s\n",gcInfoLogFileProc);
		
		fprintf(fp,"%s\n",gcAgentInfoLoc);
		fprintf(fp,"%s\n",gcAgentInfoOS);
		fprintf(fp,"%s\n",gcAgentInfoOSDescr);

		fprintf(fp,"%s\n",gcAgentInfoName);
		fprintf(fp,"%s\n",gcAgentInfoLicence);
		
		// The Agent Parameters
		fprintf(fp,"%d\n",glAgentInfoSysTime);
		fprintf(fp,"%d\n",glAgentInfoSerialNo);
		fprintf(fp,"%d\n",glAgentInfoAlertMgrPort);
		fprintf(fp,"%d\n",glAgentInfoFileTrInterval);
		fprintf(fp,"%d\n",glAgentInfoFileTrPort);

		// IP address
		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcAgentInfoFileTransferIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}
		
		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcAgentInfoIP[i]);
			fprintf(fp,"%s\n",tempBuff);
		}
		
		for(i=0;i<IPADD_LEN;i++){
			sprintf(tempBuff,"%d",gcAgentInfoAlertMgrIp[i]);
			fprintf(fp,"%s\n",tempBuff);
		}

		// TimeTicks
		for(i=0;i<DATEANDTIME_LEN;i++){
			sprintf(tempBuff,"%d",gcAgentInfoInstallDate[i]);
			fprintf(fp,"%s\n",tempBuff);
		}
		
		fflush(fp);
		fclose(fp);
	}
}


void readFromFile() {
	FILE *fp;
	int i;
	char tempBuff[10];
	fp=fopen(AGENT_INFO_FILE,"r");
	if(fp!=NULL){
		// The Log Files
		fscanf(fp,"%s\n",gcInfoLogFileNetApp);
		fscanf(fp,"%s\n",gcInfoLogFileJob);
		fscanf(fp,"%s\n",gcInfoLogFileFB);
		fscanf(fp,"%s\n",gcInfoLogFileMonRow);
		fscanf(fp,"%s\n",gcInfoLogFileTrans);
		fscanf(fp,"%s\n",gcInfoLogFileAppMetr);
		fscanf(fp,"%s\n",gcInfoLogFileSystemData);
		fscanf(fp,"%s\n",gcInfoLogFileDist);
		fscanf(fp,"%s\n",gcInfoLogFileRBM);
		fscanf(fp,"%s\n",gcInfoLogFileCmd);
		fscanf(fp,"%s\n",gcInfoLogFile);
		fscanf(fp,"%s\n",gcInfoLogFileUserCtl);
		fscanf(fp,"%s\n",gcInfoLogFileMonCol);
		fscanf(fp,"%s\n",gcInfoLogFileProc);
		
		fscanf(fp,"%s\n",gcAgentInfoLoc);
		fscanf(fp,"%s\n",gcAgentInfoOS);
		fscanf(fp,"%s\n",gcAgentInfoOSDescr);

		fscanf(fp,"%s\n",gcAgentInfoName);
		fscanf(fp,"%s\n",gcAgentInfoLicence);
		
		// The Agent Parameters
		fscanf(fp,"%d\n",&glAgentInfoSysTime);
		fscanf(fp,"%d\n",&glAgentInfoSerialNo);
		fscanf(fp,"%d\n",&glAgentInfoAlertMgrPort);
		fscanf(fp,"%d\n",&glAgentInfoFileTrInterval);
		fscanf(fp,"%d\n",&glAgentInfoFileTrPort);

		// IP address
		
		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcAgentInfoFileTransferIP[i] = atoi(tempBuff);
		}
		
		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcAgentInfoIP[i] = atoi(tempBuff);
		}
		
		for(i=0;i<IPADD_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcAgentInfoAlertMgrIp[i]=atoi(tempBuff);
		}

		// TimeTicks
		for(i=0;i<DATEANDTIME_LEN;i++){
			fscanf(fp,"%s\n",tempBuff);
			gcAgentInfoInstallDate[i] = atoi(tempBuff);
		}
		fclose(fp);
	}
}

/* <End: WIP_NURI_ALL > */

