/* Id: $*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.array-user.conf,v 5.15.2.1 2003/02/27 05:59:41 rstory Exp $
 *
 * $Id: transactionTable.h,v 1.13 2004/01/05 05:34:03 saisk Exp $
 *
 * Yes, there is lots of code here that you might not use. But it is much
 * easier to remove code than to add it!
 */
#ifndef TRANSACTIONTABLE_H
#define TRANSACTIONTABLE_H

#ifdef __cplusplus
extern "C" {
#endif

   
/* Begin: WIP_NURI_ALL */
#ifndef linux
#ifdef WIN32
#include "../winpcap/Include/pcap.h"
#else
#include <pcap.h>
#endif
#endif
/*#include <netinet/in.h> */
#include <errno.h>
#ifdef linux
#include <pcap-bpf.h>
#include <pcap.h>
#endif

#ifdef WIN32
#include "../../Windows/Common/inc/pthread.h"
#else
#include <pthread.h>
#endif

/* End: WIP_NURI_ALL */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/library/container.h>
#include <net-snmp/agent/table_array.h>

#ifdef WORDS_BIGENDIAN 
#undef __LITTLE_ENDIAN_BITFIELD
#define __BIG_ENDIAN_BITFIELD
#else
#undef __BIG_ENDIAN_BITFIELD
#define __LITTLE_ENDIAN_BITFIELD
#endif


#ifndef TYPES
#define TYPES

typedef unsigned char __u8;
typedef unsigned short __u16;
typedef unsigned int __u32;
#endif

#if !defined(linux)
struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
        __u8    ihl:4,
                version:4;
#elif defined (__BIG_ENDIAN_BITFIELD)
        __u8    version:4,
                ihl:4;
#else
#error  "Please fix <asm/byteorder.h>"
#endif
        __u8    tos;
        __u16   tot_len;
        __u16   id;
        __u16   frag_off;
        __u8    ttl;
        __u8    protocol;
        __u16   check;
        __u32   saddr;
        __u32   daddr;
};
#endif

struct tcphdr {
        __u16   source;
        __u16   dest;
        __u32   seq;
        __u32   ack_seq;
#if defined(__LITTLE_ENDIAN_BITFIELD)
        __u16   res1:4,
                doff:4,
                fin:1,
                syn:1,
                rst:1,
                psh:1,
                ack:1,
                urg:1,
                ece:1,
                cwr:1;
#elif defined(__BIG_ENDIAN_BITFIELD)
        __u16   doff:4,
                res1:4,
                cwr:1,
                ece:1,
                urg:1,
                ack:1,
                psh:1,
                rst:1,
                syn:1,
                fin:1;
#else
#error  "Adjust your <asm/byteorder.h> defines"
#endif 
        __u16   window;
        __u16   check;
        __u16   urg_ptr;
};

        /** Index transactionIndex is internal */

typedef struct transactionTable_context_s {
    netsnmp_index index; /** THIS MUST BE FIRST!!! */

    /*************************************************************
     * You can store data internally in this structure.
     *
     * TODO: You will probably have to fix a few types here...
     */
        /** INTEGER = ASN_INTEGER */
            long transactionIndex;

        /** OCTETSTR = ASN_OCTET_STR */
            unsigned char transactionClientAddress[15];
            long transactionClientAddress_len;

        /** DisplayString = ASN_OCTET_STR */
            unsigned char transactionApplication[40];
            long transactionApplication_len;

        /** INTEGER = ASN_INTEGER */
            long transactionTransportPort;

        /** INTEGER = ASN_INTEGER */
            long transactionSampleInterval;

        /** DateAndTime = ASN_OCTET_STR */
            unsigned char transactionCreateDateTime[15];
            long transactionCreateDateTime_len;

        /** DisplayString = ASN_OCTET_STR */
            unsigned char transactionDescription[255];
            long transactionDescription_len;

        /** OCTETSTR = ASN_OCTET_STR */
            unsigned char transactionOwner[40];
            long transactionOwner_len;

        /** OCTETSTR = ASN_OCTET_STR */
            unsigned char transactionCurrentClientAddress[15];
            long transactionCurrentClientAddress_len;

        /** DisplayString = ASN_OCTET_STR */
            unsigned char transactionCurrentTransactionApp[255];
            long transactionCurrentTransactionApp_len;

        /** INTEGER = ASN_INTEGER */
            long transactionResponseTime;

        /** COUNTER = ASN_COUNTER */
            unsigned long transactionInOctets;

        /** COUNTER = ASN_COUNTER */
            unsigned long transactionInPkts;

        /** COUNTER = ASN_COUNTER */
            unsigned long transactionOutOctets;

        /** COUNTER = ASN_COUNTER */
            unsigned long transactionOutPkts;

        /** RowStatus = ASN_INTEGER */
            long transactionStatus;


    /*
     * OR
     *
     * Keep a pointer to your data
     */
    void * data;

    /*
     *add anything else you want here
     */

	/* Begin: WIP_NURI_ALL */
    	long idx;
	long lastClientAckNumber;
	long lastTrTime;
	/* End: WIP_NURI_ALL */

} transactionTable_context;

/*************************************************************
 * function declarations
 */
void init_transactionTable(void);
void initialize_table_transactionTable(void);
const transactionTable_context * transactionTable_get_by_idx(netsnmp_index *);
const transactionTable_context * transactionTable_get_by_idx_rs(netsnmp_index *,
                                        int row_status);
int transactionTable_get_value(netsnmp_request_info *, netsnmp_index *, netsnmp_table_request_info *);


/*************************************************************
 * oid declarations
 */
extern oid transactionTable_oid[];
extern size_t transactionTable_oid_len;

#define transactionTable_TABLE_OID 1,3,6,1,4,1,3204,1,3,31,1
    
/*************************************************************
 * column number definitions for table transactionTable
 */
#define COLUMN_TRANSACTIONINDEX 1
#define COLUMN_TRANSACTIONCLIENTADDRESS 2
#define COLUMN_TRANSACTIONAPPLICATION 3
#define COLUMN_TRANSACTIONTRANSPORTPORT 4
#define COLUMN_TRANSACTIONSAMPLEINTERVAL 5
#define COLUMN_TRANSACTIONCREATEDATETIME 6
#define COLUMN_TRANSACTIONDESCRIPTION 7
#define COLUMN_TRANSACTIONOWNER 8
#define COLUMN_TRANSACTIONCURRENTCLIENTADDRESS 9
#define COLUMN_TRANSACTIONCURRENTTRANSACTIONAPP 10
#define COLUMN_TRANSACTIONRESPONSETIME 11
#define COLUMN_TRANSACTIONINOCTETS 12
#define COLUMN_TRANSACTIONINPKTS 13
#define COLUMN_TRANSACTIONOUTOCTETS 14
#define COLUMN_TRANSACTIONOUTPKTS 15
#define COLUMN_TRANSACTIONSTATUS 16
#define transactionTable_COL_MIN 2
#define transactionTable_COL_MAX 16

/* comment out the following line if you don't handle SET-REQUEST for transactionTable */
#define transactionTable_SET_HANDLING

/* comment out the following line if you can't create new rows */
#define transactionTable_ROW_CREATION

/* comment out the following line if you don't want the secondary index */
#define transactionTable_IDX2

/* uncommend the following line if you allow modifications to an
 * active row */
/** define transactionTable_CAN_MODIFY_ACTIVE_ROW */

#ifdef transactionTable_SET_HANDLING

int transactionTable_extract_index( transactionTable_context * ctx, netsnmp_index * hdr );

void transactionTable_set_reserve1( netsnmp_request_group * );
void transactionTable_set_reserve2( netsnmp_request_group * );
void transactionTable_set_action( netsnmp_request_group * );
void transactionTable_set_commit( netsnmp_request_group * );
void transactionTable_set_free( netsnmp_request_group * );
void transactionTable_set_undo( netsnmp_request_group * );

transactionTable_context * transactionTable_duplicate_row( transactionTable_context* );
netsnmp_index * transactionTable_delete_row( transactionTable_context* );

int transactionTable_can_activate(transactionTable_context *undo_ctx,
                      transactionTable_context *row_ctx,
                      netsnmp_request_group * rg);
int transactionTable_can_deactivate(transactionTable_context *undo_ctx,
                        transactionTable_context *row_ctx,
                        netsnmp_request_group * rg);
int transactionTable_can_delete(transactionTable_context *undo_ctx,
                    transactionTable_context *row_ctx,
                    netsnmp_request_group * rg);
    
    
#ifdef transactionTable_ROW_CREATION
transactionTable_context * transactionTable_create_row( netsnmp_index* );
#endif
#endif

#ifdef transactionTable_IDX2
transactionTable_context * transactionTable_get( const char *name, int len );
#endif

/* Begin: WIP_NURI_ALL */
#ifndef WIN32
#define TRANSACTION_CONTAINER_FILE "/usr/local/conf/transactionTable.conf"
#else
#define TRANSACTION_CONTAINER_FILE "transactionTable.conf"
#endif

void Load_Container_From_File();
void Tr_ResetCounters();
char gcErrorBuff[PCAP_ERRBUF_SIZE];
char *gcDevice;
pcap_t *gPcapHandle;
bpf_u_int32 gNetId, gNetMask;
/* Its assumed that the no of rows in the table (no of applications to be
 * monitored) does not go above 80 to 100 */
char gcFilter[1536];
struct bpf_program gBpfFilter;
pthread_t gPcapThreadId;
pthread_mutex_t gContainerLock;
int giPcapThreadStarted;
#define FILTER_FORMAT_STRING  "(tcp port %d and host %s)"
#define OR_STRING " or "
#define NULL_FILTER_STRING "host 0.0.0.0 and port 0"
int Tr_InitPcap();
void Tr_UpdateFilter();
/* End: WIP_NURI_ALL */

#ifdef __cplusplus
};
#endif

#endif /** TRANSACTIONTABLE_H */
